var _L2Block_l1BlockNumber;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { Body, TxHash } from '@aztec/circuit-types';
import { AppendOnlyTreeSnapshot, Header, STRING_ENCODING } from '@aztec/circuits.js';
import { sha256 } from '@aztec/foundation/crypto';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { makeAppendOnlyTreeSnapshot, makeHeader } from './l2_block_code_to_purge.js';
/**
 * The data that makes up the rollup proof, with encoder decoder functions.
 */
export class L2Block {
    constructor(
    /** Snapshot of archive tree after the block is applied. */
    archive, 
    /** L2 block header. */
    header, 
    /** L2 block body. */
    body, 
    /** Associated L1 block num */
    l1BlockNumber) {
        this.archive = archive;
        this.header = header;
        this.body = body;
        _L2Block_l1BlockNumber.set(this, void 0);
        __classPrivateFieldSet(this, _L2Block_l1BlockNumber, l1BlockNumber, "f");
    }
    /**
     * Constructs a new instance from named fields.
     * @param fields - Fields to pass to the constructor.
     * @param blockHash - Hash of the block.
     * @param l1BlockNumber - The block number of the L1 block that contains this L2 block.
     * @returns A new instance.
     */
    static fromFields(fields, l1BlockNumber) {
        return new this(fields.archive, fields.header, fields.body, l1BlockNumber);
    }
    /**
     * Deserializes a block from a buffer
     * @returns A deserialized L2 block.
     */
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        const header = reader.readObject(Header);
        const archive = reader.readObject(AppendOnlyTreeSnapshot);
        const body = reader.readObject(Body);
        return L2Block.fromFields({
            archive,
            header,
            body,
        });
    }
    /**
     * Serializes a block
     * @returns A serialized L2 block as a Buffer.
     */
    toBuffer() {
        return serializeToBuffer(this.header, this.archive, this.body);
    }
    /**
     * Deserializes L2 block from a buffer.
     * @param str - A serialized L2 block.
     * @returns Deserialized L2 block.
     */
    static fromString(str) {
        return L2Block.fromBuffer(Buffer.from(str, STRING_ENCODING));
    }
    /**
     * Serializes a block to a string.
     * @returns A serialized L2 block as a string.
     */
    toString() {
        return this.toBuffer().toString(STRING_ENCODING);
    }
    /**
     * Creates an L2 block containing random data.
     * @param l2BlockNum - The number of the L2 block.
     * @param txsPerBlock - The number of transactions to include in the block.
     * @param numPrivateCallsPerTx - The number of private function calls to include in each transaction.
     * @param numPublicCallsPerTx - The number of public function calls to include in each transaction.
     * @param numEncryptedLogsPerCall - The number of encrypted logs per 1 private function invocation.
     * @param numUnencryptedLogsPerCall - The number of unencrypted logs per 1 public function invocation.
     * @returns The L2 block.
     */
    static random(l2BlockNum, txsPerBlock = 4, numPrivateCallsPerTx = 2, numPublicCallsPerTx = 3, numEncryptedLogsPerCall = 2, numUnencryptedLogsPerCall = 1, numL1ToL2MessagesPerCall = 2) {
        const body = Body.random(txsPerBlock, numPrivateCallsPerTx, numPublicCallsPerTx, numEncryptedLogsPerCall, numUnencryptedLogsPerCall, numL1ToL2MessagesPerCall);
        const txsEffectsHash = body.getTxsEffectsHash();
        return L2Block.fromFields({
            archive: makeAppendOnlyTreeSnapshot(1),
            header: makeHeader(0, l2BlockNum, txsEffectsHash),
            body,
        }, 
        // just for testing purposes, each random L2 block got emitted in the equivalent L1 block
        BigInt(l2BlockNum));
    }
    get number() {
        return Number(this.header.globalVariables.blockNumber.toBigInt());
    }
    /**
     * Gets the L1 block number that included this block
     */
    getL1BlockNumber() {
        if (typeof __classPrivateFieldGet(this, _L2Block_l1BlockNumber, "f") === 'undefined') {
            throw new Error('L1 block number has to be attached before calling "getL1BlockNumber"');
        }
        return __classPrivateFieldGet(this, _L2Block_l1BlockNumber, "f");
    }
    /**
     * Sets the L1 block number that included this block
     * @param l1BlockNumber - The block number of the L1 block that contains this L2 block.
     */
    setL1BlockNumber(l1BlockNumber) {
        __classPrivateFieldSet(this, _L2Block_l1BlockNumber, l1BlockNumber, "f");
    }
    /**
     * Returns the block's hash (hash of block header).
     * @returns The block's hash.
     */
    hash() {
        return this.header.hash();
    }
    /**
     * Computes the public inputs hash for the L2 block.
     * The same output as the hash of RootRollupPublicInputs.
     * @returns The public input hash for the L2 block as a field element.
     */
    // TODO(#4844)
    getPublicInputsHash() {
        const buf = serializeToBuffer(this.header.globalVariables, AppendOnlyTreeSnapshot.zero(), // this.startNoteHashTreeSnapshot / commitments,
        AppendOnlyTreeSnapshot.zero(), // this.startNullifierTreeSnapshot,
        AppendOnlyTreeSnapshot.zero(), // this.startPublicDataTreeSnapshot,
        AppendOnlyTreeSnapshot.zero(), // this.startL1ToL2MessageTreeSnapshot,
        this.header.lastArchive, this.header.state.partial.noteHashTree, this.header.state.partial.nullifierTree, this.header.state.partial.publicDataTree, this.header.state.l1ToL2MessageTree, this.archive, this.body.getTxsEffectsHash(), this.getL1ToL2MessagesHash());
        return Fr.fromBufferReduce(sha256(buf));
    }
    /**
     * Computes the start state hash (should equal contract data before block).
     * @returns The start state hash for the L2 block.
     */
    // TODO(#4844)
    getStartStateHash() {
        const inputValue = serializeToBuffer(new Fr(Number(this.header.globalVariables.blockNumber.toBigInt()) - 1), AppendOnlyTreeSnapshot.zero(), // this.startNoteHashTreeSnapshot,
        AppendOnlyTreeSnapshot.zero(), // this.startNullifierTreeSnapshot,
        AppendOnlyTreeSnapshot.zero(), // this.startPublicDataTreeSnapshot,
        AppendOnlyTreeSnapshot.zero(), // this.startL1ToL2MessageTreeSnapshot,
        this.header.lastArchive);
        return sha256(inputValue);
    }
    /**
     * Computes the end state hash (should equal contract data after block).
     * @returns The end state hash for the L2 block.
     */
    // TODO(#4844)
    getEndStateHash() {
        const inputValue = serializeToBuffer(this.header.globalVariables.blockNumber, this.header.state.partial.noteHashTree, this.header.state.partial.nullifierTree, this.header.state.partial.publicDataTree, this.header.state.l1ToL2MessageTree, this.archive);
        return sha256(inputValue);
    }
    /**
     * Compute the hash of all of this blocks l1 to l2 messages,
     * The hash is also calculated within the contract when the block is submitted.
     * @returns The hash of all of the l1 to l2 messages.
     */
    getL1ToL2MessagesHash() {
        // Create a long buffer of all of the l1 to l2 messages
        const l1ToL2Messages = Buffer.concat(this.body.l1ToL2Messages.map(message => message.toBuffer()));
        return sha256(l1ToL2Messages);
    }
    /**
     * Get the ith transaction in an L2 block.
     * @param txIndex - The index of the tx in the block.
     * @returns The tx.
     */
    getTx(txIndex) {
        this.assertIndexInRange(txIndex);
        return this.body.txEffects[txIndex];
    }
    /**
     * A lightweight method to get the tx hash of a tx in the block.
     * @param txIndex - the index of the tx in the block
     * @returns a hash of the tx, which is the first nullifier in the tx
     */
    getTxHash(txIndex) {
        this.assertIndexInRange(txIndex);
        // Gets the first nullifier of the tx specified by txIndex
        const firstNullifier = this.body.txEffects[txIndex].nullifiers[0];
        return new TxHash(firstNullifier.toBuffer());
    }
    /**
     * Get all the transaction in an L2 block.
     * @returns The tx.
     */
    getTxs() {
        return Array(this.body.numberOfTxs)
            .fill(0)
            .map((_, i) => this.getTx(i));
    }
    /**
     * Returns stats used for logging.
     * @returns Stats on tx count, number, and log size and count.
     */
    getStats() {
        const logsStats = {
            encryptedLogLength: this.body.txEffects.reduce((logCount, txEffect) => logCount + txEffect.encryptedLogs.getSerializedLength(), 0),
            encryptedLogCount: this.body.txEffects.reduce((logCount, txEffect) => logCount + txEffect.encryptedLogs.getTotalLogCount(), 0),
            unencryptedLogCount: this.body.txEffects.reduce((logCount, txEffect) => logCount + txEffect.unencryptedLogs.getSerializedLength(), 0),
            unencryptedLogSize: this.body.txEffects.reduce((logCount, txEffect) => logCount + txEffect.unencryptedLogs.getTotalLogCount(), 0),
        };
        return {
            txCount: this.body.numberOfTxs,
            blockNumber: this.number,
            ...logsStats,
        };
    }
    assertIndexInRange(txIndex) {
        if (txIndex < 0 || txIndex >= this.body.numberOfTxs) {
            throw new IndexOutOfRangeError({
                txIndex,
                numberOfTxs: this.body.numberOfTxs,
                blockNumber: this.number,
            });
        }
    }
}
_L2Block_l1BlockNumber = new WeakMap();
/**
 * Custom error class for when a requested tx index is out of range.
 */
export class IndexOutOfRangeError extends Error {
    constructor({ txIndex, numberOfTxs, blockNumber, }) {
        super(`IndexOutOfRangeError: Failed to get tx at index ${txIndex}. Block ${blockNumber} has ${numberOfTxs} txs.`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibDJfYmxvY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbDJfYmxvY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFZLE1BQU0sRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQzlELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLEVBQUUsZUFBZSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDckYsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUM5QyxPQUFPLEVBQUUsWUFBWSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFOUUsT0FBTyxFQUFFLDBCQUEwQixFQUFFLFVBQVUsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRXJGOztHQUVHO0FBQ0gsTUFBTSxPQUFPLE9BQU87SUFHbEI7SUFDRSwyREFBMkQ7SUFDcEQsT0FBK0I7SUFDdEMsdUJBQXVCO0lBQ2hCLE1BQWM7SUFDckIscUJBQXFCO0lBQ2QsSUFBVTtJQUNqQiw4QkFBOEI7SUFDOUIsYUFBc0I7UUFOZixZQUFPLEdBQVAsT0FBTyxDQUF3QjtRQUUvQixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBRWQsU0FBSSxHQUFKLElBQUksQ0FBTTtRQVJuQix5Q0FBd0I7UUFZdEIsdUJBQUEsSUFBSSwwQkFBa0IsYUFBYSxNQUFBLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQ2YsTUFNQyxFQUNELGFBQXNCO1FBRXRCLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDN0UsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMs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