import { sha256 } from '@aztec/foundation/crypto';
import { BufferReader, prefixBufferWithLength } from '@aztec/foundation/serialize';
import isEqual from 'lodash.isequal';
import { FunctionL2Logs } from './function_l2_logs.js';
import { LogType } from './log_type.js';
/**
 * Data container of logs emitted in 1 tx.
 */
export class TxL2Logs {
    constructor(
    /**
     * An array containing logs emitted in individual function invocations in this tx.
     */
    functionLogs) {
        this.functionLogs = functionLogs;
    }
    /**
     * Serializes logs into a buffer.
     * @returns A buffer containing the serialized logs.
     */
    toBuffer() {
        const serializedFunctionLogs = this.functionLogs.map(logs => logs.toBuffer());
        // Concatenate all serialized function logs into a single buffer and prefix it with 4 bytes for its total length.
        return prefixBufferWithLength(Buffer.concat(serializedFunctionLogs));
    }
    /**
     * Get the total length of serialized data.
     * @returns Total length of serialized data.
     */
    getSerializedLength() {
        return this.functionLogs.reduce((acc, logs) => acc + logs.getSerializedLength(), 0) + 4;
    }
    /** Gets the total number of logs. */
    getTotalLogCount() {
        return this.functionLogs.reduce((acc, logs) => acc + logs.logs.length, 0);
    }
    /**
     * Adds function logs to the existing logs.
     * @param functionLogs - The function logs to add
     * @remarks Used by sequencer to append unencrypted logs emitted in public function calls.
     */
    addFunctionLogs(functionLogs) {
        this.functionLogs.push(...functionLogs);
    }
    /**
     * Deserializes logs from a buffer.
     * @param buf - The buffer containing the serialized logs.
     * @param isLengthPrefixed - Whether the buffer is prefixed with 4 bytes for its total length.
     * @returns A new L2Logs object.
     */
    static fromBuffer(buf, isLengthPrefixed = true) {
        const reader = BufferReader.asReader(buf);
        // If the buffer is length prefixed use the length to read the array. Otherwise, the entire buffer is consumed.
        const logsBufLength = isLengthPrefixed ? reader.readNumber() : -1;
        const serializedFunctionLogs = reader.readBufferArray(logsBufLength);
        const functionLogs = serializedFunctionLogs.map(logs => FunctionL2Logs.fromBuffer(logs, false));
        return new TxL2Logs(functionLogs);
    }
    /**
     * Creates a new `TxL2Logs` object with `numCalls` function logs and `numLogsPerCall` logs in each invocation.
     * @param numCalls - The number of function calls in the tx.
     * @param numLogsPerCall - The number of logs emitted in each function call.
     * @param logType - The type of logs to generate.
     * @returns A new `TxL2Logs` object.
     */
    static random(numCalls, numLogsPerCall, logType = LogType.ENCRYPTED) {
        const functionLogs = [];
        for (let i = 0; i < numCalls; i++) {
            functionLogs.push(FunctionL2Logs.random(numLogsPerCall, logType));
        }
        return new TxL2Logs(functionLogs);
    }
    /**
     * Convert a TxL2Logs class object to a plain JSON object.
     * @returns A plain object with TxL2Logs properties.
     */
    toJSON() {
        return {
            functionLogs: this.functionLogs.map(log => log.toJSON()),
        };
    }
    /**
     * Unrolls logs from this tx.
     * @returns Unrolled logs.
     */
    unrollLogs() {
        return this.functionLogs.flatMap(functionLog => functionLog.logs);
    }
    /**
     * Convert a plain JSON object to a TxL2Logs class object.
     * @param obj - A plain TxL2Logs JSON object.
     * @returns A TxL2Logs class object.
     */
    static fromJSON(obj) {
        const functionLogs = obj.functionLogs.map((log) => FunctionL2Logs.fromJSON(log));
        return new TxL2Logs(functionLogs);
    }
    /**
     * Checks if two TxL2Logs objects are equal.
     * @param other - Another TxL2Logs object to compare with.
     * @returns True if the two objects are equal, false otherwise.
     */
    equals(other) {
        return isEqual(this, other);
    }
    /**
     * Computes logs hash as is done in the kernel and app circuits.
     * @param logs - Logs to be hashed.
     * @returns The hash of the logs.
     * Note: This is a TS implementation of `computeKernelLogsHash` function in Decoder.sol. See that function documentation
     *       for more details.
     */
    hash() {
        const logsHashes = [Buffer.alloc(32), Buffer.alloc(32)];
        let kernelPublicInputsLogsHash = Buffer.alloc(32);
        for (const logsFromSingleFunctionCall of this.functionLogs) {
            logsHashes[0] = kernelPublicInputsLogsHash;
            logsHashes[1] = logsFromSingleFunctionCall.hash(); // privateCircuitPublicInputsLogsHash
            // Hash logs hash from the public inputs of previous kernel iteration and logs hash from private circuit public inputs
            kernelPublicInputsLogsHash = sha256(Buffer.concat(logsHashes));
        }
        return kernelPublicInputsLogsHash;
    }
    /** Creates an empty instance. */
    static empty() {
        return new TxL2Logs([]);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHhfbDJfbG9ncy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sb2dzL3R4X2wyX2xvZ3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxZQUFZLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUVuRixPQUFPLE9BQU8sTUFBTSxnQkFBZ0IsQ0FBQztBQUVyQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdkQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV4Qzs7R0FFRztBQUNILE1BQU0sT0FBTyxRQUFRO0lBQ25CO0lBQ0U7O09BRUc7SUFDYSxZQUE4QjtRQUE5QixpQkFBWSxHQUFaLFlBQVksQ0FBa0I7SUFDN0MsQ0FBQztJQUVKOzs7T0FHRztJQUNJLFFBQVE7UUFDYixNQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDOUUsaUhBQWlIO1FBQ2pILE9BQU8sc0JBQXNCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7SUFDdkUsQ0FBQztJQUVEOzs7T0FHRztJQUNJLG1CQUFtQjtRQUN4QixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMxRixDQUFDO0lBRUQscUNBQXFDO0lBQzlCLGdCQUFnQjtRQUNyQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLElB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