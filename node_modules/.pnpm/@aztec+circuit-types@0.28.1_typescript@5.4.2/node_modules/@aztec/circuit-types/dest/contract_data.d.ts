/// <reference types="node" resolution-mode="require"/>
import { Fr, FunctionSelector } from '@aztec/circuits.js';
import { AztecAddress } from '@aztec/foundation/aztec-address';
import { EthAddress } from '@aztec/foundation/eth-address';
import { BufferReader } from '@aztec/foundation/serialize';
import { ContractClass, ContractClassPublic, ContractInstanceWithAddress } from '@aztec/types/contracts';
/**
 * Used for retrieval of contract data (A3 address, portal contract address, bytecode).
 */
export interface ContractDataSource {
    /**
     * Get the extended contract data for this contract.
     * @param contractAddress - The contract data address.
     * @returns The extended contract data or undefined if not found.
     */
    getExtendedContractData(contractAddress: AztecAddress): Promise<ExtendedContractData | undefined>;
    /**
     * Lookup the L2 contract base info for this contract.
     * NOTE: This works for all Aztec contracts and will only return contractAddress / portalAddress.
     * @param contractAddress - The contract data address.
     * @returns The aztec & ethereum portal address (if found).
     */
    getContractData(contractAddress: AztecAddress): Promise<ContractData | undefined>;
    /**
     * Returns a contract's encoded public function, given its function selector.
     * @param address - The contract aztec address.
     * @param selector - The function's selector.
     * @returns The function's data.
     */
    getPublicFunction(address: AztecAddress, selector: FunctionSelector): Promise<EncodedContractFunction | undefined>;
    /**
     * Gets the number of the latest L2 block processed by the implementation.
     * @returns The number of the latest L2 block processed by the implementation.
     */
    getBlockNumber(): Promise<number>;
    /**
     * Returns the contract class for a given contract class id, or undefined if not found.
     * @param id - Contract class id.
     */
    getContractClass(id: Fr): Promise<ContractClassPublic | undefined>;
    /**
     * Returns a publicly deployed contract instance given its address.
     * @param address - Address of the deployed contract.
     */
    getContract(address: AztecAddress): Promise<ContractInstanceWithAddress | undefined>;
    /** Returns the list of all class ids known. */
    getContractClassIds(): Promise<Fr[]>;
}
/**
 * Represents encoded contract function.
 */
export declare class EncodedContractFunction {
    /**
     * The function selector.
     */
    selector: FunctionSelector;
    /**
     * Whether the function is internal.
     */
    isInternal: boolean;
    /**
     * The function bytecode.
     */
    bytecode: Buffer;
    constructor(
    /**
     * The function selector.
     */
    selector: FunctionSelector, 
    /**
     * Whether the function is internal.
     */
    isInternal: boolean, 
    /**
     * The function bytecode.
     */
    bytecode: Buffer);
    /**
     * Serializes this instance into a buffer.
     * @returns Encoded buffer.
     */
    toBuffer(): Buffer;
    /**
     * Deserializes a contract function object from an encoded buffer.
     * @param buffer - The encoded buffer.
     * @returns The deserialized contract function.
     */
    static fromBuffer(buffer: Buffer | BufferReader): EncodedContractFunction;
    /**
     * Serializes this instance into a string.
     * @returns Encoded string.
     */
    toString(): string;
    /**
     * Deserializes a contract function object from an encoded string.
     * @param data - The encoded string.
     * @returns The deserialized contract function.
     */
    static fromString(data: string): EncodedContractFunction;
    /**
     * Creates a random contract function.
     * @returns A random contract function.
     */
    static random(): EncodedContractFunction;
}
/**
 * A contract data blob, containing L1 and L2 addresses, public functions' bytecode, partial address and public key.
 * TODO(palla/purge-old-contract-deploy): Delete this class?
 */
export declare class ExtendedContractData {
    /** The base contract data: aztec & portal addresses. */
    contractData: ContractData;
    /** Artifacts of public functions. */
    readonly publicFunctions: EncodedContractFunction[];
    /** Contract class id */
    readonly contractClassId: Fr;
    /** Salted init hash. */
    readonly saltedInitializationHash: Fr;
    /** Public key hash of the contract. */
    readonly publicKeyHash: Fr;
    /** The contract's encoded ACIR code. This should become Brillig code once implemented. */
    bytecode: Buffer;
    constructor(
    /** The base contract data: aztec & portal addresses. */
    contractData: ContractData, 
    /** Artifacts of public functions. */
    publicFunctions: EncodedContractFunction[], 
    /** Contract class id */
    contractClassId: Fr, 
    /** Salted init hash. */
    saltedInitializationHash: Fr, 
    /** Public key hash of the contract. */
    publicKeyHash: Fr);
    /**
     * Gets the public function data or undefined.
     * @param selector - The function selector of the function to fetch.
     * @returns The public function data (if found).
     */
    getPublicFunction(selector: FunctionSelector): EncodedContractFunction | undefined;
    /**
     * Serializes this instance into a buffer, using 20 bytes for the eth address.
     * @returns Encoded buffer.
     */
    toBuffer(): Buffer;
    /**
     * Serializes this instance into a string.
     * @returns Encoded string.
     */
    toString(): string;
    /** True if this represents an empty instance. */
    isEmpty(): boolean;
    /** True if the passed instance is empty . */
    static isEmpty(obj: ExtendedContractData): boolean;
    /**
     * Deserializes a contract data object from an encoded buffer, using 20 bytes for the eth address.
     * @param buffer - Byte array resulting from calling toBuffer.
     * @returns Deserialized instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): ExtendedContractData;
    /**
     * Deserializes a contract data object from an encoded string, using 20 bytes for the eth address.
     * @param str - String resulting from calling toString.
     * @returns Deserialized instance.
     */
    static fromString(str: string): ExtendedContractData;
    /**
     * Generate ContractData with random addresses.
     * @param contractData - Optional contract data to use.
     * @returns A random ExtendedContractData object.
     */
    static random(contractData?: ContractData): ExtendedContractData;
    /** Generates empty extended contract data. */
    static empty(): ExtendedContractData;
    /** Temporary method for creating extended contract data out of classes and instances */
    static fromClassAndInstance(contractClass: Pick<ContractClass, 'publicFunctions'>, instance: ContractInstanceWithAddress): ExtendedContractData;
}
/**
 * A contract data blob, containing L1 and L2 addresses.
 * TODO(palla/purge-old-contract-deploy): Delete me
 */
export declare class ContractData {
    /**
     * The L2 address of the contract, as a field element (32 bytes).
     */
    contractAddress: AztecAddress;
    /**
     * The L1 address of the contract, (20 bytes).
     */
    portalContractAddress: EthAddress;
    constructor(
    /**
     * The L2 address of the contract, as a field element (32 bytes).
     */
    contractAddress: AztecAddress, 
    /**
     * The L1 address of the contract, (20 bytes).
     */
    portalContractAddress: EthAddress);
    /**
     * Serializes this instance into a buffer, using 20 bytes for the eth address.
     * @returns Encoded buffer.
     */
    toBuffer(): Buffer;
    /**
     * Serializes this instance into a string, using 20 bytes for the eth address.
     * @returns Encoded string.
     */
    toString(): string;
    /** True if all data is zero. */
    isEmpty(): boolean;
    /**
     * Deserializes a contract data object from an encoded buffer, using 20 bytes for the eth address.
     * @param buffer - Byte array resulting from calling toBuffer.
     * @returns Deserialized instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): ContractData;
    /**
     * Deserializes a contract data object from an encoded string, using 20 bytes for the eth address.
     * @param str - String resulting from calling toString.
     * @returns Deserialized instance.
     */
    static fromString(str: string): ContractData;
    /**
     * Generate ContractData with random addresses.
     * @returns ContractData.
     */
    static random(): ContractData;
    /** Generates an empty ContractData. */
    static empty(): ContractData;
}
//# sourceMappingURL=contract_data.d.ts.map