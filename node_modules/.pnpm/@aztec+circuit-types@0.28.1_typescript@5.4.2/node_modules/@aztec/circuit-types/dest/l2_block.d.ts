/// <reference types="node" resolution-mode="require"/>
import { Body, TxEffect, TxHash } from '@aztec/circuit-types';
import { AppendOnlyTreeSnapshot, Header } from '@aztec/circuits.js';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
/**
 * The data that makes up the rollup proof, with encoder decoder functions.
 */
export declare class L2Block {
    #private;
    /** Snapshot of archive tree after the block is applied. */
    archive: AppendOnlyTreeSnapshot;
    /** L2 block header. */
    header: Header;
    /** L2 block body. */
    body: Body;
    constructor(
    /** Snapshot of archive tree after the block is applied. */
    archive: AppendOnlyTreeSnapshot, 
    /** L2 block header. */
    header: Header, 
    /** L2 block body. */
    body: Body, 
    /** Associated L1 block num */
    l1BlockNumber?: bigint);
    /**
     * Constructs a new instance from named fields.
     * @param fields - Fields to pass to the constructor.
     * @param blockHash - Hash of the block.
     * @param l1BlockNumber - The block number of the L1 block that contains this L2 block.
     * @returns A new instance.
     */
    static fromFields(fields: {
        /** Snapshot of archive tree after the block is applied. */
        archive: AppendOnlyTreeSnapshot;
        /** L2 block header. */
        header: Header;
        body: Body;
    }, l1BlockNumber?: bigint): L2Block;
    /**
     * Deserializes a block from a buffer
     * @returns A deserialized L2 block.
     */
    static fromBuffer(buf: Buffer | BufferReader): L2Block;
    /**
     * Serializes a block
     * @returns A serialized L2 block as a Buffer.
     */
    toBuffer(): Buffer;
    /**
     * Deserializes L2 block from a buffer.
     * @param str - A serialized L2 block.
     * @returns Deserialized L2 block.
     */
    static fromString(str: string): L2Block;
    /**
     * Serializes a block to a string.
     * @returns A serialized L2 block as a string.
     */
    toString(): string;
    /**
     * Creates an L2 block containing random data.
     * @param l2BlockNum - The number of the L2 block.
     * @param txsPerBlock - The number of transactions to include in the block.
     * @param numPrivateCallsPerTx - The number of private function calls to include in each transaction.
     * @param numPublicCallsPerTx - The number of public function calls to include in each transaction.
     * @param numEncryptedLogsPerCall - The number of encrypted logs per 1 private function invocation.
     * @param numUnencryptedLogsPerCall - The number of unencrypted logs per 1 public function invocation.
     * @returns The L2 block.
     */
    static random(l2BlockNum: number, txsPerBlock?: number, numPrivateCallsPerTx?: number, numPublicCallsPerTx?: number, numEncryptedLogsPerCall?: number, numUnencryptedLogsPerCall?: number, numL1ToL2MessagesPerCall?: number): L2Block;
    get number(): number;
    /**
     * Gets the L1 block number that included this block
     */
    getL1BlockNumber(): bigint;
    /**
     * Sets the L1 block number that included this block
     * @param l1BlockNumber - The block number of the L1 block that contains this L2 block.
     */
    setL1BlockNumber(l1BlockNumber: bigint): void;
    /**
     * Returns the block's hash (hash of block header).
     * @returns The block's hash.
     */
    hash(): Fr;
    /**
     * Computes the public inputs hash for the L2 block.
     * The same output as the hash of RootRollupPublicInputs.
     * @returns The public input hash for the L2 block as a field element.
     */
    getPublicInputsHash(): Fr;
    /**
     * Computes the start state hash (should equal contract data before block).
     * @returns The start state hash for the L2 block.
     */
    getStartStateHash(): Buffer;
    /**
     * Computes the end state hash (should equal contract data after block).
     * @returns The end state hash for the L2 block.
     */
    getEndStateHash(): Buffer;
    /**
     * Compute the hash of all of this blocks l1 to l2 messages,
     * The hash is also calculated within the contract when the block is submitted.
     * @returns The hash of all of the l1 to l2 messages.
     */
    getL1ToL2MessagesHash(): Buffer;
    /**
     * Get the ith transaction in an L2 block.
     * @param txIndex - The index of the tx in the block.
     * @returns The tx.
     */
    getTx(txIndex: number): TxEffect;
    /**
     * A lightweight method to get the tx hash of a tx in the block.
     * @param txIndex - the index of the tx in the block
     * @returns a hash of the tx, which is the first nullifier in the tx
     */
    getTxHash(txIndex: number): TxHash;
    /**
     * Get all the transaction in an L2 block.
     * @returns The tx.
     */
    getTxs(): TxEffect[];
    /**
     * Returns stats used for logging.
     * @returns Stats on tx count, number, and log size and count.
     */
    getStats(): {
        encryptedLogLength: number;
        encryptedLogCount: number;
        unencryptedLogCount: number;
        unencryptedLogSize: number;
        txCount: number;
        blockNumber: number;
    };
    assertIndexInRange(txIndex: number): void;
}
/**
 * Custom error class for when a requested tx index is out of range.
 */
export declare class IndexOutOfRangeError extends Error {
    constructor({ txIndex, numberOfTxs, blockNumber, }: {
        /**
         * The requested index of the tx in the block.
         */
        txIndex: number;
        /**
         * The number of txs in the block.
         */
        numberOfTxs: number;
        /**
         * The number of the block.
         */
        blockNumber: number;
    });
}
//# sourceMappingURL=l2_block.d.ts.map