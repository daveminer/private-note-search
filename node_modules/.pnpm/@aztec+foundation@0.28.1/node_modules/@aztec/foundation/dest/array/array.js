/**
 * Create an array over an integer range.
 * @param n - The number of integers.
 * @param offset - The starting number.
 * @returns The array of numbers.
 */
export function range(n, offset = 0) {
    const ret = [];
    for (let i = 0; i < n; i++) {
        ret.push(offset + i);
    }
    return ret;
}
/**
 * Create an array over an integer range, filled with a function 'fn'.
 * This is used over e.g. lodash because it resolved to a tuple type, needed for our fixed array type safety.
 * @param n - The number of integers.
 * @param fn - The generator function.
 * @returns The array of numbers.
 */
export function makeTuple(length, fn, offset = 0) {
    return Array.from({ length }, (v, i) => fn(i + offset));
}
/**
 * Create an array over an integer range, filled with a function 'fn'. However, the latter half of the array are set to zeros.
 * see `makeTuple` above.
 * @param n - The number of integers.
 * @param fn - The generator function.
 * @returns The array of numbers.
 */
export function makeHalfFullTuple(length, fn, offset = 0) {
    return Array.from({ length }, (v, i) => (i < length / 2 ? fn(i + offset) : fn(0)));
}
/**
 * Assert a member of an object is a certain length.
 * @param obj - An object.
 * @param member - A member string.
 * @param length - The length.
 */
export function assertMemberLength(obj, member, length) {
    if (obj[member].length !== length) {
        throw new Error(`Expected ${member} to have length ${length} but was ${obj[member].length}`);
    }
}
/**
 * Assert all subarrays in a member of an object are a certain length.
 * @param obj - An object.
 * @param member - A member string.
 * @param length - The expected length for each subarray.
 */
export function assertItemsLength(obj, member, length) {
    const arrays = obj[member];
    for (let i = 0; i < arrays.length; i++) {
        if (arrays[i].length !== length) {
            throw new Error(`Expected ${member}[${i}] to have length ${length} but was ${arrays[i].length}`);
        }
    }
}
/**
 * Checks that the permutation is valid. Throws an error if it is not.
 * @param original - The original array.
 * @param permutation - The array which is allegedly a permutation of the original.
 * @param indexes - The indices of the original array which the permutation should map to.
 * @param isEqual - A function to compare the elements of the original and permutation arrays.
 */
export function assertPermutation(original, permutation, indexes, isEqual) {
    if (original.length !== permutation.length || original.length !== indexes.length) {
        throw new Error(`Invalid lengths: ${original.length}, ${permutation.length}, ${indexes.length}`);
    }
    const seenValue = new Set();
    for (let i = 0; i < indexes.length; i++) {
        const index = indexes[i];
        const permutedValue = permutation[i];
        const originalValueAtIndex = original[index];
        if (!isEqual(permutedValue, originalValueAtIndex)) {
            throw new Error(`Invalid permutation at index ${index}: ${permutedValue} !== ${originalValueAtIndex}`);
        }
        if (seenValue.has(index)) {
            throw new Error(`Duplicate index in permutation: ${index}`);
        }
        seenValue.add(index);
    }
}
export function assertRightPadded(arr, isEmpty) {
    let seenEmpty = false;
    for (let i = 0; i < arr.length; i++) {
        if (isEmpty(arr[i])) {
            seenEmpty = true;
        }
        else if (seenEmpty) {
            throw new Error(`Non-empty element at index [${i}] after empty element`);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXJyYXkvYXJyYXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBSUE7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUFDLENBQVMsRUFBRSxNQUFNLEdBQUcsQ0FBQztJQUN6QyxNQUFNLEdBQUcsR0FBYSxFQUFFLENBQUM7SUFDekIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzNCLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUFzQixNQUFTLEVBQUUsRUFBb0IsRUFBRSxNQUFNLEdBQUcsQ0FBQztJQUN4RixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQU0sRUFBRSxDQUFTLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQWdCLENBQUM7QUFDdEYsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxpQkFBaUIsQ0FBc0IsTUFBUyxFQUFFLEVBQW9CLEVBQUUsTUFBTSxHQUFHLENBQUM7SUFDaEcsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFNLEVBQUUsQ0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBZ0IsQ0FBQztBQUNqSCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsa0JBQWtCLENBVWhDLEdBQU0sRUFBRSxNQUFTLEVBQUUsTUFBYztJQUNqQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLEtBQUssTUFBTSxFQUFFLENBQUM7UUFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxZQUFZLE1BQU0sbUJBQW1CLE1BQU0sWUFBWSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUMvRixDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLGlCQUFpQixDQVUvQixHQUFNLEVBQUUsTUFBUyxFQUFFLE1BQWM7SUFDakMsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzNCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDdkMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLE1BQU0sRUFBRSxDQUFDO1lBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsWUFBWSxNQUFNLElBQUksQ0FBQyxvQkFBb0IsTUFBTSxZQUFZLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQ25HLENBQUM7SUFDSCxDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxpQkFBaUIsQ0FDL0IsUUFBYSxFQUNiLFdBQWdCLEVBQ2hCLE9BQWlCLEVBQ2pCLE9BQWdDO0lBRWhDLElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxXQUFXLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2pGLE1BQU0sSUFBSSxLQUFLLENBQUMsb0JBQW9CLFFBQVEsQ0FBQyxNQUFNLEtBQUssV0FBVyxDQUFDLE1BQU0sS0FBSyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUNuRyxDQUFDO0lBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztJQUNwQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ3hDLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6QixNQUFNLGFBQWEsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsTUFBTSxvQkFBb0IsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFN0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsb0JBQW9CLENBQUMsRUFBRSxDQUFDO1lBQ2xELE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLEtBQUssS0FBSyxhQUFhLFFBQVEsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO1FBQ3pHLENBQUM7UUFDRCxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQzlELENBQUM7UUFDRCxTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLGlCQUFpQixDQUFJLEdBQVEsRUFBRSxPQUE2QjtJQUMxRSxJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDdEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUNwQyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ3BCLFNBQVMsR0FBRyxJQUFJLENBQUM7UUFDbkIsQ0FBQzthQUFNLElBQUksU0FBUyxFQUFFLENBQUM7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQzNFLENBQUM7SUFDSCxDQUFDO0FBQ0gsQ0FBQyJ9