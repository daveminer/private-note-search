import { Fr } from '../fields/index.js';
import { isAddressStruct, isFunctionSelectorStruct, isWrappedFieldStruct } from './utils.js';
/**
 * Encodes arguments for a function call.
 * Missing support for integer and string.
 */
class ArgumentEncoder {
    constructor(abi, args) {
        this.abi = abi;
        this.args = args;
        this.flattened = [];
    }
    static typeSize(abiType) {
        switch (abiType.kind) {
            case 'field':
            case 'boolean':
            case 'integer':
                return 1;
            case 'string':
                return abiType.length;
            case 'array':
                return abiType.length * ArgumentEncoder.typeSize(abiType.type);
            case 'struct':
                return abiType.fields.reduce((acc, field) => acc + ArgumentEncoder.typeSize(field.type), 0);
            default: {
                const exhaustiveCheck = abiType;
                throw new Error(`Unhandled abi type: ${exhaustiveCheck}`);
            }
        }
    }
    /**
     * Encodes a single argument from the given type to field.
     * @param abiType - The abi type of the argument.
     * @param arg - The value to encode.
     * @param name - Name.
     */
    encodeArgument(abiType, arg, name) {
        if (arg === undefined || arg == null) {
            throw new Error(`Undefined argument ${name ?? 'unnamed'} of type ${abiType.kind}`);
        }
        switch (abiType.kind) {
            case 'field':
                if (typeof arg === 'number') {
                    this.flattened.push(new Fr(BigInt(arg)));
                }
                else if (typeof arg === 'bigint') {
                    this.flattened.push(new Fr(arg));
                }
                else if (typeof arg === 'boolean') {
                    this.flattened.push(new Fr(arg ? 1n : 0n));
                }
                else if (typeof arg === 'object') {
                    if (Buffer.isBuffer(arg)) {
                        this.flattened.push(Fr.fromBuffer(arg));
                    }
                    else if (typeof arg.toField === 'function') {
                        this.flattened.push(arg.toField());
                    }
                    else {
                        throw new Error(`Argument for ${name} cannot be serialized to a field`);
                    }
                }
                else {
                    throw new Error(`Invalid argument "${arg}" of type ${abiType.kind}`);
                }
                break;
            case 'boolean':
                this.flattened.push(new Fr(arg ? 1n : 0n));
                break;
            case 'array':
                for (let i = 0; i < abiType.length; i += 1) {
                    this.encodeArgument(abiType.type, arg[i], `${name}[${i}]`);
                }
                break;
            case 'string':
                for (let i = 0; i < abiType.length; i += 1) {
                    // If the string is shorter than the defined length, pad it with 0s.
                    const toInsert = i < arg.length ? BigInt(arg.charCodeAt(i)) : 0n;
                    this.flattened.push(new Fr(toInsert));
                }
                break;
            case 'struct': {
                // If the abi expects a struct like { address: Field } and the supplied arg does not have
                // an address field in it, we try to encode it as if it were a field directly.
                const isAddress = isAddressStruct(abiType);
                if (isAddress && typeof arg.address === 'undefined' && typeof arg.inner === 'undefined') {
                    this.encodeArgument({ kind: 'field' }, arg, `${name}.inner`);
                    break;
                }
                // Or if the supplied argument does have an address field in it, like a CompleteAddress,
                // we encode it directly as a field.
                if (isAddress && typeof arg.address !== 'undefined') {
                    this.encodeArgument({ kind: 'field' }, arg.address, `${name}.address`);
                    break;
                }
                if (isFunctionSelectorStruct(abiType)) {
                    this.encodeArgument({ kind: 'integer', sign: 'unsigned', width: 32 }, arg.value ?? arg, `${name}.inner`);
                    break;
                }
                if (isWrappedFieldStruct(abiType)) {
                    this.encodeArgument({ kind: 'field' }, arg.inner ?? arg, `${name}.inner`);
                    break;
                }
                for (const field of abiType.fields) {
                    this.encodeArgument(field.type, arg[field.name], `${name}.${field.name}`);
                }
                break;
            }
            case 'integer':
                this.flattened.push(new Fr(arg));
                break;
            default:
                throw new Error(`Unsupported type: ${abiType}`);
        }
    }
    /**
     * Encodes all the arguments for the given function ABI.
     * @returns The encoded arguments.
     */
    encode() {
        for (let i = 0; i < this.abi.parameters.length; i += 1) {
            const parameterAbi = this.abi.parameters[i];
            this.encodeArgument(parameterAbi.type, this.args[i], parameterAbi.name);
        }
        return this.flattened;
    }
}
/**
 * Encodes all the arguments for a function call.
 * @param abi - The function ABI entry.
 * @param args - The arguments to encode.
 * @returns The encoded arguments.
 */
export function encodeArguments(abi, args) {
    return new ArgumentEncoder(abi, args).encode();
}
/**
 * Returns the size of the arguments for a function ABI.
 * @param abi - The function ABI entry.
 * @returns The size of the arguments.
 */
export function countArgumentsSize(abi) {
    return abi.parameters.reduce((acc, parameter) => acc + ArgumentEncoder.typeSize(parameter.type), 0);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jb2Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hYmkvZW5jb2Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFeEMsT0FBTyxFQUFFLGVBQWUsRUFBRSx3QkFBd0IsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUU3Rjs7O0dBR0c7QUFDSCxNQUFNLGVBQWU7SUFHbkIsWUFBb0IsR0FBZ0IsRUFBVSxJQUFXO1FBQXJDLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFBVSxTQUFJLEdBQUosSUFBSSxDQUFPO1FBRmpELGNBQVMsR0FBUyxFQUFFLENBQUM7SUFFK0IsQ0FBQztJQUU3RCxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQWdCO1FBQzlCLFFBQVEsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3JCLEtBQUssT0FBTyxDQUFDO1lBQ2IsS0FBSyxTQUFTLENBQUM7WUFDZixLQUFLLFNBQVM7Z0JBQ1osT0FBTyxDQUFDLENBQUM7WUFDWCxLQUFLLFFBQVE7Z0JBQ1gsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDO1lBQ3hCLEtBQUssT0FBTztnQkFDVixPQUFPLE9BQU8sQ0FBQyxNQUFNLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDakUsS0FBSyxRQUFRO2dCQUNYLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDOUYsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDUixNQUFNLGVBQWUsR0FBVSxPQUFPLENBQUM7Z0JBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLGVB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