import { BufferReader, FieldReader } from '../serialize/index.js';
import { Fr } from './fields.js';
/**
 * Represents a Point on an elliptic curve with x and y coordinates.
 * The Point class provides methods for creating instances from different input types,
 * converting instances to various output formats, and checking the equality of points.
 */
export class Point {
    constructor(
    /**
     * The point's x coordinate
     */
    x, 
    /**
     * The point's y coordinate
     */
    y) {
        this.x = x;
        this.y = y;
        /** Used to differentiate this class from AztecAddress */
        this.kind = 'point';
    }
    /**
     * Generate a random Point instance.
     *
     * @returns A randomly generated Point instance.
     */
    static random() {
        // TODO is this a random point on the curve?
        return new Point(Fr.random(), Fr.random());
    }
    /**
     * Create a Point instance from a given buffer or BufferReader.
     * The input 'buffer' should have exactly 64 bytes representing the x and y coordinates.
     *
     * @param buffer - The buffer or BufferReader containing the x and y coordinates of the point.
     * @returns A Point instance.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new this(Fr.fromBuffer(reader.readBytes(32)), Fr.fromBuffer(reader.readBytes(32)));
    }
    /**
     * Create a Point instance from a hex-encoded string.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 128 hex characters representing the x and y coordinates.
     * Throws an error if the input length is invalid or coordinate values are out of range.
     *
     * @param address - The hex-encoded string representing the Point coordinates.
     * @returns A Point instance.
     */
    static fromString(address) {
        return this.fromBuffer(Buffer.from(address.replace(/^0x/i, ''), 'hex'));
    }
    /**
     * Returns the contents of the point as an array of 2 fields.
     * @returns The point as an array of 2 fields
     */
    toFields() {
        return [this.x, this.y];
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new this(reader.readField(), reader.readField());
    }
    /**
     * Returns the contents of the point as BigInts.
     * @returns The point as BigInts
     */
    toBigInts() {
        return {
            x: this.x.toBigInt(),
            y: this.y.toBigInt(),
        };
    }
    /**
     * Converts the Point instance to a Buffer representation of the coordinates.
     * The outputs buffer length will be 64, the length of both coordinates not represented as fields.
     * @returns A Buffer representation of the Point instance.
     */
    toBuffer() {
        return Buffer.concat([this.x.toBuffer(), this.y.toBuffer()]);
    }
    /**
     * Convert the Point instance to a hexadecimal string representation.
     * The output string is prefixed with '0x' and consists of exactly 128 hex characters,
     * representing the concatenated x and y coordinates of the point.
     *
     * @returns A hex-encoded string representing the Point instance.
     */
    toString() {
        return '0x' + this.toBuffer().toString('hex');
    }
    /**
     * Generate a short string representation of the Point instance.
     * The returned string includes the first 10 and last 4 characters of the full string representation,
     * with '...' in between to indicate truncation. This is useful for displaying or logging purposes
     * when the full string representation may be too long.
     *
     * @returns A truncated string representation of the Point instance.
     */
    toShortString() {
        const str = this.toString();
        return `${str.slice(0, 10)}...${str.slice(-4)}`;
    }
    /**
     * Check if two Point instances are equal by comparing their buffer values.
     * Returns true if the buffer values are the same, and false otherwise.
     *
     * @param rhs - The Point instance to compare with the current instance.
     * @returns A boolean indicating whether the two Point instances are equal.
     */
    equals(rhs) {
        return this.x.equals(rhs.x) && this.y.equals(rhs.y);
    }
    isZero() {
        return this.x.isZero() && this.y.isZero();
    }
}
Point.ZERO = new Point(Fr.ZERO, Fr.ZERO);
Point.SIZE_IN_BYTES = Fr.SIZE_IN_BYTES * 2;
/**
 * Does this object look like a point?
 * @param obj - Object to test if it is a point.
 * @returns Whether it looks like a point.
 */
export function isPoint(obj) {
    if (!obj) {
        return false;
    }
    const point = obj;
    return point.kind === 'point' && point.x !== undefined && point.y !== undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9pbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZmllbGRzL3BvaW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDbEUsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUVqQzs7OztHQUlHO0FBQ0gsTUFBTSxPQUFPLEtBQUs7SUFPaEI7SUFDRTs7T0FFRztJQUNhLENBQUs7SUFDckI7O09BRUc7SUFDYSxDQUFLO1FBSkwsTUFBQyxHQUFELENBQUMsQ0FBSTtRQUlMLE1BQUMsR0FBRCxDQUFDLENBQUk7UUFYdkIseURBQXlEO1FBQ3pDLFNBQUksR0FBRyxPQUFPLENBQUM7SUFXNUIsQ0FBQztJQUVKOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsTUFBTTtRQUNYLDRDQUE0QztRQUM1QyxPQUFPLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUE2QjtRQUM3QyxNQUFNLE1BQU0sR0FBRyxZQUFZLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzdDLE9BQU8sSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBZTtRQUMvQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxD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