import { Fr, FunctionLeafPreimage } from '@aztec/circuits.js';
import { FunctionSelector, FunctionType } from '@aztec/foundation/abi';
import { hashVK } from '../../hash/hash.js';
/**
 * Computes the hash of a hex-encoded string representation of a verification key (vk).
 * The input 'vk' should be a hexadecimal string, and the resulting hash is computed using 'hashVK' function.
 * Returns a Promise that resolves to a Buffer containing the hash of the verification key.
 *
 * @param vk - The hex-encoded string representing the verification key.
 * @returns A Promise resolving to a Buffer containing the hash of the verification key.
 */
export function hashVKStr(vk) {
    // TODO - check consistent encoding
    return hashVK(Buffer.from(vk, 'hex'));
}
/**
 * Determine if the given function is a constructor.
 * This utility function checks if the 'name' property of the input object is "constructor".
 * Returns true if the function is a constructor, false otherwise.
 * TODO(palla/purge-old-contract-deploy): Remove me
 * @param Object - An object containing a 'name' property.
 * @returns Boolean indicating if the function is a constructor.
 */
export function isConstructor({ name, }) {
    return name === 'constructor';
}
/**
 * @param Object - An object containing function name and type.
 * @returns Boolean indicating if the function is constrained and therefore in the function tree.
 */
export function isConstrained({ name, functionType, }) {
    return functionType !== FunctionType.UNCONSTRAINED && !isConstructor({ name });
}
/**
 * Generate function leaves for the constrained functions in a contract.
 * Only computes leaves for functions that are either secret or open and not constructors.
 * Each function leaf is computed from its selector, privacy flag, hashed verification key, and hashed bytecode.
 *
 * @param functions - Array of ContractFunctionDao objects representing the functions in a contract.
 * @returns An array of Fr instances representing the generated function leaves.
 */
export function generateFunctionLeaves(functions) {
    const targetFunctions = functions.filter(isConstrained);
    const result = [];
    for (let i = 0; i < targetFunctions.length; i++) {
        const f = targetFunctions[i];
        const selector = FunctionSelector.fromNameAndParameters(f.name, f.parameters);
        const isInternal = f.isInternal;
        const isPrivate = f.functionType === FunctionType.SECRET;
        // All non-unconstrained functions have vks
        // TODO we'd need to have a defined length of the VK for this to be computed in noir
        // const vkHash = hashVKStr(f.verificationKey!, wasm);
        const vkHash = Buffer.alloc(32, 0);
        // TODO
        // FIXME: https://github.com/AztecProtocol/aztec3-packages/issues/262
        // const acirHash = keccak(Buffer.from(f.bytecode, 'hex'));
        const acirHash = Buffer.alloc(32, 0);
        const fnLeafPreimage = new FunctionLeafPreimage(selector, isInternal, isPrivate, Fr.fromBuffer(vkHash), Fr.fromBuffer(acirHash));
        const fnLeaf = fnLeafPreimage.hash();
        result.push(fnLeaf);
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJhY3RfdHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb250cmFjdC9jb250cmFjdF90cmVlL2NvbnRyYWN0X3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUF1QixFQUFFLEVBQWdCLG9CQUFvQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDakcsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFlBQVksRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXZFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUU1Qzs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FBQyxFQUFVO0lBQ2xDLG1DQUFtQztJQUNuQyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ3hDLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FBQyxFQUM1QixJQUFJLEdBTUw7SUFDQyxPQUFPLElBQUksS0FBSyxhQUFhLENBQUM7QUFDaEMsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQUMsRUFDNUIsSUFBSSxFQUNKLFlBQVksR0FVYjtJQUNDLE9BQU8sWUFBWSxLQUFLLFlBQVksQ0FBQyxhQUFhLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQ2pGLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLHNCQUFzQixDQUFDLFNBQWdDO0lBQ3JFLE1BQU0sZUFBZSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDeEQsTUFBTSxNQUFNLEdBQVMsRUFBRSxDQUFDO0lBQ3hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDaEQsTUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdCLE1BQU0sUUFBUSxHQUFHLGdCQUFnQixDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzlFLE1BQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUM7UUFDaEMsTUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDLFlBQVksS0FBSyxZQUFZLENBQUMsTUFBTSxDQUFDO1FBQ3pELDJDQUEyQztRQUMzQyxvRkFBb0Y7UUFDcEYsc0RBQXNEO1FBQ3RELE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ25DLE9BQU87UUFDUCxxRUFBcUU7UUFDckUsMkRBQTJEO1FBQzNELE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRXJDLE1BQU0sY0FBYyxHQUFHLElBQUksb0JBQW9CLENBQzdDLFFBQVEsRUFDUixVQUFVLEVBQ1YsU0FBUyxFQUNULEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQ3JCLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQ3hCLENBQUM7UUFDRixNQUFNLE1BQU0sR0FBRyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDckMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQyJ9