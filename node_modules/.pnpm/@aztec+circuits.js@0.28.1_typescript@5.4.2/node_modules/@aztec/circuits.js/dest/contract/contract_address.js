import { FunctionSelector, encodeArguments } from '@aztec/foundation/abi';
import { AztecAddress } from '@aztec/foundation/aztec-address';
import { pedersenHash } from '@aztec/foundation/crypto';
import { Fr } from '@aztec/foundation/fields';
import { GeneratorIndex } from '../constants.gen.js';
import { computeVarArgsHash } from '../hash/hash.js';
// TODO(@spalladino): Review all generator indices in this file
/**
 * Returns the deployment address for a given contract instance as defined on the [Yellow Paper](../../../../yellow-paper/docs/addresses-and-keys/specification.md).
 * ```
 * salted_initialization_hash = pedersen([salt, initialization_hash, portal_contract_address as Field], GENERATOR__SALTED_INITIALIZATION_HASH)
 * partial_address = pedersen([contract_class_id, salted_initialization_hash], GENERATOR__CONTRACT_PARTIAL_ADDRESS_V1)
 * address = pedersen([public_keys_hash, partial_address], GENERATOR__CONTRACT_ADDRESS_V1)
 * ```
 * @param instance - A contract instance for which to calculate the deployment address.
 */
export function computeContractAddressFromInstance(instance) {
    const partialAddress = computePartialAddress(instance);
    const publicKeyHash = instance.publicKeysHash;
    return computeContractAddressFromPartial({ partialAddress, publicKeyHash });
}
/**
 * Computes the partial address defined as the hash of the contract class id and salted initialization hash.
 * @param instance - Contract instance for which to calculate the partial address.
 */
export function computePartialAddress(instance) {
    const saltedInitializationHash = 'saltedInitializationHash' in instance
        ? instance.saltedInitializationHash
        : computeSaltedInitializationHash(instance);
    return pedersenHash([instance.contractClassId, saltedInitializationHash].map(x => x.toBuffer()), GeneratorIndex.PARTIAL_ADDRESS);
}
/**
 * Computes the salted initialization hash for an address, defined as the hash of the salt, initialization hash, and portal address.
 * @param instance - Contract instance for which to compute the salted initialization hash.
 */
export function computeSaltedInitializationHash(instance) {
    return pedersenHash([instance.salt, instance.initializationHash, instance.portalContractAddress].map(x => x.toBuffer()), GeneratorIndex.PARTIAL_ADDRESS);
}
/**
 * Computes a contract address from its partial address and the pubkeys hash.
 * @param args - The hash of the public keys or the plain public key to be hashed, along with the partial address.
 * @returns The partially constructed contract address.
 */
export function computeContractAddressFromPartial(args) {
    const publicKeyHash = 'publicKey' in args ? computePublicKeysHash(args.publicKey) : args.publicKeyHash;
    const result = pedersenHash([publicKeyHash.toBuffer(), args.partialAddress.toBuffer()], GeneratorIndex.CONTRACT_ADDRESS);
    return AztecAddress.fromField(result);
}
/**
 * Computes the hash of a set of public keys to be used for computing the deployment address of a contract.
 * @param publicKey - Single public key (for now!).
 * @returns The hash of the public keys.
 */
export function computePublicKeysHash(publicKey) {
    if (!publicKey) {
        return Fr.ZERO;
    }
    return pedersenHash([publicKey.x.toBuffer(), publicKey.y.toBuffer()], GeneratorIndex.PARTIAL_ADDRESS);
}
/**
 * Computes the initialization hash for an instance given its constructor function and arguments.
 * @param initFn - Constructor function or empty if no initialization is expected.
 * @param args - Unencoded arguments, will be encoded as fields according to the constructor function abi.
 * @returns The hash, or zero if no initialization function is provided.
 */
export function computeInitializationHash(initFn, args) {
    if (!initFn) {
        return Fr.ZERO;
    }
    const selector = FunctionSelector.fromNameAndParameters(initFn.name, initFn.parameters);
    const flatArgs = encodeArguments(initFn, args);
    return computeInitializationHashFromEncodedArgs(selector, flatArgs);
}
/**
 * Computes the initialization hash for an instance given its constructor function selector and encoded arguments.
 * @param initFn - Constructor function selector.
 * @param args - Encoded arguments.
 * @returns The hash.
 */
export function computeInitializationHashFromEncodedArgs(initFn, encodedArgs) {
    const argsHash = computeVarArgsHash(encodedArgs);
    return pedersenHash([initFn.toBuffer(), argsHash.toBuffer()], GeneratorIndex.CONSTRUCTOR);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJhY3RfYWRkcmVzcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250cmFjdC9jb250cmFjdF9hZGRyZXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBZSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN2RixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDL0QsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUc5QyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDckQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFHckQsK0RBQStEO0FBRS9EOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSxVQUFVLGtDQUFrQyxDQUNoRCxRQUVzRztJQUV0RyxNQUFNLGNBQWMsR0FBRyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2RCxNQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDO0lBQzlDLE9BQU8saUNBQWlDLENBQUMsRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQztBQUM5RSxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLHFCQUFxQixDQUNuQyxRQUV5RDtJQUV6RCxNQUFNLHdCQUF3QixHQUM1QiwwQkFBMEIsSUFBSSxRQUFRO1FBQ3BDLENBQUMsQ0FBQyxRQUFRLENBQUMsd0JBQXdCO1FBQ25DLENBQUMsQ0FBQywrQkFBK0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUVoRCxPQUFPLFlBQVksQ0FDakIsQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFLHdCQUF3QixDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQzNFLGNBQWMsQ0FBQyxlQUFlLENBQy9CLENBQUM7QUFDSixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLCtCQUErQixDQUM3QyxRQUF5RjtJQUV6RixPQUFPLFlBQVksQ0FDakIsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxRQUFRLENBQUMscUJBQXFCLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsRUFDbkcsY0FBYyxDQUFDLGVBQWUsQ0FDL0IsQ0FBQztBQUNKLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLGlDQUFpQyxDQUMvQyxJQUFpRjtJQUVqRixNQUFNLGFBQWEsR0FBRyxXQUFXLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7SUFDdkcsTUFBTSxNQUFNLEdBQUcsWUFBWSxDQUN6QixDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQzFELGNBQWMsQ0FBQyxnQkFBZ0IsQ0FDaEMsQ0FBQztJQUNGLE9BQU8sWUFBWSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxxQkFBcUIsQ0FBQyxTQUFnQztJQUNwRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDZixPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUM7SUFDakIsQ0FBQztJQUNELE9BQU8sWUFBWSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ3hHLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSx5QkFBeUIsQ0FBQyxNQUErQixFQUFFLElBQVc7SUFDcEYsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ1osT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDO0lBQ2pCLENBQUM7SUFDRCxNQUFNLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN4RixNQUFNLFFBQVEsR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQy9DLE9BQU8sd0NBQXdDLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQ3RFLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSx3Q0FBd0MsQ0FBQyxNQUF3QixFQUFFLFdBQWlCO0lBQ2xHLE1BQU0sUUFBUSxHQUFHLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ2pELE9BQU8sWUFBWSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUM1RixDQUFDIn0=