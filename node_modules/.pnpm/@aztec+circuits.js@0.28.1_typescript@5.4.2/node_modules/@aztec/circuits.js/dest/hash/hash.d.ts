/// <reference types="node" resolution-mode="require"/>
import { AztecAddress } from '@aztec/foundation/aztec-address';
import { Fr } from '@aztec/foundation/fields';
import { Buffer } from 'buffer';
import type { FunctionData, SideEffect, SideEffectLinkedToNoteHash } from '../structs/index.js';
/**
 * Computes a hash of a given verification key.
 * @param vkBuf - The verification key.
 * @returns The hash of the verification key.
 */
export declare function hashVK(vkBuf: Buffer): Buffer;
/**
 * Computes a function tree from function leaves.
 * @param fnLeaves - The function leaves to be included in the contract function tree.
 * @returns All nodes of the tree.
 */
export declare function computeFunctionTree(fnLeaves: Fr[]): Fr[];
/**
 * Computes a function tree root from function leaves.
 * @param fnLeaves - The function leaves to be included in the contract function tree.
 * @returns The function tree root.
 */
export declare function computeFunctionTreeRoot(fnLeaves: Fr[]): Fr;
/**
 * Computes a constructor hash.
 * @param functionData - Constructor's function data.
 * @param argsHash - Constructor's arguments hashed.
 * @param constructorVKHash - Hash of the constructor's verification key.
 * @returns The constructor hash.
 */
export declare function hashConstructor(functionData: FunctionData, argsHash: Fr, constructorVKHash: Buffer): Fr;
/**
 * Computes a commitment nonce, which will be used to create a unique commitment.
 * @param nullifierZero - The first nullifier in the tx.
 * @param commitmentIndex - The index of the commitment.
 * @returns A commitment nonce.
 */
export declare function computeCommitmentNonce(nullifierZero: Fr, commitmentIndex: number): Fr;
/**
 * Computes a siloed commitment, given the contract address and the commitment itself.
 * A siloed commitment effectively namespaces a commitment to a specific contract.
 * @param contract - The contract address
 * @param innerNoteHash - The commitment to silo.
 * @returns A siloed commitment.
 */
export declare function siloNoteHash(contract: AztecAddress, innerNoteHash: Fr): Fr;
/**
 * Computes a unique commitment. It includes a nonce which contains data that guarantees the commitment will be unique.
 * @param nonce - The contract address.
 * @param siloedCommitment - An siloed commitment.
 * @returns A unique commitment.
 */
export declare function computeUniqueCommitment(nonce: Fr, siloedCommitment: Fr): Fr;
/**
 * Computes a siloed nullifier, given the contract address and the inner nullifier.
 * A siloed nullifier effectively namespaces a nullifier to a specific contract.
 * @param contract - The contract address.
 * @param innerNullifier - The nullifier to silo.
 * @returns A siloed nullifier.
 */
export declare function siloNullifier(contract: AztecAddress, innerNullifier: Fr): Fr;
/**
 * Computes a public data tree value ready for insertion.
 * @param value - Raw public data tree value to hash into a tree-insertion-ready value.
 * @returns Value hash into a tree-insertion-ready value.

 */
export declare function computePublicDataTreeValue(value: Fr): Fr;
/**
 * Computes a public data tree index from contract address and storage slot.
 * @param contractAddress - Contract where insertion is occurring.
 * @param storageSlot - Storage slot where insertion is occurring.
 * @returns Public data tree index computed from contract address and storage slot.

 */
export declare function computePublicDataTreeLeafSlot(contractAddress: AztecAddress, storageSlot: Fr): Fr;
/**
 * Computes the hash of a list of arguments.
 * @param args - Arguments to hash.
 * @returns Pedersen hash of the arguments.
 */
export declare function computeVarArgsHash(args: Fr[]): Fr;
export declare function computeCommitmentsHash(input: SideEffect): Fr;
export declare function computeNullifierHash(input: SideEffectLinkedToNoteHash): Fr;
/**
 * Given a secret, it computes its pedersen hash - used to send l1 to l2 messages
 * @param secret - the secret to hash - secret could be generated however you want e.g. `Fr.random()`
 * @returns the hash
 */
export declare function computeMessageSecretHash(secretMessage: Fr): Fr;
//# sourceMappingURL=hash.d.ts.map