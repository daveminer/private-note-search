import { padArrayEnd } from '@aztec/foundation/collection';
import { pedersenHash, pedersenHashBuffer } from '@aztec/foundation/crypto';
import { Fr } from '@aztec/foundation/fields';
import { createDebugLogger } from '@aztec/foundation/log';
import { numToUInt8, numToUInt16BE, numToUInt32BE } from '@aztec/foundation/serialize';
import { Buffer } from 'buffer';
import chunk from 'lodash.chunk';
import { ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, GeneratorIndex, } from '../constants.gen.js';
import { MerkleTreeCalculator } from '../merkle/merkle_tree_calculator.js';
import { VerificationKey } from '../structs/verification_key.js';
/**
 * Computes a hash of a given verification key.
 * @param vkBuf - The verification key.
 * @returns The hash of the verification key.
 */
export function hashVK(vkBuf) {
    const vk = VerificationKey.fromBuffer(vkBuf);
    const toHash = Buffer.concat([
        numToUInt8(vk.circuitType),
        numToUInt16BE(5), // fr::coset_generator(0)?
        numToUInt32BE(vk.circuitSize),
        numToUInt32BE(vk.numPublicInputs),
        ...Object.values(vk.commitments)
            .map(e => [e.y.toBuffer(), e.x.toBuffer()])
            .flat(),
        // Montgomery form of fr::one()? Not sure. But if so, why?
        Buffer.from('1418144d5b080fcac24cdb7649bdadf246a6cb2426e324bedb94fb05118f023a', 'hex'),
    ]);
    return pedersenHashBuffer(toHash);
    // barretenberg::evaluation_domain eval_domain = barretenberg::evaluation_domain(circuit_size);
    // std::vector<uint8_t> preimage_data;
    // preimage_data.push_back(static_cast<uint8_t>(proof_system::CircuitType(circuit_type)));
    // const uint256_t domain = eval_domain.domain; // montgomery form of circuit_size
    // const uint256_t generator = eval_domain.generator; //coset_generator(0)
    // const uint256_t public_inputs = num_public_inputs;
    // write(preimage_data, static_cast<uint16_t>(uint256_t(generator))); // maybe 1?
    // write(preimage_data, static_cast<uint32_t>(uint256_t(domain))); // try circuit_size
    // write(preimage_data, static_cast<uint32_t>(public_inputs));
    // for (const auto& [tag, selector] : commitments) {
    //     write(preimage_data, selector.y);
    //     write(preimage_data, selector.x);
    // }
    // write(preimage_data, eval_domain.root);  // fr::one()
    // return crypto::pedersen_hash::hash_buffer(preimage_data, hash_index);
}
let functionTreeRootCalculator;
/**
 * The "zero leaf" of the function tree is the hash of 5 zero fields.
 * TODO: Why can we not just use a zero field as the zero leaf? Complicates things perhaps unnecessarily?
 */
function getFunctionTreeRootCalculator() {
    if (!functionTreeRootCalculator) {
        const functionTreeZeroLeaf = pedersenHash(new Array(5).fill(Buffer.alloc(32))).toBuffer();
        functionTreeRootCalculator = new MerkleTreeCalculator(FUNCTION_TREE_HEIGHT, functionTreeZeroLeaf);
    }
    return functionTreeRootCalculator;
}
/**
 * Computes a function tree from function leaves.
 * @param fnLeaves - The function leaves to be included in the contract function tree.
 * @returns All nodes of the tree.
 */
export function computeFunctionTree(fnLeaves) {
    const leaves = fnLeaves.map(fr => fr.toBuffer());
    return getFunctionTreeRootCalculator()
        .computeTree(leaves)
        .nodes.map(b => Fr.fromBuffer(b));
}
/**
 * Computes a function tree root from function leaves.
 * @param fnLeaves - The function leaves to be included in the contract function tree.
 * @returns The function tree root.
 */
export function computeFunctionTreeRoot(fnLeaves) {
    const leaves = fnLeaves.map(fr => fr.toBuffer());
    return Fr.fromBuffer(getFunctionTreeRootCalculator().computeTreeRoot(leaves));
}
/**
 * Computes a constructor hash.
 * @param functionData - Constructor's function data.
 * @param argsHash - Constructor's arguments hashed.
 * @param constructorVKHash - Hash of the constructor's verification key.
 * @returns The constructor hash.
 */
export function hashConstructor(functionData, argsHash, constructorVKHash) {
    return pedersenHash([functionData.hash().toBuffer(), argsHash.toBuffer(), constructorVKHash], GeneratorIndex.CONSTRUCTOR);
}
/**
 * Computes a commitment nonce, which will be used to create a unique commitment.
 * @param nullifierZero - The first nullifier in the tx.
 * @param commitmentIndex - The index of the commitment.
 * @returns A commitment nonce.
 */
export function computeCommitmentNonce(nullifierZero, commitmentIndex) {
    return pedersenHash([nullifierZero.toBuffer(), numToUInt32BE(commitmentIndex, 32)], GeneratorIndex.NOTE_HASH_NONCE);
}
/**
 * Computes a siloed commitment, given the contract address and the commitment itself.
 * A siloed commitment effectively namespaces a commitment to a specific contract.
 * @param contract - The contract address
 * @param innerNoteHash - The commitment to silo.
 * @returns A siloed commitment.
 */
export function siloNoteHash(contract, innerNoteHash) {
    return pedersenHash([contract.toBuffer(), innerNoteHash.toBuffer()], GeneratorIndex.SILOED_NOTE_HASH);
}
/**
 * Computes a unique commitment. It includes a nonce which contains data that guarantees the commitment will be unique.
 * @param nonce - The contract address.
 * @param siloedCommitment - An siloed commitment.
 * @returns A unique commitment.
 */
export function computeUniqueCommitment(nonce, siloedCommitment) {
    return pedersenHash([nonce.toBuffer(), siloedCommitment.toBuffer()], GeneratorIndex.UNIQUE_NOTE_HASH);
}
/**
 * Computes a siloed nullifier, given the contract address and the inner nullifier.
 * A siloed nullifier effectively namespaces a nullifier to a specific contract.
 * @param contract - The contract address.
 * @param innerNullifier - The nullifier to silo.
 * @returns A siloed nullifier.
 */
export function siloNullifier(contract, innerNullifier) {
    return pedersenHash([contract.toBuffer(), innerNullifier.toBuffer()], GeneratorIndex.OUTER_NULLIFIER);
}
/**
 * Computes a public data tree value ready for insertion.
 * @param value - Raw public data tree value to hash into a tree-insertion-ready value.
 * @returns Value hash into a tree-insertion-ready value.

 */
export function computePublicDataTreeValue(value) {
    return value;
}
/**
 * Computes a public data tree index from contract address and storage slot.
 * @param contractAddress - Contract where insertion is occurring.
 * @param storageSlot - Storage slot where insertion is occurring.
 * @returns Public data tree index computed from contract address and storage slot.

 */
export function computePublicDataTreeLeafSlot(contractAddress, storageSlot) {
    return pedersenHash([contractAddress.toBuffer(), storageSlot.toBuffer()], GeneratorIndex.PUBLIC_LEAF_INDEX);
}
/**
 * Computes the hash of a list of arguments.
 * @param args - Arguments to hash.
 * @returns Pedersen hash of the arguments.
 */
export function computeVarArgsHash(args) {
    if (args.length === 0) {
        return Fr.ZERO;
    }
    const maxLen = ARGS_HASH_CHUNK_LENGTH * ARGS_HASH_CHUNK_COUNT;
    if (args.length > maxLen) {
        // TODO(@spalladino): This should throw instead of warning. And we should implement
        // the same check on the Noir side, which is currently missing.
        args = args.slice(0, maxLen);
        createDebugLogger('aztec:circuits:abis').warn(`Hashing ${args.length} args exceeds max of ${maxLen}`);
    }
    let chunksHashes = chunk(args, ARGS_HASH_CHUNK_LENGTH).map(c => {
        if (c.length < ARGS_HASH_CHUNK_LENGTH) {
            c = padArrayEnd(c, Fr.ZERO, ARGS_HASH_CHUNK_LENGTH);
        }
        return pedersenHash(c.map(a => a.toBuffer()), GeneratorIndex.FUNCTION_ARGS);
    });
    if (chunksHashes.length < ARGS_HASH_CHUNK_COUNT) {
        chunksHashes = padArrayEnd(chunksHashes, Fr.ZERO, ARGS_HASH_CHUNK_COUNT);
    }
    return pedersenHash(chunksHashes.map(a => a.toBuffer()), GeneratorIndex.FUNCTION_ARGS);
}
export function computeCommitmentsHash(input) {
    return pedersenHash([input.value.toBuffer(), input.counter.toBuffer()], GeneratorIndex.SIDE_EFFECT);
}
export function computeNullifierHash(input) {
    return pedersenHash([input.value.toBuffer(), input.noteHash.toBuffer(), input.counter.toBuffer()], GeneratorIndex.SIDE_EFFECT);
}
/**
 * Given a secret, it computes its pedersen hash - used to send l1 to l2 messages
 * @param secret - the secret to hash - secret could be generated however you want e.g. `Fr.random()`
 * @returns the hash
 */
export function computeMessageSecretHash(secretMessage) {
    return pedersenHash([secretMessage.toBuffer()], GeneratorIndex.L1_TO_L2_MESSAGE_SECRET);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9oYXNoL2hhc2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQzNELE9BQU8sRUFBRSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUM1RSxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDOUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQsT0FBTyxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFdkYsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUNoQyxPQUFPLEtBQUssTUFBTSxjQUFjLENBQUM7QUFFakMsT0FBTyxFQUNMLHFCQUFxQixFQUNyQixzQkFBc0IsRUFDdEIsb0JBQW9CLEVBQ3BCLGNBQWMsR0FDZixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBRTNFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUVqRTs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLE1BQU0sQ0FBQyxLQUFhO0lBQ2xDLE1BQU0sRUFBRSxHQUFHLGVBQWUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDN0MsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUMzQixVQUFVLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQztRQUMxQixhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUUsMEJBQTBCO1FBQzVDLGFBQWEsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDO1FBQzdCLGFBQWEsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDO1FBQ2pDLEdBQUcsTUFBTSxD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