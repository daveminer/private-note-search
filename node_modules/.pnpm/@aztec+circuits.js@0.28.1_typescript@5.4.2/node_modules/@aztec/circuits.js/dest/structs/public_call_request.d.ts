/// <reference types="node" resolution-mode="require"/>
import { AztecAddress } from '@aztec/foundation/aztec-address';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import { FieldsOf } from '@aztec/foundation/types';
import { CallContext } from './call_context.js';
import { CallRequest } from './call_request.js';
import { FunctionData } from './function_data.js';
import { PublicCallStackItem } from './public_call_stack_item.js';
/**
 * Represents a request to call a public function from a private function. Serialization is
 * equivalent to a public call stack item, but without the result fields.
 */
export declare class PublicCallRequest {
    /**
     *Address of the contract on which the function is invoked.
     */
    contractAddress: AztecAddress;
    /**
     * Data identifying the function being called.
     * TODO(#3417): Remove this since the only useful data is the function selector, which is already part of the call context.
     */
    functionData: FunctionData;
    /**
     * Context of the public call.
     * TODO(#3417): Check if all fields of CallContext are actually needed.
     */
    callContext: CallContext;
    /**
     * Context of the public call.
     * TODO(#3417): Check if all fields of CallContext are actually needed.
     */
    parentCallContext: CallContext;
    /**
     * Function arguments.
     */
    args: Fr[];
    constructor(
    /**
     *Address of the contract on which the function is invoked.
     */
    contractAddress: AztecAddress, 
    /**
     * Data identifying the function being called.
     * TODO(#3417): Remove this since the only useful data is the function selector, which is already part of the call context.
     */
    functionData: FunctionData, 
    /**
     * Context of the public call.
     * TODO(#3417): Check if all fields of CallContext are actually needed.
     */
    callContext: CallContext, 
    /**
     * Context of the public call.
     * TODO(#3417): Check if all fields of CallContext are actually needed.
     */
    parentCallContext: CallContext, 
    /**
     * Function arguments.
     */
    args: Fr[]);
    /**
     * Serialize this as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer;
    /**
     * Deserialize this from a buffer.
     * @param buffer - The bufferable type from which to deserialize.
     * @returns The deserialized instance of PublicCallRequest.
     */
    static fromBuffer(buffer: Buffer | BufferReader): PublicCallRequest;
    /**
     * Create PublicCallRequest from a fields dictionary.
     * @param fields - The dictionary.
     * @returns A PublicCallRequest object.
     */
    static from(fields: FieldsOf<PublicCallRequest>): PublicCallRequest;
    /**
     * Serialize into a field array. Low-level utility.
     * @param fields - Object with fields.
     * @returns The array.
     */
    static getFields(fields: FieldsOf<PublicCallRequest>): readonly [AztecAddress, FunctionData, CallContext, CallContext, Fr[]];
    /**
     * Creates a new PublicCallStackItem by populating with zeroes all fields related to result in the public circuit output.
     * @returns A PublicCallStackItem instance with the same contract address, function data, call context, and args.
     */
    toPublicCallStackItem(): PublicCallStackItem;
    /**
     * Creates a new CallRequest with values of the calling contract.
     * @returns A CallRequest instance with the contract address, caller context, and the hash of the call stack item.
     */
    toCallRequest(): CallRequest;
    /**
     * Returns the hash of the arguments for this request.
     * @returns Hash of the arguments for this request.
     */
    getArgsHash(): Fr;
}
//# sourceMappingURL=public_call_request.d.ts.map