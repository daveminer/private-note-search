import { times } from '@aztec/foundation/collection';
import { Fq } from '@aztec/foundation/fields';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { CircuitType } from './shared.js';
/**
 * Curve data.
 */
export class G1AffineElement {
    constructor(x, y) {
        this.x = typeof x === 'bigint' ? new Fq(x) : x;
        this.y = typeof y === 'bigint' ? new Fq(y) : y;
    }
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer() {
        return serializeToBuffer(this.x, this.y);
    }
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer  or BufferReader to read from.
     * @returns The G1AffineElement.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new G1AffineElement(Fq.fromBuffer(reader), Fq.fromBuffer(reader));
    }
}
/**
 * Used store and serialize a key-value map of commitments where key is the name of the commitment and value is
 * the commitment itself. The name can be e.g. Q_1, Q_2, SIGMA_1 etc.
 */
export class CommitmentMap {
    constructor(
    /**
     * An object used to store the commitments.
     */
    record) {
        this.record = record;
    }
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer() {
        const values = Object.entries(this.record);
        return serializeToBuffer(values.length, ...values.flat());
    }
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer or BufferReader to read from.
     * @returns The CommitmentMap.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new CommitmentMap(reader.readMap(G1AffineElement));
    }
}
/**
 * Kate commitment key object for verifying pairing equations.
 * @see proof_system/verification_key/verification_key.hpp
 */
export class VerificationKey {
    constructor(
    /**
     * For Plonk, this is equivalent to the proving system used to prove and verify.
     */
    circuitType, 
    /**
     * The number of gates in this circuit.
     */
    circuitSize, 
    /**
     * The number of public inputs in this circuit.
     */
    numPublicInputs, 
    /**
     * The commitments for this circuit.
     */
    commitments, 
    /**
     * Contains a recursive proof?
     */
    containsRecursiveProof, 
    /**
     * Recursion stack.
     */
    recursiveProofPublicInputIndices) {
        this.circuitType = circuitType;
        this.circuitSize = circuitSize;
        this.numPublicInputs = numPublicInputs;
        this.commitments = commitments;
        this.containsRecursiveProof = containsRecursiveProof;
        this.recursiveProofPublicInputIndices = recursiveProofPublicInputIndices;
    }
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer() {
        return serializeToBuffer(this.circuitType, this.circuitSize, this.numPublicInputs, new CommitmentMap(this.commitments), this.containsRecursiveProof, serializeToBuffer(this.recursiveProofPublicInputIndices.length, this.recursiveProofPublicInputIndices));
    }
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer to read from.
     * @returns The VerificationKey.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new VerificationKey(reader.readNumber(), reader.readNumber(), reader.readNumber(), reader.readObject(CommitmentMap).record, reader.readBoolean(), reader.readNumberVector());
    }
    /**
     * Builds a fake verification key that should be accepted by circuits.
     * @returns A fake verification key.
     */
    static makeFake() {
        return new VerificationKey(CircuitType.ULTRA, // This is entirely arbitrary
        2048, 116, {}, // Empty set of commitments
        false, times(16, i => i));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyaWZpY2F0aW9uX2tleS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdHJ1Y3RzL3ZlcmlmaWNhdGlvbl9rZXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ3JELE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUM5QyxPQUFPLEVBQUUsWUFBWSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFOUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUUxQzs7R0FFRztBQUNILE1BQU0sT0FBTyxlQUFlO0lBVTFCLFlBQVksQ0FBYyxFQUFFLENBQWM7UUFDeEMsSUFBSSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUNEOzs7T0FHRztJQUNILFFBQVE7UUFDTixPQUFPLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUE2QjtRQUM3QyxNQUFNLE1BQU0sR0FBRyxZQUFZLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzdDLE9BQU8sSUFBSSxlQUFlLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFD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