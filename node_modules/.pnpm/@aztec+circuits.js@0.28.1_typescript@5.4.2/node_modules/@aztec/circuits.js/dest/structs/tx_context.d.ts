/// <reference types="node" resolution-mode="require"/>
import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import { FieldsOf } from '@aztec/foundation/types';
/**
 * Transaction context.
 */
export declare class TxContext {
    /**
     * Whether this is a fee paying tx. If not other tx in a bundle will pay the fee.
     * TODO(#3417): Remove fee and rebate payment fields.
     */
    isFeePaymentTx: boolean;
    /**
     * Indicates whether this a gas rebate payment tx.
     *
     * NOTE: The following is a WIP and it is likely to change in the future.
     * Explanation: Each tx is actually 3 txs in one: a fee-paying tx, the actual tx you want to execute, and a rebate
     * tx. The fee-paying tx pays some `max_fee = gas_price * gas_limit`. Then the actual tx will cost an amount of gas
     * to execute (actual_fee = gas_price * gas_used). Then the rebate tx returns `max_fee - actual_fee` back to
     * the user.
     */
    isRebatePaymentTx: boolean;
    /**
     * Chain ID of the transaction. Here for replay protection.
     */
    chainId: Fr;
    /**
     * Version of the transaction. Here for replay protection.
     */
    version: Fr;
    constructor(
    /**
     * Whether this is a fee paying tx. If not other tx in a bundle will pay the fee.
     * TODO(#3417): Remove fee and rebate payment fields.
     */
    isFeePaymentTx: boolean, 
    /**
     * Indicates whether this a gas rebate payment tx.
     *
     * NOTE: The following is a WIP and it is likely to change in the future.
     * Explanation: Each tx is actually 3 txs in one: a fee-paying tx, the actual tx you want to execute, and a rebate
     * tx. The fee-paying tx pays some `max_fee = gas_price * gas_limit`. Then the actual tx will cost an amount of gas
     * to execute (actual_fee = gas_price * gas_used). Then the rebate tx returns `max_fee - actual_fee` back to
     * the user.
     */
    isRebatePaymentTx: boolean, 
    /**
     * Chain ID of the transaction. Here for replay protection.
     */
    chainId: Fr, 
    /**
     * Version of the transaction. Here for replay protection.
     */
    version: Fr);
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer;
    toFields(): Fr[];
    /**
     * Deserializes TxContext from a buffer or reader.
     * @param buffer - Buffer to read from.
     * @returns The TxContext.
     */
    static fromBuffer(buffer: Buffer | BufferReader): TxContext;
    static empty(chainId?: Fr | number, version?: Fr | number): TxContext;
    isEmpty(): boolean;
    /**
     * Create a new instance from a fields dictionary.
     * @param fields - The dictionary.
     * @returns A new instance.
     */
    static from(fields: FieldsOf<TxContext>): TxContext;
    /**
     * Serialize into a field array. Low-level utility.
     * @param fields - Object with fields.
     * @returns The array.
     */
    static getFields(fields: FieldsOf<TxContext>): readonly [boolean, boolean, Fr, Fr];
    hash(): Fr;
}
//# sourceMappingURL=tx_context.d.ts.map