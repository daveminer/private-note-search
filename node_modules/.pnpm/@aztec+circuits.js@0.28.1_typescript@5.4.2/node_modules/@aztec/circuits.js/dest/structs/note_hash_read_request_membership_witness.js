import { makeTuple, range } from '@aztec/foundation/array';
import { toBufferBE } from '@aztec/foundation/bigint-buffer';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { MAX_NEW_NOTE_HASHES_PER_CALL, NOTE_HASH_TREE_HEIGHT } from '../constants.gen.js';
/**
 * A ReadRequestMembershipWitness is similar to a MembershipWitness but includes
 * some additional fields used to direct the kernel regarding whether a read is transient
 * and if so which commitment it corresponds to.
 */
export class NoteHashReadRequestMembershipWitness {
    constructor(
    /**
     * Index of a leaf in the Merkle tree.
     */
    leafIndex, 
    /**
     * Sibling path of the leaf in the Merkle tree.
     */
    siblingPath, 
    /**
     * Whether or not the read request corresponds to a pending note hash.
     */
    isTransient = false, 
    /**
     * When transient, the note hash being read was created by some app circuit in the current TX.
     * The kernel will need some hint to efficiently find that note hash for a given read request.
     * When not transient, this can be 0.
     */
    hintToNoteHash) {
        this.leafIndex = leafIndex;
        this.siblingPath = siblingPath;
        this.isTransient = isTransient;
        this.hintToNoteHash = hintToNoteHash;
        if (hintToNoteHash.toBigInt() > MAX_NEW_NOTE_HASHES_PER_CALL) {
            throw new Error(`Expected ReadRequestMembershipWitness' hintToNoteHash(${hintToNoteHash}) to be <= NEW_NOTE_HASHES_LENGTH(${MAX_NEW_NOTE_HASHES_PER_CALL})`);
        }
    }
    toBuffer() {
        return serializeToBuffer(toBufferBE(this.leafIndex.toBigInt(), 32), ...this.siblingPath, this.isTransient, this.hintToNoteHash);
    }
    static mock(size, start) {
        return new NoteHashReadRequestMembershipWitness(new Fr(start), range(size, start).map(x => new Fr(BigInt(x))), false, new Fr(0));
    }
    /**
     * Creates a random membership witness. Used for testing purposes.
     * @returns Random membership witness.
     */
    static random() {
        return new NoteHashReadRequestMembershipWitness(new Fr(0n), makeTuple(NOTE_HASH_TREE_HEIGHT, () => Fr.random()), false, new Fr(0));
    }
    /**
     * Creates a read request membership witness whose sibling path is full of zero fields.
     * @param leafIndex - Index of the leaf in the Merkle tree.
     * @returns Membership witness with zero sibling path.
     */
    static empty(leafIndex) {
        const arr = makeTuple(NOTE_HASH_TREE_HEIGHT, () => Fr.ZERO);
        return new NoteHashReadRequestMembershipWitness(new Fr(leafIndex), arr, false, new Fr(0));
    }
    /**
     * Creates a transient read request membership witness.
     * @returns an empty transient read request membership witness.
     */
    static emptyTransient() {
        const arr = makeTuple(NOTE_HASH_TREE_HEIGHT, () => Fr.ZERO);
        return new NoteHashReadRequestMembershipWitness(new Fr(0), arr, true, new Fr(0));
    }
    static fromBufferArray(leafIndex, siblingPath, isTransient, hintToNoteHash) {
        return new NoteHashReadRequestMembershipWitness(leafIndex, siblingPath.map(x => Fr.fromBuffer(x)), isTransient, hintToNoteHash);
    }
    static fromMembershipWitness(membershipWitness, isTransient, hintToNoteHash) {
        return new NoteHashReadRequestMembershipWitness(new Fr(membershipWitness.leafIndex), membershipWitness.siblingPath, isTransient, hintToNoteHash);
    }
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer or reader to read from.
     * @returns The deserialized `ReadRequestMembershipWitness`.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const leafIndex = Fr.fromBuffer(reader);
        const siblingPath = reader.readArray(NOTE_HASH_TREE_HEIGHT, Fr);
        const isTransient = reader.readBoolean();
        const hintToNoteHash = Fr.fromBuffer(reader);
        return new NoteHashReadRequestMembershipWitness(leafIndex, siblingPath, isTransient, hintToNoteHash);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90ZV9oYXNoX3JlYWRfcmVxdWVzdF9tZW1iZXJzaGlwX3dpdG5lc3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc3RydWN0cy9ub3RlX2hhc2hfcmVhZF9yZXF1ZXN0X21lbWJlcnNoaXBfd2l0bmVzcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzNELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUM3RCxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDOUMsT0FBTyxFQUFFLFlBQVksRUFBUyxpQkFBaUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRXJGLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRzFGOzs7O0dBSUc7QUFDSCxNQUFNLE9BQU8sb0NBQW9DO0lBQy9DO0lBQ0U7O09BRUc7SUFDSSxTQUFhO0lBQ3BCOztPQUVHO0lBQ0ksV0FBb0Q7SUFDM0Q7O09BRUc7SUFDSSxjQUFjLEtBQUs7SUFDMUI7Ozs7T0FJRztJQUNJLGNBQWtCO1FBZGxCLGNBQVMsR0FBVCxTQUFTLENBQUk7UUFJYixnQkFBVyxHQUFYLFdBQVcsQ0FBeUM7UUFJcEQsZ0JBQVcsR0FBWCxXQUFXLENBQVE7UUFNbkIsbUJBQWMsR0FBZCxjQUFjLENBQUk7UUFFekIsSUFBSSxjQUFjLENBQUMsUUFBUSxFQUFFLEdBQUcsNEJBQTRCLEVBQUUsQ0FBQztZQUM3RCxNQUFNLElBQUksS0FBSyxDQUNiLHlEQUF5RCxjQUFjLHFDQUFxQyw0QkFBNEIsR0FBRyxDQUM1SSxDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxpQkFBaUIsQ0FDdEIsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEVBQUUsRUFB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