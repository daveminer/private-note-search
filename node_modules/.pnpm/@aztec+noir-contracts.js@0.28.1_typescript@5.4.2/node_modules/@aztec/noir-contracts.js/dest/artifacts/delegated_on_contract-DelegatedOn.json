{ "noir_version": "0.25.0+589a6cb62caf38445c768429150eee469ae35d77", "name": "DelegatedOn", "functions": [{ "name": "public_set_value", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "new_value", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 37 }], "new_value": [{ "start": 37, "end": 38 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239] }, "bytecode": "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", "debug_symbols": "1Z3drmVZkZ3fpa6RtSJm/E1exfIFbrclpBa0GmzJQry7V9t5TtHiCHKQHuFRVyTUmmsGioxReb78Yu8//fQvv/+n3/zxt7//3R9++vWffnr+k1f89Ov//Kef/vCvv/ndv/8vf/jjb/7tjz/9+vnVT//8u//2/ueff/XTf//tv/zzT7/28j//l1/9nxMJnyj4RMMnBj5x0RP9fP+JX/3Vc+fYtydP3s9npz9ebsyXO/z/9cAn4N9JDf9Oavh3UsO/kxr+ndTw76R54BMGn4B7PnDPB+75wD0fuOcD93zgng/c8/tD6WF5vz1pY3854F882pYfz7bV58N270cpplOK65RydEoJnVJSp5TSKaV1ShmdUq5KKeeRSdvzyKTteWTS9jwyaXsembQ9j0zankcmbc8jk7bnkUnb8+ikremkremkremkremkremkremkremkremkremkremkreukreukreukreukreukreukreukreukreukreuk7dFJ26OTtkcnbY9O2h6dtD06aXt00vbopO3RSdujk7ahk7ahk7ahk7ahk7ahk7ahk7ahk7ahk7ahk7ahk7apk7apk7apk7apk7apk7apk7apk7apk7apk7apk7alk7alk7alk7alk7alk7alk7alk7alk7alk7alk7atk7atk7atk7atk7atk7atk7atk7atk7atk7atk7ajk7ajk7ajk7ajk7ajk7ajk7ajk7ajk7ajk7ajk7Y6u2RHZ5fs6OySHZ1dsqOzS3Z0dsmOzi7Z0dklOzq7ZEdnlyx0dslCZ5csdHbJQmeXLB6ZtA2dXbLQ2SULnV2y0NklC51dstDZJQudXbLQ2SULnV2y0NklC51dstDZJQudXbLQ2SULnV2y0NklC51dstDZJQudXbLQ2SULnV2y0NklC51dstDZJQudXbLQ2SULnV2yWFxVKv8sZc5XpZROKVu/bf0lkN+efX85X5SytpTzHaWYTimuU8rRKSW2JsjfRz4efn/98wz54x/FpFIxpVRMKxUzSsVcoWL2FnS+pxhTKsaVijlKxSglcColcColcCol8NrCjsf5+HOvx/X/8AcI7Olvhd9faOFry0BY4XPzo4b7WHxVuP1SC/dfauHoZ6YH/I0LAX/jQsDfuBDwNy5EP/CJH/rd+fd78WP7E9/x/kN+f5Dfn+T3F/n9P/Rv5Zinvj36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" }, { "name": "view_public_value", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [], "param_witnesses": {}, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [0] }, "bytecode": "H4sIAAAAAAAA/81UwU7DMAx12rTr6BBcOYAqcUeZxAeEX+APiloQl1XqNgl+HkGYrb5lFpeFaU+q7DpO7Dw7JiIytENOEwzt44FlBTbPX4A7Bo9uWYZDLKmY/XwF6zX4ZWy7BpuBPGX9K1Wezi0v6ZCjCrjzCWPFNfCg58BH7FfDega2LNobeL2H9ULZUyrxRMeaSOlKZS/yVMBdPOvuOPzyhLE8/Eu8BeRRniAfbGUP/8WZxJ6lj+0qmuZD6jvNoXYe8pd4FnzuWF7RruZil7yw/wMWwI341gpv+IYs+OP7TzlrKpp61Sc8F+8m+GvW/Pd7uWBuA9abYWzf+ue+7QykZqM0URrlGhnYUM8VG9H+uLJgkxbRWgBHXdxSczqkNOl7yEmHRgbablnesHwax/azeV91/UczbDfN8Nq8DNtVt6Zvd/PeXBoIAAA=", "debug_symbols": "zZfNaoNAFIXfZdZS7s9kfnyV0sU0tSCICdEWivjuHUm0i4RCJJGz8zLncr7F+MEMpjnsU18f2s6Ug6GXnSlfB9MdUzvNXZ9OvSlZfSxM1X7kT0t+LMxn3VSmFCdjcZ1m9nOabVjSTm+E1csla1mXKOeStyLjOCwcj4UTsHAiFg4TGA+D8QgYj4LxWDAeMDczmJwZzM4MpmcG87OA+Vme6+dzh2zQoRt02A06HuK7XVg6Av1/P5hY5zCJ/N2QGC5EDo7IwxEFOKKIRqQER8RwRDf/fnGzMpTstcLVrVnya5bCmqW4YsnSnUt5+k6nOr031fSonw6/2v38xs9j/3M8n4y/" }, { "name": "view_private_value", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "amount", "type": { "kind": "field" }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "amount": [{ "start": 0, "end": 1 }], "owner": [{ "start": 1, "end": 2 }] }, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [2] }, "bytecode": "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", "debug_symbols": "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0HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303fhA4P0xGDqYOrh0sHSwdXDr4NHBq4NaTmg5oeWElhNaTmg5oeWElhNaTmg5oeWklpNaTmo5qeWklpNaTmo5qeWklpNaztJylpaztJyl5SwtZ2k5S8tZWs7ScpaWU1pOaTml5ZSWU1pOaTml5ZSWU1pOaTmt5bSW01pOazmt5bSW01pOazmt5bSWs7WcreVsLWdrOVvL2VrO1nK2lrO1nK3lHC3naDlHyzlaztFyjpZztJyj5Rwt52g5V8u5Ws7Vcq6Wc7Wcq+VcLedqOVfLuVrOaDmj5YyWM1rOaDmj5YyWM1rOaDlqyKGGHGrIoYYcasg//veDDrYObh08Onh1UMtRQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXk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yKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIa+fGPKPD8J+G/wBMJ8OLh0sHWwd3Dp4dPDq4ODgTwz5FwZDB7Wc1nJay2ktp7Wc1nJay2ktZ2s5W8vZWs7WcraWs7WcreVsLWdrOVvLOVrO0XKOlnO0nKPlHC3naDlHyzlaztFyrpZztZyr5Vwt52o5V8u5Ws7Vcq6Wc7Wc0XJGyxktZ7Sc0XJGyxktZ7Sc0XIGy6mPDx0MHUwdXDpYOtg6uHXw6ODVQS0ntJzQckLLCS0ntJzQckLLCS0ntJzQclLLSS0ntZzUclLLSS0ntZzUclLLSS1naTlLy1laztJylpaztJyl5SwtZ2k5S8spLae0HDXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNeRRQx415FFDHjXkUUMeNOT1gYb8YzB0MHVw6WDpYOvg1sGjg1cHtZzQckLLCS0ntJzQckLLCS0ntJzQckLLSS0ntZzUclLLSS0ntZzUclLLSS0ntZyl5SwtZ2k5S8tZWs7ScpaWs7ScpeUsLae0nNJySsspLae0nNJySsspLae0nNJyWstpLae1nNZyWstpLae1nNZyWstpLWdrOVvL2VrO1nK2lrO1nK3lbC1nazlbyzlaztFyjpZztJyj5Rwt52g5R8s5Ws7Rcq6Wc7Wcq+VcLedqOVfLuVrO1XKulnO1nNFyRssZLWe0nNFyRssZLWe0nNFy1JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+asjnZ4Z86vfBm58Obh08Onh1cHDwZ4b81wdDB//qL8f6iE8Htw4eHbw6+Okvx7/8WSV/HvyXBeLfB/8y97nL/sJc4Fzi3MK5wrnGuY1zB+cuzmEvG3vZ2MvGXjb2srGXjb1s7GVjLxt72djLwV4O9nKwl4O9HOzlYC8HeznYy8FeDvZysZeLvVzs5WIvF3u52MvFXi72crGXi70M9jLYy2Avg70M9jLYy2Avg70M9jLWy/34wLnAucS5hXOFc41zG+cOzl2cw14CewnsJbCXwF4CewnsJbCXwF4CewnsJbGXxF4Se0nsJbGXxF4Se0nsJbGXxF4W9rKwl4W9LOxlYS8Le1nYy8JeFvaysJfCXgp7KeylsJfCXgp7KeylsJfCXtB3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303THfrQ/z3R9zgXOJcwvnCuca5zbOHZy7OIe9BPYS2EtgL4G9BPYS2EtgL4G9BPYS2EtiL4m9JPaS2EtiL4m9JPaS2EtiL4m9LOxlYS8Le1nYy8JeFvaysJeFvSzsZWEvhb0U9lLYS2Evhb0U9lLYS2Evhb0U9tLYS2Mvjb009tLYS2Mvjb009tLYS2MvG3vZ2MvGXjb2srGXjb1s7GVjLxt72djLwV4O9nKwl4O9HOzlYC8HeznYy8FeDvZysZeLvVzs5WIvF3u52MvFXi72crGXi70M9jLYy2Avg70M9jLYy2Avg70M9oK+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ouwt9d6HvLvTdhb670HcX+u5C313ou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvrvRdzf67kbf3ei7G313o+9u9N2NvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHHPOiYBx3zoGOezx1zZ+4/z+086/e5yN8G7+eQ+SuDoYOpg0sHSwdbB7cOHh28OqjlhJYTWk5oOaHlhJYTWk5oOaHlhJYTWk5qOanlpJaTWk5qOanlpJaTWk5qOanlLC1naTlLy1laztJylpaztJyl5SwtZ2k5peWUllNaTmk5peWUllNaTmk5peWUltNaTms5reW0ltNaTms5reW0ltNaTms5W8vZWs7WcraWs7WcreVsLWdrOVvL2VrO0XKOlnO0nKPlHC3naDlHyzlaztFyjpZztZyr5Vwt52o5V8u5Ws7Vcq6Wc7Wcq+WMljNazmg5o+WMljNazmg5o+WMlqOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjw/MeSq3werzqeDSwdLB1sHtw4eHbw6ODj4E0P+hcHQwZ+U0+e3wR8fw346uHSwdLB1cOvg0cGrg4ODPzHkXxgMHdRySsspLae0nNJySsspLae0nNZyWstpLae1nNZyWstpLae1nNZyWsvZWs7WcraWs7WcreVsLWdrOVvL2VrO1nKOlnO0nKPlHC3naDlHyzlaztFyjpZztJyr5Vwt52o5V8u5Ws7Vcq6Wc7Wcq+VcLWe0nNFyRssZLWe0nNFyRssZLWe0nLFy+uPjQwdDB1MHlw6WDrYObh08Onh1UMsJLSe0nNByQssJLSe0nNByQssJLSe0nNRyUstJLSe1nNRyUstJLSe1nNRyUstZWs7ScpaWs7ScpeUsLWdpOUvLWVrO0nJKyyktp7Sc0nJKyyktp7Sc0nJKyyktp7Wc1nJay2ktp7Wc1nJay2ktp7Wc1nK2lrO1nK3lbC1nazlby9laztZytpaztZyj5Rwt52g5R8s5Ws7Rco6Wc7Sco+UcLedqOVfLuVrO1XKulnO1nKvlXC3najlXyxktZ7Sc0XJGyxktZ7Sc0XJGyxktRw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZBbDbnVkFsNudWQWw251ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+agh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lrO0nNJySsspLae0nNJySsspLae0nNJyfuYAf/W3gJ85wF8f/PyXY8f9bfDH57D/ZvBv6L9Yf88x+3uOOd9zzP2eY+ZbjvmJjfzhx8T3HJPfc8z6nmO+5xW43/MK3D/gFVi/f7vgjw/2fv+x6/cjztcfcb/+iPnyI+bj64/4A278j4/Sfjtif3ZEfv0R6+uPqK8/or/+iP31R5yvP+J+/RHz1Uf0x8fXHxFff0R+/RHr64+orz+iv/6I/fVHnK8/4n79EV9/u+Prb3d8/e2Or7/d8fW3O77+dsfX3+74+tsdX3+74+tvd3z97c6vv9359bc7v/5259ff7vz6251ff7vz6293fv3t/snHNz9Y//cj+rP9wf7Jxze/MJg6uHSwdPAnFf3lO8D3p98B3j/5+OYXBo8OXh0cHPzJxze/MBg6mDq4dLB0UMspLae0nNJySstpLae1nNZyWstpLae1nNZyWstpLae1nK3lbC1nazlby9laztZytpaztZyt5Wwt52g5R8s5Ws7Rcn7y6fZf/QipT+vg1sGjg1cH8dtU+n7oYOhg6uDSQS3najlXy7laztVyrpYzWs5oOaPljJYzWs5oOaPljJYzWs5gOfvjQwdDB1MHlw6WDrYObh08OqgBhAYQGkBoAKEB/ITH/+pW5v4Jev/C4E82T//yT1Yx9c//EU/bP6HsP/KIn1D2H3pEfP0R+fVHrK8/or7+iP76I/bXH3G+/oivv9359bd7/RG3+//3W8j2iq8/Ir/+iPX1R9TXH/H1t3t9/e1eX3+719ff7vX1t7u+/vfu+vrfu+vrf++ur/+9u77+9+76+ttdX3+76+tvd3397a6vv9399be7v/5299ff7v76291ff7v76293f/3t7q+/3f31t7u//nbvr7/d++tv9/76272//nbvr7/d++tv9/76272//nbvr7/d++tv9/n6232+/nafr7/d5+tv9/n6232+/nafr7/d5+tv9/n6232+/nbfr7/d9+tv9/362/2TD/Tz4/c/WiFz/ZsjfhvcOnh08Org4OBPPtD/hcHP28j9+3cg572fDn7+K571+3eAZ8+ng0sHSwdbB7cOHh28Ojg2eH7ygf4vDIYOpg4uHSwdbB3cOnh08OqglhNaTmg5oeWElhNaTmg5oeWElhNaTmg5qeWklpNaTmo5qeWklpNaTmo5qeWklrO0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8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEsNudSQSw251JBLDbnUkEspuJSCSym4lIJLKbjmG/7Ay5r9HYec7zjkfsch3/BntvbHH/FHd1b+dsi/+uuH/vUh8R2H5Hccsr7jkPoDDln390PWp4f0dxyyv+OQ8x2H3O84ZL7hkPiGP6y3I77jkPyOQ9Z3HFLfcUh/xyH7Ow4533HI/Y5DvuGP5+78jhuf33Hj8ztufH7Hjc/vuPH5HTc+v+PG53fc+PyOG5/fcePXd9z49R03fn3HjV/fcePXd9z49R03fn3HjV/fcePXd9z49R03vr7jxtd33Pj6jhtf33Hj6ztufH3Hja/vuPH1HTe+vuPGf/5x818fSxtbNlY29mlvsWP/eS52nX/zE/jb4NbBo4NXBwcHP/+Y+VcGQwdTB5cOlg5qOVvL2VrO1nL2T8rp3//OgcnP/hjvPh86GDqYOrh0sP7dgz/+3f/9d//97//uf/8v//kff8z8y//z//qH//RPf/9f/+HP//af/p//9v/9f/75/wU=" }, { "name": "private_set_value", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "new_value", "type": { "kind": "field" }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "new_value": [{ "start": 33, "end": 34 }], "owner": [{ "start": 34, "end": 35 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263] }, "bytecode": "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", "debug_symbols": "7VjRjhoxDPyXPCNkO7aT8CvVPWyvVEJC3OmglSrEv3cXLt4cRI3Yk2hBfULL2st4sMez2bv1y3O3W71stm6xdwhu8WXvtq/dZrjc7rq3nVvAzC033/rPw8x9X62XbkFKh9lFHEp6j8SIFhtDJZQoxfdY8iIWjClVomOSjCEB8ofop5lDvEvUdCvU7Cmj5kSfRO0/g1pQM4FCEEfc1RIBMm4EGotE8ZXovjJ7chhjOR5R812ilrtErTXUATKYwC3klILkhk1Fd5M/tWCo/oC1bUihNTyonKv1MMKpBkfOsTEWw4OxhhxSHktCGjnHgdLLJwdvkyaN2P5bzJBJ6AMn1w9xfBAGk6p1LWqL7gYp6T8pF6QQ3JQUBNMsPK6ngpYBDf41ND3vF2jotmiIxNBobLQMC2e9YNFUqv8A3d8vdL4xdLN86Nm3BpUJzGqxNlSaY9Z/8aP+JziWKQ9TZkC21a9lmRXp4mDjD4UYcZggXfowDKr5raD8ZwYxmZEjKHzCYM6upzA8ThOG3FkRwvmsxX+6TMnrnDRgo0wfkjnzwvLLyZjPq6Ji3gKLHZfktP7n9SMBit4cSVR/btGHPJyYV92qYhqiUDR1rxHHlTCvmzfPmWif4vmfzvO6uWkl4ZQkmpLkr06K8/reEJ/pk0BnbTEk6ZSkqjioB5uz4jUS9PDUX/3s3lbd1/VyOGwabv7YPOezp/5y9+v1dOfwGw==" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "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", "debug_symbols": "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" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "35": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "62": { "source": "use dep::protocol_types::{\n    constants::{MAX_NOTES_PER_PAGE, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    abis::side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateSet<T> {}\n\nimpl<Note> PrivateSet<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n    // docs:start:insert\n    pub fn insert<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            broadcast\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N>(self, note: &mut Note) where Note: NoteInterface<N> {\n        create_note_hash_from_public(self.context.public.unwrap(), self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n\n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(\n            false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(\n            false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // docs:start:remove\n    pub fn remove<N>(self, note: Note) where Note: NoteInterface<N> {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_consumption(note);\n        let has_been_read = context.note_hash_read_requests.any(|r: SideEffect| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>\n    ) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(self.context.private.unwrap(), storage_slot, options);\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N>(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr" }, "63": { "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T> Storage<T> for PublicMutable<T> {}\n\nimpl<T> PublicMutable<T> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable reads only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr" }, "77": { "source": "use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_non_existent_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL>,\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_non_existent_read_requests: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_non_existent_read_requests: self.nullifier_non_existent_read_requests.storage,\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address,\n            reverted: false\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_non_existent_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_non_existent_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let side_effect_counter = self.side_effect_counter;\n        // TODO get next value from output of `call_public_function_internal`\n        self.side_effect_counter += 1;\n\n        call_public_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "85": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/log.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "90": { "source": "use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "95": { "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/rand.nr" }, "104": { "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr" }, "106": { "source": "use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr" }, "107": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "118": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr" }, "121": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "122": { "source": "use dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note: Note) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index].lt(fields_1[sort.field_index]);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter.nr" }, "147": { "source": "use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl Eq for PublicKeysHash {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    assert(actual.to_field() == 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/public_keys_hash.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "198": { "source": "use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<1> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<1> for U128 {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr" }, "199": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "202": { "source": "global ARGS_LENGTH: u64 = 16;\nglobal RETURN_VALUES_LENGTH: u64 = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_NOTE_HASHES_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX ≥ MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_NOTE_HASHES_PER_TX ≥ MAX_NEW_NOTE_HASHES_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX ≥ MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_CALL: u64 = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: u64 = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: u64 = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: u64 = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: u64 = 16;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_CALL: u64 = 32;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_CALL: u64 = 2; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL: u64 = 2;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: u64 = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 56;\n\nglobal MAX_NEW_NULLIFIERS_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 56;\n\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: u64 = 8;\n\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 8;\nglobal MAX_NON_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 3;\nglobal MAX_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 5;\n\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\n\nglobal MAX_PUBLIC_DATA_READS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\n\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: u64 = 2;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_TX: u64 = 128;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_TX: u64 = 8; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX: u64 = 8;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: u64 = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: u64 = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: u64 = 3;\nglobal FUNCTION_TREE_HEIGHT: u64 = 5;\nglobal NOTE_HASH_TREE_HEIGHT: u64 = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: u64 = 40;\nglobal NULLIFIER_TREE_HEIGHT: u64 = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: u64 = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: u64 = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\nglobal NULLIFIER_TREE_ID = 0;\nglobal NOTE_HASH_TREE_ID = 1;\nglobal PUBLIC_DATA_TREE_ID = 2;\nglobal L1_TO_L2_MESSAGE_TREE_ID = 3;\nglobal ARCHIVE_TREE_ID = 4;\n\n// SUB-TREES RELATED CONSTANTS\nglobal NOTE_HASH_SUBTREE_HEIGHT: u64 = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: u64 = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: u64 = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: u64 = 5;\nglobal ARCHIVE_HEIGHT: u64 = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: u64 = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: u64 = 35;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: u64 = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: u64 = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: u64 = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u64 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u64 = 32;\n// The following is used in immutable state variables to compute an initialization slot whose value is used to\n// determine whether a given variable has been initialized (by asserting that the value in the slot is 0).\n// The initialization slot is computed by adding the constant bellow to the variable's storage slot. This constant has\n// to be large enough so that it's ensured that it doesn't collide with storage slots of other variables.\nglobal INITIALIZATION_SLOT_SEPARATOR: Field = 1000_000_000;\nglobal INITIAL_L2_BLOCK_NUM: Field = 1;\n// 126976 = 31 * 4096;\nglobal BLOB_SIZE_IN_BYTES: Field = 126976;\n\n// CONTRACT CLASS CONSTANTS\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: u64 = 15000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: u64 = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: u64 = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\nglobal DEPLOYER_CONTRACT_ADDRESS = 0x0bffa876f07f9fe1802579dfef599810202f9c25b9a2f58921064a267d1ad1d3;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\nglobal MAX_NOTE_FIELDS_LENGTH: u64 = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: u64 = 23;\nglobal MAX_NOTES_PER_PAGE: u64 = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: u64 = 212;\n\n// LENGTH OF STRUCTS SERIALIZED TO FIELDS\nglobal AZTEC_ADDRESS_LENGTH = 1;\nglobal CALL_CONTEXT_LENGTH: u64 = 7;\nglobal CONTENT_COMMITMENT_LENGTH: u64 = 7;\nglobal CONTRACT_INSTANCE_LENGTH: u64 = 6;\nglobal CONTRACT_STORAGE_READ_LENGTH: u64 = 2;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: u64 = 2;\nglobal ETH_ADDRESS_LENGTH = 1;\nglobal FUNCTION_DATA_LENGTH: u64 = 4;\nglobal FUNCTION_LEAF_PREIMAGE_LENGTH: u64 = 5;\nglobal GLOBAL_VARIABLES_LENGTH: u64 = 6;\nglobal HEADER_LENGTH: u64 = 23; // 2 for last_archive, 7 for content commitment, 8 for state reference, 6 for global vars\nglobal L1_TO_L2_MESSAGE_LENGTH: u64 = 8;\nglobal L2_TO_L1_MESSAGE_LENGTH: u64 = 2;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH = 5;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: u64 = 6;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: u64 = 215;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 210;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 202;\nglobal STATE_REFERENCE_LENGTH: u64 = 8; // 2 for snap + 8 for partial\nglobal TX_CONTEXT_DATA_LENGTH: u64 = 4;\nglobal TX_REQUEST_LENGTH: u64 = 10;\n\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH: Field = 13; // 2 + FUNCTION_DATA_LENGTH + CALL_CONTEXT_LENGTH\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: u64 = 674;\nglobal NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal NUM_MSGS_PER_BASE_PARITY: u64 = 4;\n// NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP / NUM_MSGS_PER_BASE_PARITY\nglobal NUM_BASE_PARITY_PER_ROOT_PARITY: u64 = 4;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n ≤ 8                         | 0 < hash_index ≤ 32  |\n * | MID       | 8 < n ≤ 16                    | 32 < hash_index ≤ 40 |\n * | HIGH      | 16 < n ≤ 48                   | 40 < hash_index ≤ 48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size ≤ 8\nglobal GENERATOR_INDEX__NOTE_HASH = 1;\nglobal GENERATOR_INDEX__NOTE_HASH_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size ≤ 16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size ≤ 44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\nglobal GENERATOR_INDEX__AUTHWIT_INNER = 45;\nglobal GENERATOR_INDEX__AUTHWIT_OUTER = 46;\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/constants.nr" }, "209": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "239": { "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.owner.to_field(), self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr" }, "262": { "source": "// A contract used along with `Parent` contract to test nested calls.\ncontract DelegatedOn {\n    use dep::aztec::prelude::{\n        AztecAddress, FunctionSelector, NoteHeader, NoteGetterOptions, NoteViewerOptions,\n        emit_unencrypted_log, PublicMutable, PrivateSet, PrivateContext\n    };\n\n    use dep::aztec::{context::{PublicContext, Context}, protocol_types::abis::call_context::CallContext};\n    use dep::value_note::value_note::{ValueNote, VALUE_NOTE_LEN};\n\n    struct Storage {\n        current_value: PublicMutable<Field>,\n        a_private_value: PrivateSet<ValueNote>,\n    }\n\n    #[aztec(private)]\n    fn private_set_value(new_value: Field, owner: AztecAddress) -> Field {\n        let mut note = ValueNote::new(new_value, owner);\n        storage.a_private_value.insert(&mut note, true);\n        new_value\n    }\n\n    #[aztec(public)]\n    fn public_set_value(new_value: Field) -> Field {\n        storage.current_value.write(new_value);\n        new_value\n    }\n\n    unconstrained fn view_private_value(amount: Field, owner: AztecAddress) -> pub Field {\n        let options = NoteViewerOptions::new().select(0, amount, Option::none()).select(1, owner.to_field(), Option::none()).set_limit(1);\n        let notes = storage.a_private_value.view_notes(options);\n        notes[0].unwrap_unchecked().value\n    }\n\n    unconstrained fn view_public_value() -> pub Field {\n        storage.current_value.read()\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/delegated_on_contract/src/main.nr" } } }
