{ "noir_version": "0.25.0+589a6cb62caf38445c768429150eee469ae35d77", "name": "EasyPrivateVoting", "functions": [{ "name": "end_vote", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 37 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238] }, "bytecode": "H4sIAAAAAAAA/+2dd3QcyXXue0Aw9oBgTsvdxXITM4EBmBOYc84LJpAASZAEQBIAc8455wiGTdpdSbZlRUuWZFuWJduyZCtYtnKO753z3nnnPP+xdtVMXeFjbfcIA3UBd2aqz7mnq25X9/3V13d6erp7qn/vOE7IiU3NhPVyPjjR8kI1z/3TprwAt5VrkjOUJJwZScLZLEk4M5OEs3mScLZIEs6WScLZKkk4WwfIKdkynKenoHnbGNA1aEY3yTQNJ4GmWUmmadsk0DTbSY5jVLsk4WyfJJwdkoSzY5JwdkoSzs5JwtklSTi7JglntyTh7J4knD2ShPOZJOHsmSSczyYJ53NJwvl8knDmJAnnC0nC2StJOF9MEs6XAuTsB5wvq/krav6qmvdW8z5q3lfNad3+qo+Zqj5A2EBhgySftkzeaIgIyxdWoC0bLGyIsKHChqllOWrZcGEjhI0UNkrYaGFjhI1VWowTNl7YBGEThU0SNlnYFGFThU0TNl3YDGEzhc0SNlvYHGFzhc0TNl/YAmELhS0StljYEmFLNZZlwl4TViRsubAVwlYKWyVstbBiYWuErRVWIqxU2Dph64VtEFYmbKOwTcI2CysXViGsUtgWYVuFbRNWJaxaWI2w7cJ2CNupabZL2G5he4Tt1Tj3Cdsv7ICwg8IOCTss7Iiwo8KOCTsu7ISwk8JOCTst7Iyws8LOCTsv7IKwi8IuCbss7Iqwq8KuCbsu7Iawm8JuCbst7I6wu4qFPgj3hN0X9kBYrbCHwh4JeyzsibDXhb0h7E1hbwl7W9iHhL0j7F1h7wn7sLCPCPuosD8T9ufC/kLYx4T9pbCPC/uEsE8K+5SwTwv7jLC/EvZZYZ8T9tfCPi/sC8K+KOxvhP2tsL8T9iVhfy/sy8L+QdhXhH1V2D9qmv+TsH8W9jVh/6J8X1fzb6i2dL3pX4X9myp/U82/pebfVvPvaOv8u7Dvar7/EPafmu97wr6vyj9Q8x+q+Y/U/Mdq/hM1/6ma/0zNf67mv1DzX6r5r9T812r+GzX/rZr/Ts1/L2xAj1i5lVM3FToBHaMKStfJexUk/svO05PUoplaRvMc5c9UdZqTds1Vvbnmb6HqLbTttFL1Vpq/vaq31/wdVb2j5u+s6p01f1dV76r5X1L1l8DvOnAtU/mlr5lyhcBH+ZoBvubK1wx8LWhz4GupfM3BR/u3BfhaK19L8LVRvlbgc5WvNWkpLKx8hU5QuZJbLLebFfR21f2dtsHzrpXbzTbE2y543lK53fYGeGV+dFDbagd501H52oOvk/J1AF9n5esIvi7K1wl8XZWvM/i6KV8X8HVXvq7gU4c5pxv4nlG+7uDrqXw9wPes8j0DvueUryf4nle+Z8GXo3zPge8F5XsefL2ULwd8LyrfC+B7Sfl6gY+Oqy+Cj84D6fgjjwktQ7CO8tPxKLoOHYvB9yodh8HXm47B4OtDx1/w9YXY5OsHxxDy9Vc+Oh7JZSNUudAJKv8jJXK7I4Pertiy3O7o4Lcbvfc1xqnTtRDijAStxqpygM/X5GHskDKKQ/5MKE+FttSO9KDvFGKX3x2jVHlsnPVGaOtlQZtRHv0vdILt/2iNZ7TG3Bx8ZnI2P8/mbL2nhHN2MbTVc4/Ob1IxZ2cAh4GcHWxztt5TwjlbAm313KNz3FTM2WXAYSBnh5vJ2UiuzdnY9TDH8c49+p2Tijm7HjiCz9nBNmfrPyWcswehrZ579Fs3FXO2BjiCz9mhw+25Qb2nhHP2PLTVc4+uu6Rizh4BDgM5W2KPs/WeEs7Zu9BWzz26BpiKOXsJOILP2eGGcjbf5qwTu7fpON65R9ejUzFnHwBH8Dm71l6frf+UcM5+EtrquUf3RlIxZ99TZXmf4evqPkNP8H1D+Z4F3uBzuyTfUG5HbG7HnvlwHO8cpft0qZjbn1VlmcffhOcMyPct5XsBfN9Wvl7g+47yvQj9MvAZGG4/A/WeEv4MfBfa6rlM94xT8TPwNeAwkLNrbM7We0o4Z38JbfXco+cXUjFnvwccBnK2xOZsvaeEc/b/QVs993qrcirm7G9UWZ4v/ECdL/QF3w+Vrx/4fqR8/cH3Y+UbAL6fKN9A8P1U+QaB72fKlwu+nytfHvh+oXwR8P1S+fLB9yvlKwDfr5VvMPh+o3xDwPdb5RsKvt8p3zDw/V75hiufvN9Fz159RfnkviU9Cp3g9m302Srn6Smk1QuhPMAsT24W8GCsgcHHyk+07wOBZ5CBvrsQoz48g4AnN3ie6HNFecFv96l9jJ9nitUf+hUx0K8QxKJtU53iZYEPjy8RD8b84BkjIYhF26Z6PjCSLxd4iO19J9jcfFXruzzm54Q+GLfQCXZfZTlP65DlsQ9Mxc7WYmc3Yuz2Wuz2jRjbam4156Q5p3Mf/P7KAEYD5yhRxgEJMA4ERlqvGTAaOG/Ja+h5SxaslwmMJs5lXIhbH8ZcYKT1mgOjgfOiKGOuU3/GPGCk9VoAo4lzJzxPqw+j1/lUS2A0cO6Uh+dp9WH0Op9qBfMCQ4z5CTAWACOth/+FGWyIsSABxsHASOv94b+CTt1v48KAGQcnwDgEGPH3u0nGeN/tQyD20OBjR1yIUR99hprliXuugbGHGdJiqFN/LYaZ5Yl77oOxhxvSYphTfy2GA0/g16PV53h4AjzEkAXrdQBGA9e2o4wjEmAcCYy0XkdgHGWIcWQCjKOAkdbrBIwGruVHGUclwIjXvGm9zsA4xhDj6AQYxwAjrdcFGE1cl3chbn0YxwIjrdcVGAsNMY5NgLEQGGm9bsA4zhBjYQKM44CR/N2BcbwhxnEJMI4HRlqvBzBOMMQ4PgHGCcBI6z0DjBMNMU5IgHEiMNJ6PYFxkiHGiQkwTgJGWg+fVZtsiHFSAoyTgZHWew4YpxhinJwA4xRgpPWeB8aphhinJMA4FRhpvZwkYHwhCRh7JQHji0nA+FISML6cBIyvAOM0Q4xTE2CcBoxTPRinG2KclgDjdGCk9V4FxhnBM0Z/S09PgBHHVpgZPE9UsxkJ8Mw0yxO93z/DI9as4GNFEu37LOCZHTxPdF/MSoCHGLJgvZlmGSMNZZQ8c4LniWo2OwGeOaDZbA/NDDBGGsooeeYGzxPVbE4CPHNBszkemhlgjDSUUfLMC54nqtncBHjmgWZzPTQzwBhpKKPkmR88T1SzeQnwzAfN5nloZoAx0lBGybMgeJ6oZvMT4FkAms330MwAY6ShjJJnYfA8Uc0WJMCzEDRb4KGZAcZIQxklz6LgeaKaLUyAZxFottBDMwOMkYYySp7FhjRblADPYtBskYdmnBiRJ8hnQbHvGGsJg74TAzK2TgLGNknAiM9JmDh+xXtOYpFZfSIN1cfU/or3nATGXmpIiyVO/bVYapYn7nMSGHuZIS2WOvXXAscgfM2AFi7EqA8PMWTBeh2SgLFjEjB2SgLGzknA2CUJGLsmAWO3JGDsngSMPZKA8ZkkYOyZBIzPJgHjc0nA+HwSMC42zBjv98trKR7b77dKqsf2+12S6rFtnts8T4fYNs9tnqdDbJvnNs/TIbbNc5vn6RDb5rnN83SIbfPc5nk6xLZ5bvOcU+wiA7FdiEFTvGv8xJAF6y22jCnNiDw5wfHkYt8x1nIGfV/uwRMy1HeMtYJB34kh2RiLkoBxcRIwWh1jzyA2hFHyrDTEsyIBnpXAs8oQz8oEeFYBz+rgeaI5tSoBntVqngXrLU4CxqIkYLQ6Wh05MVod00dHy2gZLaNlbArGZDiGW8akyMdIQxklT3HwPFHNVifAUwya0XozzTJGGsooedYEzxPVrDgBnjWgWbGHZgYYIw1llDxrg+eJarYmAZ61oNkaD80MMEYayih5SoLniWq2NgGeEtBsrYdmBhgjDWWUPKXB80Q1K0mApxQ0K/HQzABjpKGMkmdd8DxRzUoT4FkHmpV6aGaAMdJQRsmzPnieqGbrEuBZD5qt89DMAGOkoYySZ0PwPFHN1ifAswE0W++hmQHGSEMZJU9Z8DxRzTYkwFMGmm3w0Iwr4+IkYCxKAkbDOkYayih5NhriKUuAZyPwbDLEszEBnk3Aszl4nmhObUqAhxiyYL3FScBYlASMVkerIydGq2P66GgZLaNlTIxxeRIw2n1tGbkyGvh9Ffc/NJtSPLbff2hSPbbff2hSPbbNc5vn6RDb5rnN83SIbfPc5nk6xLZ5bvM8HWLbPLd5ng6xbZ7bPE+H2DbPbZ6nQ2yb5zbP0yG2zXOb5+kQ2+a5zfN0iG3z3OZ5OsS2eW7zPB1i2zy3eZ4OsW2e2zxPh9g2z22ep0Nsm+c2z9Mhts1zm+fpENvmuc3zdIht89zmeTrEtnlu8zwdYts8t3meDrFtnts8T4fYNs9tnnOKXR587Oj4mJucp6eQVi+EcjnwmBjzxlA/c2WfKrQ+bdL6lAVtcNycCgP9DEFc2jbVK2A/JBuz5KH3ORKrC+1eY8JIvs3AUxk8T8TVeOQU7/NVaVgfQ/2Mfr62ON66V4Lu1AZzdYuBfoYgLm2b6ltgPyQbs+Sh95MSqwvtVjBhJF8F8GwNnifiajxyivf52mpYH0P9jH6+tjneum8F3akN5uo2A/0MQVzaNtW3wX5INmbJQ+/bJVYX2q1kwki+LcBTFTxPgavxyCne56vKsD6G+hn9fFU73rpXge7UBnO12kA/QxCXtk31atgPltkyezFLHnqvHbG60G4VE0bybQOemsB5CnJdjUdO8Y5jNYb1MdPP2HFsu+Otew3oTm0wV7cb6GcI4tK2qb4d9kMizEVJyGx1tjr7MVudrc5+zFZnq7Mfs9XZ6uzHbHW2OvsxW52tzn7MVmersx+z1dnq7MdsdbY6+zFbna3OfsxWZ6uzH7PV2ersx2x1tjr7MVudrc5+zFZnq7Mfs9XZ6uzHbHW2OvsxW52tzn7MVmersx+z1dnq7MdsdW4Ys+RZrcrE6kK71UwYyVcNPDuC5ylwNR45hbR6IZR3GNbHUD+jz73vdLx13wG6Uxv8fO000M8QxKVtU30n7IdEmIuSkNnq3DBmyVOsysTqQrtiJozk2w48u4LnKXA1HjnFO47tMqyPoX5Gj2O7HW/dd4Hu1AY/X7sN9DMEcWnbVN8N+8EyW2YvZsmzRpWJ1YV2a5gwkm8n8OwJnCeS62o8cop3HNtjWB8z/Ywdx/Y63rrvAd2pDebqXgP9DEFc2jbV98J+SIS5KAmZrc5WZz9mq7PV2Y/Z6mx19mO2Olud/ZitzlZnP2ars9XZj9nqbHX2Y7Y6W539mK3OVmc/Zqtz+ugsedaqMrG60G4tE0by7QaefYHz5Oe6Go+c4t132GdYHzP9jN132O94674PdKc2+Pnab6CfIYhL26b6ftgPqc5clITMNjcah9nmhmX2Y7a5YZn9mG1uWGY/ZpsbltmP2eaGZfZjtrlhmf2YbW5YZj9mmxuW2Y/Z5oZl9mO2uWGZ/ZhtblhmP2abG5bZj9nmhmX2Y7a5YZn9mDnkhuQpUWVidaFdCRNG8u0FngPB8xS4Go+c4j23c8CwPob6GX1u56DjrfsB0J3a4OfroIF+hiAubZvqB2E/HLTMltmDWfKUqjKxutCulAkj+fYDz6HgeQpcjUdO8Y5jhwzrY6if0ePYYcdb90OgO7XBXD1soJ8hiEvbpvph2A+W2TJ7MUuedapMrC60W8eEkXwHgedI8DwFrsYjp3jHsSOG9THUz+hx7KjjrfsR0J3aYK4eNdDPEMSlbVP9KOwHy2yZvZglz3pVJlYX2q1nwki+w8BzLHieiKvxyCneceyYYX0M9TN6HDvueOt+DHSnNpirxw30MwRxadtUPw77IdmYJc8GVSZWF9ptYMJIvqPAcyJ4noir8cgp3ufrhGF9DPUz+vk66XjrfgJ0pzaYqycN9DMEcWnbVD8J+yHZmCVPmSoTqwvtypgwku848JwKnifiajxyivf5OmVYH0P9jH6+Tjveup8C3akN5uppA/0MQVzaNtVPw35INmbJs1GVidWFdhuZMJLvJPAYyLsoT5bGQ/VTKR47W4udnSax22ux26dJbJvnNs/TIbbNc5vn6RDb5rnN83SIbfPc5nk6xLZ5bvM8HWKna65Zza3mVnOrudXcav6nxraa+2t+JvjYEbxHRlO8+7BngMfEfTRD/Yzehz2r9emU1qcsaNMM+nnWQD9DEJe2TfWzsB+SjRn3X05wsYfK7Z4Lvk+RtmIbrUHXc5q+2K/zhjT1O+adZxBb1oeocljNXVg+BBgvGGI8rzFS/QIwIq9pzfy+Jxpjf/2x2LL/Q1W5rZrj/hoKjBz2V3YjaOb33doY++uPxZZaDFPldmqO+2sYMHLYX+2B52LwPAWuxiOneOcjFw3rY6if0fORS4637hdBd2qDz1hdMtDPEMSlbVP9EuwHy2yZvZglz3RVJlYX2k1nwki+C8BzOXieAlfjkVO849hlw/oY6mf0OHbF8db9MuhObTBXrxjoZwji0rapfgX2QyLMRUnIbHVuGLPkmaHKxOpCuxlMGMl3CXiuBs9T4Go8cop3HLtqWB9D/Ywex6453rpfBd2pDX6+rhnoZwji0rapfg32QyLMRUnIbHVuGLPkmaXKxOpCu1lMGMl3BXiuB84TyXU1HjnFO45dN6yPmX7GjmM3HG/dr4Pu1AY/XzcM9DMEcWnbVL8B+8EyW2bLbJkts2W2zJbZMltmy2yZLbNltsyW2TJbZstsmS0zb2bJM1uVidWFdrOZMJLvGvDcDJwndt8BeeQU777DTcP6mOln7L7DLcdb95ugO7XBXL1loJ8hiEvbpvot2A+W2TJbZstsmS2zZbbMltkyW2bLbJkts2W2zJbZMltmy2yZeTNLnjmqTKwutJvDhJF8N4DndvA8Ba7GI6d49x1uG9bHUD+j9x3uON663wbdqQ3m6h0D/QxBXNo21e/AfrDMltmLWfLMVWVidaHdXCaM5LsFPHcD54ndP0UeOcU7jt01rI+ZfsaOY/ccb93vgu7UBnP1noF+hiAubZvq92A/JMJclITMVmersx+z1dnq7MdsdbY6+zFbna3OfsxWZ6uzH7PV2ersx2x1tjr7MVudrc5+zFZnq7Mfs9U5fXSWPPNUmVhdaDePCSP57gDP/cB58nNdjUdO8e473Desj5l+xu47PHC8db8PulMb/Hw9MNDPEMSlbVP9AeyHVGcuSkJmmxuNw2xzwzL7MdvcsMx+zDY3LLMfs80Ny+zHbHPDMvsx29ywzH7MNjcssx+zzQ3L7Mdsc8My+zHb3LDMfsw2NyyzH7PNDcvsx2xzwzL7MdvcsMx+zBxyQ/LMV2VidaHdfCaM5LsHPLXB8xS4Go+c4j23U2tYH0P9jD6389Dx1r0WdKc2+Pl6aKCfIYhL26Y6xbPMltmPWfIsUGVidaHdAiaM5HsAPI+C54m4Go+c4h3HHhnWx1A/o8exx4637o9Ad2qDufrYQD9DEJe2TfXHsB+SjVnyLFTlWjV3od1CJozkewg8BvIuypOl8VD9EYPYsr5IlcNqjvtrETBy2F9ZjaBZtsaTrWnWlLFl/5eocls1x/21BBg57K/sRtCsvcbTXtOsKWNLLZaqcjs1x/21FBg57K/2jaBZUx4Pm/Kz3ZR5ajW3mnPRPMOpO/b0VPMc5dePTe9r7R9Be9T3bCP0y9H65WhMyPMaM55xzHhGMuMZzIxnEDOedcx41jLjWcCMZzUznrnMeGYx45nKjGcFM57xzHhGMeNZxoxnCDOeXGY8G5jx9GHGM40Zz2NmPCuZ8UxgxjOaGc9QZjx5zHjKmPGsZ8aziBlPCTOehcx4ipnxzGPGM5sZz3RmPBOZ8YxhxjOMGU+EGc9GZjz9mfEsYcbTlxnPJGY8Y5nxDGfGk8+MZwAznqXMeEqZ8axhxtOPGU8XZjxzmPHMYMYznxlPb2Y8k5nxrGLGU8iMZwQzngJmPAOZ8UxhxhNiwOM6H/xvCT4L+xh8T1T5LPgyPLbXTJWpfUthP+xWt/xt5c+AdT6kys3A944qZ4LvXVVuDr73VLkF+D4MsXX+tz36+SHwva7K74DvDVV+F3xvqvJ74HtLlT/swYL7m9YpdILd3xirEOoULwwcH2bCM4UZz0BmPAXMeEYw4ylkxrOKGc9kZjy9mfHMZ8YzgxnPHGY8XZjx9GPGs4YZTykznqXMeAYw48lnxjOcGc9YZjyTmPH0ZcazhBlPf2Y8G5nxRJjxDGPGM4YZz0RmPNOZ8cxmxjOPGU8xM56FzHhKmPEsYsaznhlPGTOePGY8Q5nxjGbGM4EZz0pmPI+Z8UxjxtOHGc8GZjy5zHiGMONZxoxnFDOe8cx4VjDjmcqMZxYznrnMeFYz41nAjGctM551zHgGMeMZzIxnJDOeccx4XmPGc9aDx9Q4kG85dVMh1HGMYSrLZ94eqTIxZsLyH2fF5tka8/vBMedibORB3vdg+evactnnd1U5Q9XPauu1Al9hgOwhjU1u9w1NT9nmHY3vXY0vE9u0rdveb7Lq1qP+0vbfV/2qDb5f+fh8ogP9wKkQyrVqLnkeBs9j9L0H+js63tD6lAVtHkE/Tb3/olbjoXq894rEY349CZkfM2DGnMsJLnau3O794PuULw8brUFX/R0N1C/52e6t+eSxpnnbun7jMaYwoH5j3Df+SNxCJ9h97fedSPG4xM4JLHZegaH8jeDz7MQtv58olygmjen6SGtb6Jj7npBseN4gp3jfW8SG7/mhZ/ol493gGaPfOXfUtlqo7d7VeGTs28AfUOw8jB1SRnHInwnlHPXZdKBdpvPBdzLJ6ZaaZ0BbXH4P4t7X1glB2VH9pf1I2mRBm3vQ9n4crlawTqETrI53Nd67Wp/ksa0jHNueGOJ4qHFQHfO41kBs/P8LTfU5R8yC9XqbZYx+5/TR4sv90qetybh5BVIHOt7RZ1znyIQ2b3WrYxug2PC+FOr8BPpBzy0/hm3S8jy1nWxtW/TbGP+rhONYmzguhyAWbZvqFC8M7HgcfGSI54nGo8cOQ3kFaFar+ZryHDUM+tUCT60hHr9jTS3wUHklaHZf80nGe4YY/d4feA8YSb/7wGPgnDzP63ePHjsM5VWg2V3NJxnvGGL0+y67A4yk313gMXB+FOW5p/HoscNQXg2a3dZ8Jr//b2uMVL8FjKTfbeC5bYjnjsajxw5DuRg0u6n5JOMNQ4w3NUaq3wBG0u8m8Nw0xKOfc+qxw1BeA5pd13yS8ZohxusaI9WvASPpdx14rhviuaHx6LHDUF4Lml3VfJLxiiHGqxoj1a8AI+l3FXiuGuK5pvHoscNQLgHNLms+yXjJEONljZHql4CR9LsMPJcN8VzRePTYYSiXgmYXNZ9kvGCI8aLGSPULwEj6XQSei4Z4Lmk8euwwlNeBZuc1n2Q8Z4jxvMZI9XPASPqdB57zhnguaDx67DCU14NmZzWfZDxjiPGsxkj1M8BI+uE7kgzc84rynNN49Nh4z3MDaHZa80nGU4YYT2uMVD8FjKTfaeA5bYjnjMajxw5DuQw0O6n5JOMJQ4wnNUaqnwBG0u8k8Jw0xHNK49Fjh6G8ETQ7rvkk4zFDjMc1RqofA0bS7zjwHDfEc0Lj0WOHoTwENDuq+STjEUOMRzVGqh8BRtLvKPAcNcRzTOPRY4ehPBQ0O6z5JOMhQ4yHNUaqHwJG0u8w8Bw2xHNE49Fjh6E8DDQ7qPkk4wFDjAc1RqofAEbS7yDwHDTEc0jj0WOHoTwdNNuv+STjPkOM+zVGqu8DRtJvP/DsN8RzQOPRY4ehPAM026v5JOMeQ4x7NUaq7wFG0m8v8Ow1xLNP49Fjh6E8CzTbrfkk4y5DjLs1RqrvAkbSbzfw7DbEs0fj0WOHoTwbNNup+STjDkOMOzVGqu8ARtJvJ/DsNMSzS+PRY4ehPAc02675JGONIcbtGiPVa4CR9NsOPNsN8ezQePTYYSjPBc2qNZ9krDLEWK0xUr0KGEm/auCpNsRTo/HoscNQngeabdN8knGrIcZtGiPVtwIj6bcNeLYZ4qnSePTYYSjPB822aD7JWGmIcYvGSPVKYCT9tgDPFkM8WzUePXYYygtAswrNJxnLDTFWaIxULwdG0q8CeCoM8VRqPHrsMJQXgmabNZ9k3GSIcbPGSPVNwEj6bQaezYZ4yjUePXYYyotAs+WaTzIWGWJcrjFSvQgYSb/lwLPcEM8mjUePHYbyEtBsseaTjDMNMS7WGKk+ExhJv8XAs9gQT5HGo8cOQ3kpaPa65jP5fOzrGqP+bGkY9MNn2V83xDNT42nM2H7PJKV67Ida7IdpEtvv2aBUj+33fE+qx/Z7RifVY/s9Z5Pqsf2elUn12H7Pu6R6bL9nVlI9tt9zJ6ke2+/ZkVSP7ff8R6rH9nuGI9Vj+z2Hkeqx/Z6l4BY7wP/p5mVB3AyIZer3v6P1kyaKhzz7mfHsY8YzkhnPaWY8p5jxDGLGc50ZzzVmPOuY8bzEjOcRM56HzHhWM+OZy4ynGzOeqcx4WjPjWcGMZzwznmXMeIYw49mg5lx4nmfG05EZTx9mPFuY8VQy48lkxrOXGc8eZjyvMuMZzYznJDOeE8x48pjxXGXGc4UZz3pmPIuY8bzCjKeWGc8DZjzFzHjmMePpwYxnOjMelxnPRGY8w5jxbGTG058ZzwvMeDoz46lgxlPOjKcFM57dzHh2MeMZy4znODOeY8x48pnxXGbGc4kZT2P8HykRnvvMeO4x41nDjGc+M56ezHj6MeOZwYynLTOebGY8k5nxjGDGM5AZz4vMeLoy49nMjGcTM54pzHhaMePZyYxnBzOe15jxjGPGc5QZzxFmPIOZ8VxkxnOBGc9dZjx3mPGsZcazgBnPc8x4ZjHj6cCMpxkznlHMeHKZ8bzMjKc7M57lzHiKmPFMY8bThhnPdmY8Ncx4VjLjmcCM5zAznkPMeIYy4znPjOccM54yZjy3mfHcYsZTwoxnITOeHGY8s5nxdGLG05wZzxhmPBFmPEuY8TzDjKcvM57FzHhmMuMJM+PJYsZTzYynihnPJGY8B5nxHGDGM5wZz1lmPGeY8QxgxnOTGc8NZjylzHh6MeN5zIznCTOeVcx45jDjacmMpzcznkJmPAXMeJ5lxtOOGU97ZjzbmPFsZcYTYsDjAocDPlr+OvgytHXl8bxHj7rlbyl/Bqzztio389j2W+B7U5Xf9lgXdXoL+lKoyrl/2hTVCWMVQp3ihYHjbSY8W5nxbGPG054ZTztmPM8y4ylgxlPIjKc3M56WzHjmMONZxYznCTOex8x4ejHjKWXGc4MZz01mPAOY8ZxhxnOWGc9wZjwHmPEcZMYziRlPFTOeamY8Wcx4wsx4ZjLjWcyMpy8znmeY8SxhxhNhxjOGGU9zZjydmPHMZsaTw4xnITOeEmY8t5jx3GbGU8aM5xwznvPMeIYy4znEjOcwM54JzHhWMuOpYcaznRlPG2Y805jxFDHjWc6MpzsznpeZ8eQy4xnFjKcZM54OzHhmMeN5jhnPAmY8a5nx3GHGc5cZzwVmPBeZ8QxmxnOEGc9RZjzjmPG8xoxnBzOencx4WjHjmcKMZxMzns3MeLoy43mRGc9AZjwjmPFMZsaTzYynLTOeGcx4+jHj6cmMZz4znjXMeO4x47nPjGcpM55LzHguM+PJZ8ZzjBnPcWY8Y5nx7GLGs5sZTwtmPOXMeCqY8XRmxvMCM57+zHg2MuMZxoxnIjMelxnPdGY8PZjxzGPGU8yM5wEznlpmPK8w41nEjGc9M54rzHiuMuPJY8ZzghnPSWY8o5nxvMqMZw8znr3MeDKZ8VQy49nCjKcPM56OzHieZ8azgRnPEGY8y5jxjGfGs4IZT2tmPFOZ8XRjxjOXGc9qZjwPmfE8YsbzEjOedcx4rjHjuc6MZxAznlPMeE4z4xnJjGcfM579zHgyGpGHxgunbb+p8TR17A8FHztXbvcdQ316V22rhdou8VO8TGjTT/3Qls/j4rrEReO70zbCoM274CPd+oNupsbBP6YxUv2NFI99RIt9JE1iH9JiH0qT2Ae02AfSJPY+Lfa+NIm9R4u9J01i79Ji70qT2Du02DvSJHaNFrsmTWJXabGr0iT2Vi321jSJXanFrkyT2OVa7PI0ib1Ji70pTWIXabGL0iT2TC32TEaxsSzHKqbf7PQ7PROWb4VrAK2gTWHAzE805icaU6rGfqjFfpgmsR9osR+kSex7Wux7aRL7jhb7TprEvqXFvpUmsW9osW+kSexrWuxraRL7ihb7SprEvqTFvpQmsS9osS+kSexzWuxzaRL7jBb7TJrEPqXFPpUmsU9osU+kSWy/e7ipHtvvHm6qxz6kxT6UJrH97uGmemy/e7ipHtvvHm6qx/a7h5vqsf3u4aZ6bL97uKke2+8ebqrH9ruHm+qx/e7hpnpsv3u4qR7b7x5uqsf2u4eb6rH97uGmemzO94Hle87p3QqP1dyF5a8B41uGGN/UGKn+FjCS7wnwPDHE81DjecgottSC/sv8SM1dWL4CGB8bYvTLqcfASL6HwLPCEI/fve8VDGJLLehdlrVq7sLylcD40BDjCo2R6g+BkXwPgGelIR6/e/YrGcSWWqxSZRoz24Xlq4DxgSHGlRoj1R8AI/nuAc89Qzx+zxpwiC21WK3K9E4wF5avBsb7hhj9cuo+MJLvDvDcMcTj94wEh9hSi2JVpneMu7C8GBjvGmL0y6m7wEi+W8BzyxCP37MdHGJLLdao8k01d2H5GmC8bYjRL6duAyP5bgDPDUM8fs+kcIgttaB3R9IYBi4sXwuMNw0x+uXUTWAk3zXguWaIx+9ZGg6xpRYlqkxjWLqwvAQYrxti9Mup68BIvivAc8UQj98zQBxiSy1KVZne0eHC8lJgvGqI0S+nrgIj+S4BzyVDPH7PLnGILbVYp8r0TlQXlq8DxsuGGP1y6jIwku8C8FwwxOP3zBWH2FKL9ap8Xs1dWL4eGC8aYvTLqYvASL5zwHPOEI/fs2IcYkstNqjyWTV3YfkGYDxviNEvp84DI/nOAM8ZQzx+z7hxiC21KFNlGjPJheVlwHjWEKNfTp0FRvKdAp4yQzwnNJ4THlo0VWypBb275KSau7B8IzCeMsRYpjFS/RQwku8E8BDb+8Hx5JvaF67z9L6QU0irF0IZc+OkAR5D/czFPAlwv0Tz5LSmlVcuUxv8XJ82oF+8vD0NPDRlAI+pz7qj8Tge+tC0nxnPPmY8I5nxDGLG8xIznrnMeLox45nKjKc1M57xzHiWMeMZwozneWY8HZnx9FFzLjxbmPFUMuPJZMazlxnPHmY8rzLjGc2MJ48ZzyJmPK8w45nHjKcHM57pzHhcZjwTmfEMY8bTnxnPC8x4OjPjqWDGU86MpwUznt3MeHYx4xnLjOc4M55jzHjymfEsZcYznxlPT2Y8/ZjxzGDG05YZTzYznsnMeEYw4xnIjOdFZjxdmfFsZsaziRnPFGY8rZjx7GTGs4MZzzhmPEeZ8RxhxjOYGc8CZjzPMeOZxYynAzOeZsx4RjHjyWXG8zIznu7MeJYz4ylixjONGU8bZjzbmfHUMOOZwIznMDOeQ8x4hjLjWciMJ4cZz2xmPJ2Y8TRnxjOGGU+EGc8SZjzPMOPpy4xnMTOemcx4wsx4spjxVDPjqWLGM4kZz0FmPAeY8QxnxjOAGU8vZjxzmPG0ZMbTmxlPITOeAmY8zzLjaceMpz0znm3MeLYy4wkx4HGdD44h4jV2i/TRmBQnwEdj4JwEX4ZHDLq3huP50P8VaRvy++HlHh/cNupkahwOjFUIdYoXBo4zTHi2MuPZxoynPTOedsx4nmXGU8CMp5AZT29mPC2Z8cxhxtOLGc8AZjzDmfEcYMZzkBnPJGY8Vcx4qpnxZDHjCTPjmcmMZzEznr7MeJ5hxrOEGU+EGc8YZjzNmfF0YsYzmxlPDjOehcx4hjLjOcSM5zAzngnMeGqY8WxnxtOGGc80ZjxFzHiWM+PpzoznZWY8ucx4RjHjacaMpwMznlnMeJ5jxrOAGc9gZjxHmPEcZcYzjhnPDmY8O5nxtGLGM4UZzyZmPJuZ8XRlxvMiM56BzHhGMOOZzIwnmxlPW2Y8M5jx9GPG05MZz3xmPEuZ8eQz4znGjOc4M56xzHh2MePZzYynBTOecmY8Fcx4OjPjeYEZT39mPMOY8UxkxuMy45nOjKcHM555zHheYcaziBlPHjOe0cx4XmXGs4cZz15mPJnMeCqZ8WxhxtOHGU9HZjzPM+MZwoxnGTOe8cx4WjPjmcqMpxsznrnMeF5ixjOIGc9IZjz7mPHsZ8aTofGEYXl/8FF5APioPBB8VB4EPirngo/KeeCjcgR8VM4HH5ULwEflweCj8nDwUXkE+Kg8EnxUHgU+Ko8GH5XHgI/KY8FH5ULwUXkc+Kg8HnxUngA+Kk8EH5UngY/Kk8FH5Sngo/JU8FF5GvioTOcZraBc6ASbv3TviLZ9jFFs+b9SOveje0ouLB8CjKbGtVmmMVIdx9khH76XcYghniMazxEPLZoqttSC/itEzxi6sBzHxTaVU0M0Rqp75RS+52aoIZ5DGs8hDy2aKrbUgu4FHFZzF5bje6lN5dRQjZHqXjl1CHiGGeI5oPEc8NCiqWJLLaar8kE1d2H5dGA0lVPDNEaqe+UUjis63RDPPo1nn4cWTRVbajFDlemc1IXlM4DRVE5N1xip7pVT+4BnhiGePRrPHg8tmiq21IL+60HXmF1Yju+1MpVTMzRGqnvl1B7gmWWIZ5fGs8tDi6aKLbWg/5LTMywuLMf3OpjKqVkaI9W9cgrfsz7bEM8OjWeHhxZNFVtqQWNn0X8aXFiO4wibyqnZGiPVvXIK31s5xxBPjcZT46FFU8WWWtC1QfrPtAvL5wKjqZyaozFS3Sun8L1Ncw3xVGk8VR5aNFVsqQU9C0FjRLmwfB4wmsqpuRoj1b1yCt8TMM8Qz1aNZ6uHFk0VW2pBz1rTmKYuLJ8PjKZyap7GSHWvnMJxjecb4qnUeCo9tGiq2FIL+q8r3dN2YTm+F9ZUTs3XGKnulVOVwLPAEE+5xlPuoUVTxZZa0Fg69MysC8vxvWimcmqBxkh1r5wqB56Fhng2aTybPLRoqthSC3pWbbOau7B8ETCWG2JcqDFSvRwYybcJeDYZ4inSeIoYxZZa0Nh0NCaKC8vxPWSbDTH65dRmYCQfvhd2iSGemRrPTA8tmiq21IL+S0VjQLqwfCkwFhliXKIxUr0IGMk3E3iWGuLxu4a3tBFi+12PaozYftdWGiO233WCxojtd429MWL7/X5rjNh+v0UaI7bfdYbGiO13Tt8Ysf3ubzdGbL97tY0R+5AW+1Ajxm7Kz7f9Lkmv75KmPK6l63eJPZ7zPJ4vDj52xIUYNIW0eiGU8T3KMw1oYaifufib8P0At+v1G17//ZcFbfA3qqnff4s1HqpTvGRkxrwIBRc714UY9Lyw9NG1lv7go2scA8BH10AGgo+uoQ0CH13PygUfXe/KAx9dQ50KPrp2eRB8dG3zAPjo+jQ+B0P3GPaBj+4T4fMXdK9vD/jofi3e96d77rvAR89N7AQfPQu4A3z0PCfe5zyryjXg26DKeH/tnCpXge+8KuN9nfWqvBV8F1QZ7ydcVOVK8K1T5cngu6TKU8B3WZWXgq9UlWeC74oqLwHfVVWOgK9ElfPBd02VC8B3XZXxOd21qnwMfDdUGZ8PvanKR8C3RpUPg++WKh8C321VHgy+YlUeDr47qjwCfHdVeST4VqvyKPDdU+XR4LuvymPAt0qVx4JvpSoXgu+BKo8DX60qjwffClWeAL6HqjwRfI9UeRL4nqjyNPA9VmW89pehykXgo/GA8Zou/cd1E/joPRd4rZ7GblkEPnp/20LwtVLlcvDR/8bwXk0bVV4APleV54MvrMrzwEfvJZoLPhobbQ74aPy22eCjdyjOAh+953EG+Gis4ungo/9zLgMfvYMD31VK46acBV8XVd4APhov8Rz4uqnyefDROODrwUdjNVwAH73f5iL4aAyydeCj9zZeAh+NPXwZfPR/0VLw5ajyFfC9oMpXwddLlUvAR+MxXgMf/SfsOvhonPG14KOxF26Aj/5PfxN8vVV5Dfjof8G3wNdXlW+Dr58qF4OPvovvgI++i++Cj76LV4OPvovvgY++i++Dj76LV4GPjtUrwUfH6gfgo2N1LfjomLkCfPTc9UPw0bO9j8A3TJWfgI+Ot3SckZ9neT70hqrLY0OhU6fz62reClgDPH+KnrvVqm0111goXia0eU99qLJV21of7kce637UZ11HrUua0DbCwFIL2yPf57rVcX+s2wfXId1Ru0InKO3yCmQf7vv0H7WjNp/S+k9+4nrTo/+1qow5Tp+3N8DXT9NJavLlbnX9rzXU/wc+/a+F/lObL2r9J3+8/uu5GIbyk3pq8sBHk+BzIvZ7nBhoivd7nBjM7KPY73ED/cz1yl99X2VBm77Qz/sG+umVT1S/D/shEeZ+DJhx/+UEFzt6PeVe8H2KyHPH1qDrPU3f+6DzE4++3jWks77f6RhD8WQbOi9pqbWhdTOhzffhWOZ6tJXHmj5t6/rVKvB+5Q3D3xIO9MPR+kpTK5i3DJwnN0/+DqHz4fWl1bNrNm8uW1dWum1Wafma0m1VG8q2LCmrriitqgoBLHWgm9aBkPN0Z2h5Bviw3MzDR50NXvxYUrWEOIVQb2Vj/+GHaoCxI/ijmKZ4Cd8aeNzgefLxB3l9eFzgaRM8T56hfka/LOjiQdAX37M0rVprWmVBmzDol2VAvxDEpW0jh5wsc+MwZzl1n3Vkxc8QB0bytQEeE59BvMBI25cnGa2618U1cEzJD4H+9CMvU+tzJrT5efc6trAq44BXraAPXvsyHHwf4u7LMMzbABvxmPoObaPxYP7Q3PSxPLjt5g3DY0wLH40zoU03lRt0MUA/PrXQ9gW+VCkLNDL12ffbPxjbQK5GP29t66EjtcnRdGyrcbf20JH60NZsX6LnI9mGNGqnaUT82aARtXlV04j8ukZ4LCBt2oFGBvoSkdttb0ijDppGxN8eNKI2AzWNyK9rlA0akTbUNgPatYN1pZ8+P7T8feWndvjdZer8ON5vFzz+mvrtgscUOdX3t0vw+ZFXkOhvl/bA0yFwntixwsDnIPp9Rzcbg/7t0knTqrWmVRa06Qj6dTKgXwji0rapTvEss2W2zJbZMltmy2yZLbNltsyW2TL/6cySR7/GgQ/EtmHCSL4OwNgcyo6qX4P7CgauF0cfHqNrSXR9ijjwOie1eQ/uK9yC+wrZmr54X8HwNZ249xXwmmIY2IjH1PWtsMYT9tBHv9eAmmWBj/rQFnyUP+3AR7mUDb6O0H/yZXiwNIMyzen+En6OKDfag4/uEWAu0/W8jrCNZM4TAzwFXjzNNR48nrTU2tC6mdDmE3D92Mw1wtg9Jtqv+r2RDsBEbT6jXdMmP3F53WOi/uB3ioG+FOB3nH78w75Qmy9o+gb/HZJXYOraruwr/ZGjufP0cQn7Sm2+BMf6L3ev20e0n7JhW9/2WE5TvOvZpJ/sc9fg+xy9PkzPrNH+7eoRuzuwBhQ7D2PTc3QUh/yZUP5W97q21I70IK2JXe43+gMOsuvrudp6WdCmi0f/C51g+99V4+mqMcvc+Srk2bfhfKejIaYuPho1B42oDd5vMfVMhH6+qJ9/4Tma/h2A9xCpzQ/gGIXnw/jdrn8Py/51NtQ/ikXbpjrFywJfR2DU+4jnw8n8LEtj8WRqPPh8R0utDZ5LUJv/rX3XtQ2cO3Yuof/+IJa2wERt/q92LqHnlte5BPWH2sq+tAu8L7F7/e21vpC+7aAv1Oa/NH1NPH9gqK95+GwCnUu08egrtflvOMaHetTtI9onrWFb7TyW01Tfe+MGftvn4vkT7d9OHrG7AGtAsZ86d6NzCYpDfjx3y+5R11b/viOtiR1f7Irs+nrZ2nr4PdnRo/+FTrD9169FddKYZe5k9qgrUx6ZOXbFmDr6aJQJGnWEMs3p+wl/q+MzbTQ3dX1Cf86P6vh8nf58Wn2efaXrCAE+4xF9JqWFAR2wPzTFO74QQyun7twkSJ42oGtVdeW24vWl80uLS/CvOJkapt/fdKicAT4s+/1NBy/n4K6myzl46SFDkwUvI1F7eagxJRfqQdvO1DhN/ccKT09pipc6+NccE6ksU4dO81TqLNlWVl2K+dFc42xI7shlzeK089tWa+eD+gSaCAT1shY8Qy3LVAJI8eXOoGt69Jmj80R5rJPHZHkOI7/T5fmLPH7L7xr53Sq/a+RvWPmbXR725FeMHKRCDkoh/3QnB52Qg0zkOLFBJHo5sUEiXgKurwCrHARCDvrQ24n9eVH+QbefExukYYATG4RhkBMbZCHPiQ2iIAdNKHBigyLIQRDkoAdykAM5qIEcNEYOEiMHhZGDwMhBX8Yqrcc5sUFb5CAtE53YICyTndigPFOd2AAscnCQGU5sAJ5ZTmygkTlObGCSeU5sIBM5wMlCJzZwihygRQ7MIwfxkYOIvObEBmiRA7LIwRrkYA9yEIjVTmwQijVObBCMEic2CMc6JzYIyAYnNuDIRic2cMtmJzbgihxgpdKJDTq01YkNUiQHL6p2YoMdyUGQ5OBIctCkXU5skCU5+JIclEkO1iQHcZKDOx10YoPxHHZig/ccdWKD/RwXdkLYSWGnnNjgVWec2EAn55zYoCUXnNgAJJec2GAicqCQq05s0A85yIccwEMO2CEH45CDb8g/p8o/tMo/3co/oso/3dY6sYEqHjmxARbkn25fd2J/0JV/uH9L2NvCPiTsHWHvCntP2IeFfUTYR4X9mbA/F/YXwj4m7C+FfVzYJ4R9UtinhH1a2GeE/ZWwzwr7nLC/FvZ5YV8Q9kVhfyPsb4X9nbAvCft7YV8W9g9OLDe/Kuwfhf2TsH8W9jVh/yLs68K+Iexfhf2bsG8K+5awbwv7jrB/F/ZdYf8h7D+FfU/Y94X9QNgPhf1I2I+F/UTYT4X9TNjPhf1C2C+F/UrYr4X9Rthvhf1O2O+dp+9H0vQjdXLSR9X/8C/XnJLK0qqcisrqnPLi6rUbcrYXb64pzSmryNnx9J9e5ZSrzmx6qfrcbZXbyyrW51T8YWNlFWs311SVVVbkrCsu21xagmv3Ved1dClr3LZtxbvEGiWlO3Mqa6pzKtflrKmsqSh5KuQWtRJd85tTsXlXTnFJuQBcW1yRU1pRkrO9srr0qXXeVY3pPHJa/BAf6dYArk82ZKUvNGSl76mVaBif4urq0vIt1TnVlUKHErmbNuRUbi/dtm5z5Q5cr2v3BgR7viErvdKQlQY0ZKWPd2+YFp9uSLDPN2Sl7zeQ8H81cL3/0xDI/1/flZz/AVMpKSbg+QQA", "debug_symbols": "7b3frl3Nce33Lro2gtld//0qQS6UEwcwYMgHx0qAwNC7Zynh3iSPtkSP/ljF0fx4Zcla3bPWrK6acw/+Rq3//MO//ft/++Of//Xf//Qff/jn//zD879slz/88//6n3/4j//+xz/99f/zH3/+4//48x/++fmnP/zLn/6P1//9yz/94f/813/7lz/88/b6y//2T//fCoVXGLzC4RUBr0h4RaEr4oFXLHjFhlfAOQ845wHnPOCcB5zzgHMecM4TznnCOU845wnnPOGcJ3x3E767Bd/dgu9uwXe34LtbwN39p7/5XJa9fbSepe+fXvW+vzXv7837R/P+2bx/te4vz/Nb9td8/NNHX/8x3j8d8bb96t1+924vvdtr7/bWuz36nJUn4BUJr0CfBLIeeMWCV2x4hcArFF5h8Ao45wvO+YJzvuCcbzjnG875hnO+4ZxvOOcbzvmGc77hnG845xvOucA5FzjnAudc4JwLnHOBcy5wzgXOucA5FzjnCudc4ZwrnHOFc65wzhXOucI5VzjnCudc4ZwbnHODc25wzg3OucE5NzjnBufc4JwbnHODc+5wzh3OucM5hzVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRgTVRSTjnCec84ZzDSq3ASq3ASq3ASq3ASq3ASq0UnPOCc15wzgvOecE5LzTn+jzwigWv2PAKgVcovMLgFQ6vCHhFwivgnMM6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nMI6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nME6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nMM6nCM63MFUD0dUu6P9d/P+0ry/Nu9vzft78/7RvH827987NcetuX6tuX6tuX6tuX6tuX6tuX6tuX6tuX6tuX6tuX69uX69uX69uX69uX79N9Xv6+X00ydfjeDz7uv54LMr4tNn9/N5X7G3QIwlEGcJJFgCSZZAiiSQeFgCWSyBbJZAhCUQls4aLJ01WDprsHTWYOmswdJZk6WzJktnTZbOmiydNVk6a7J01mTprMnSWbOps37avTp3r6d199W6+27dXVp319bdrXV3b909WndvrdXqrNV4ntbdV+vuu3V3ad1dW3e31t29dfdo3T1bd2+t1dVaq6u1Vtdvq1W3t92jftOLVSxhCURZAjGWQJwlkGAJJFkCKZJA9sMSyGIJhKWzbpbOulk662bprJuls26WzrpZOutm6azC0lmFpbMKS2cVls4qLJ1VWDqrsHRWYemswtJZhaWzKktnVZbOqiydVVk6q7J0VmXprMrSWZWlsypLZ1WWzmosndVYOquxdFZj6azG0lmNpbMaS2c1ls5qLJ3VWDqrs3RWZ+msztJZnaWzOktndZbO6iyd1Vk6q7N0VmfprMHSWYOlswZLZw2WzhosnTVYOmuwdNZg6azB0lmDpbMmS2dNls6aLJ01WTprsnTWZOmsydJZk6WzJktnTZbOWiydtVg6a7F01mLprMXSWYulsxZLZy2WzlosnbVIOms+JJ01H5LOmg9JZ82H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9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Qmu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Smu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Rmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9Tmu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9QWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9SWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWu9RWs9e0H1vpeSxa+ZONLBF+i+BLDlzi+JPAliS/Bs7/w7C88+wvP/sKzv/DsLzz7C8/+wrO/8OwvPPsbz/7Gs7/x7G88+xvP/sazv/Hsbzz7G8/+xrMvePYFz77g2Rc8+4JnX/DsC559wbMvePYFz77i2Vc8+4pnX/HsK559xbOvePYVz77i2Vc8+4Zn3/DsG559w7NvePYNz77h2Tc8+4Zn3/DsO559x7PvePYdz77j2Xc8+45n3/HsO559x7MfePYDz37g2Q88+4FnP/DsB579wLMfePYDz37i2U88+4lnP/HsJ579xLOfePYTz37i2U88+4Vnv/DsF579wrNfePYLz37h2S88+4VnH9f6Fq71LVzrW7jWt3Ctb+Fa38K1voVrfQvX+hau9S1c61u41rdwrW/hWt/Ctb6Fa30L1/oWrvUtXOtbuNa3cK1v4VrfwrW+hWt9C9f6Fq71LVzrW7jWt3Ctb+Fa38K1voVrfQvX+hau9S1c61u41rdwrW/hWt/Ctb6Fa30L1/oWrvUtXOtbuNa3cK1v4VrfwrW+hWt9C9f6Fq71LVzrW7jWt3Ctb+Fa38K1voVrfQvX+hau9S1c61u41rdwrW/hWt/Ctb6Fa30L1/oWrvUtXOtbuNa3cK1v4VrfwrW+hWt9C9f6Fq71LVzrW7jWt3Ctb+Fa38K1voVrfQvX+hau9S1c61u41rdwrW/hWt/Ctb6Fa30L1/oWrvUtXOtbuNa3cK1v4VrfwrW+hWt9C9f6Fq71LVzrW7jWt3Ctb+Na38a1vo1rfRvX+l7/wo0vMXyJ40sCX5L4Ejz7uNa3ca1v41rfRrS+f/qbz2ntT5+0He+fff0d9b699m5vvdt77/bRu332bl+t2yP66Mn2q3f73bt9b9Xu3qrdvVW7e6t291bt7q3a3Vu10lu10lu10lu10lu10lu10lu10lu18puqNtQ+fTLKP2+/9IPPmshbKKKf933eX7kkeUIpmlD04Qll8YSyeUIRnlCUJxTjCcV5QuHptsrTbXWs21blp8+uZz9fffhTLPYQxbKIYtlEsQhRLEoUixHF4kSxBFEsSRQLUd91or7rY313PR5vwaz97U9vf/+07A9D3/eGLveGrveGbveG7veGHveGnveGXteGHs+9od/7NI17n6Yx+DT9+8F8IEi//n3006dVVD5/uj6KI8veQq5n6Veffvui+nv5ovZ7+aL+e/mi8Xv5ovl7+aL1O/mi+fxevuj6vXzR/Xv5or+XNyOERL/7i/5e3ozy9/JmlL+XN6P8vbwZZdOb0aft6+ndfvVuv3u3l97ttXd7693ee7eP3u2zd/vWqpXn6d1+9W6/e7eX3u21d3vr3d57t4/e7bN3+96qXb1Vu3qrdvVW7eqt2tVbtau3aldv1a7eql29Vbt6q3b3Vu3urdrdW7W7t2p3b9Xu3qrdvVW7e6t291bt7q1a6a1a6a1a6a1a6a1a6a1a6a1a6a1a6a1a6a1a6a1a7a1a7a1a7a1a7a1a7a1a7a1a7a1a7a1a7a1a7a1a661a661a661a661a661a661a661a661a661a661a761a761a761a761a761a761a761a761a761a763a6K3a6K3a6K3a6K3a6K3a6K3a6K3a6K3a6K3a6K3a7K3a7K3a7K3a7K3a7K3a7K3a7K3a7K3a7K3aXjZKetko6WWjpJeNkl42SnrZKOllo6SXjZJeNkp62SjpZaO0l43SXjZKe9ko7WWj9NHe7a13e+/dPnq3z97te6u2l43SXjZKe9ko7WWjtJeN0l42SnvZKO1lo7SXjdJeNkp72SjtZaO0l43SXjZKe9ko7WWjtJeN0l42SnvZKO1lo7SXjdJeNkp72SjtZaO0l43SXjZKe9ko7WWjtJeN0l42SnvZKO1lo7SXjdJeNkp72SjtZaO0l43SXjZKe9ko7WWjtJeN0l42SnvZKO1lo7SXjdJeNkp72SjtZaO0l43SXjZKe9ko7WWjtJeN0l42SnvZKO1lo7SXjdJeNkp72SjtZaO0l43SXjZKe9ko7WWjtJeN0l42SnvZKO1lo7SXjdJeNkp72SjtZaO0l43SXjZKe9ko7WWjtJeN0l42SnvZKO1lo7SXjdJeNkp72SjtZaO0l43SXjZKe9ko7WWjtJeN0l42ynrZKOtlo6yXjbJeNsoe7d3eerf33u2jd/vs3b63anvZKOtlo6yXjbJeNsp62SjrZaOsl42yXjbKetko62WjrJeNsl42ynrZKOtlo6yXjbJeNsp62SjrZaOsl42yXjbKetko62WjrJeNsl42ynrZKOtlo6yXjbJeNsp62SjrZaOsl42yXjbKetko62WjrJeNsl42ynrZKOtlo6yXjbJeNsp62SjrZaOsl42yXjbKetko62WjrJeNsl42ynrZKOtlo6yXjbJeNsp62SjrZaOsl42yXjbKetko62WjrJeNsl42ynrZKOtlo6yXjbJeNsp62SjrZaOsl42yXjbKetko62WjrJeNsl42ynrZKOtlo6yXjbJeNsp62SjrZaOsl42yXjbKetko62WjrJeNsl42ynrZKOtlo6yXjbJeNsp62SjrZaO8l43yXjbKe9ko72Wj/NHe7a13e+/dPnq3z97te6u2l43yXjbKe9ko72WjvJeN8l42ynvZKO9lo7yXjfJeNsp72SjvZaO8l43yXjbKe9ko72WjvJeN8l42ynvZKO9lo7yXjfJeNsp72SjvZaO8l43yXjbKe9ko72WjvJeN8l42ynvZKO9lo7yXjfJeNsp72SjvZaO8l43yXjbKe9ko72WjvJeN8l42ynvZKO9lo7yXjfJeNsp72SjvZaO8l43yXjbKe9ko72WjvJeN8l42ynvZKO9lo7yXjfJeNsp72SjvZaO8l43yXjbKe9ko72WjvJeN8l42ynvZKO9lo7yXjfJeNsp72SjvZaO8l43yXjbKe9ko72WjvJeN8l42ynvZKO9lo7yXjfJeNsp72SjvZaO8l43yXjbKe9ko72WjvJeN8l42KnrZqOhlo6KXjYpeNioe7d3eerf33u2jd/vs3b63anvZqOhlo6KXjYpeNip62ajoZaOil42KXjYqetmo6GWjopeNil42KnrZqOhlo6KXjYpeNip62ajoZaOil42KXjYqetmo6GWjopeNil42KnrZqOhlo6KXjYpeNip62ajoZaOil42KXjYqetmo6GWjopeNil42KnrZqOhlo6KXjYpeNip62ajoZaOil42KXjYqetmo6GWjopeNil42KnrZqOhlo6KXjYpeNip62ajoZaOil42KXjYqetmo6GWjopeNil42KnrZqOhlo6KXjYpeNip62ajoZaOil42KXjYqetmo6GWjopeNil42KnrZqOhlo6KXjYpeNip62ajoZaOil42KXjYqetmo6GWjopeNil42KnrZqOhlo6KXjYpeNip62ajoZaOyl43KXjYqe9mo7GWj8tHe7a13e+/dPnq3z97te6u2l43KXjYqe9mo7GWjspeNyl42KnvZqOxlo7KXjcpeNip72ajsZaOyl43KXjYqe9mo7GWjspeNyl42KnvZqOxlo7KXjcpeNip72ajsZaOyl43KXjYqe9mo7GWjspeNyl42KnvZqOxlo7KXjcpeNip72ajsZaOyl43KXjYqe9mo7GWjspeNyl42KnvZqOxlo7KXjcpeNip72ajsZaOyl43KXjYqe9mo7GWjspeNyl42KnvZqOxlo7KXjcpeNip72ajsZaOyl43KXjYqe9mo7GWjspeNyl42KnvZqOxlo7KXjcpeNip72ajsZaOyl43KXjYqe9mo7GWjspeNyl42KnvZqOxlo7KXjcpeNip72ajsZaOyl43KXjYqe9mo7GWjspeNyl42qnrZqOplo6qXjapeNqoe7d3eerf33u2jd/vs3b63anvZqOplo6qXjapeNqp62ajqZaOql42qXjaqetmo6mWjqpeNql42qnrZqOplo6qXjapeNqp62ajqZaOql42qXjaqetmo6mWjqpeNql42qnrZqOplo6qXjapeNqp62ajqZaOql42qXjaqetmo6mWjqpeNql42qnrZqOplo6qXjapeNqp62ajqZaOql42qXjaqetmo6mWjqpeNql42qnrZqOplo6qXjapeNqp62ajqZaOql42qXjaqetmo6mWjqpeNql42qnrZqOplo6qXjapeNqp62ajqZaOql42qXjaqetmo6mWjqpeNql42qnrZqOplo6qXjapeNqp62ajqZaOql42qXjaqetmo6mWjqpeNql42qnrZqOplo6qXjapeNqp62ahqZaPkaWWjXtuv3u137/bSu732bm+923vv9tG7ffZu31u1q7dqV2/Vrt6qXb1Vu3qrdvVW7eqt2tVbtau3aldv1e7eqt29Vbt7q3b3Vu3urdrdW7W7t2p3b9Xu3qrdvVUrvVUrvVUrvVUrvVUrvVUrvVUrvVUrvVUrvVUrvVWrvVWrvVWrvVWrvVWrvVWrvVWrvVWrvVWrvVWrvVVrvVVrvVVrvVVrvVVrvVVrvVVrvVVrvVVrvVVrvVXrvVXrvVXrvVXrvVXrvVXrvVXrvVXrvVXrvVXrvVUbvVUbvVUbvVUbvVUbvVUbvVUb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jnB9OcL15QjXlyNcX45wfTnC9eUI11cjXF+NcH01wvXVCNdXj45cxUau4iNXiZGr5MhVRmp/hOurEa6vRri+GuH6aoTrqxGur0a4vhrh+mqE66sRrq9GuL4a4fpqhOurEa6vRri+GuH6aoTrqxGur0a4vhrh+mqE66sRrq9GuL4a4fpqhOurEa6vRri+GuH6aoTrqxGur0a4vhrh+mqE66sRrq9GuL4a4fpqhOurEa6vRri+GuH6aoTrqxGur0a4vhrh+mqE66sRrq9GuL4a4fpqhOurEa6vRri+GuH6aoTrqxGur3Cu722hnS7004VxujBPF9bhQpxke1u4Thfu04VyuvD05MTpyYnTkxOnJydOT06cnpw8PTl5enLy9OTk6cnJ05OTpycnT09Onp6cPD05eXpy6vTk1OnJqdOTU6cnp05PTp2enDo9OXV6cur05NTZyfHneU4XrtOF+3ShnC7U04V2utBPF8bpwjxdeHpy1unJWacnZ52enHV6ctbpyVmnJ2ednpx1enLW6clZpydnn56cfXpy9unJ2acnZ5+enH16cvbpydmnJ2efnpx9enLk9OTI6cmR05MjpydHTk+OnJ4cOT05cnpy5PTkyOnJ0dOTo6cnR09Pjp6eHD09OXp6cvT05OjpydHTk6OnJ8dOT46dnhw7PTl2enLs9OTY6cmx05NjpyfHTk+OnZ4cPz05fnpy/PTk+OnJ8dOT46cnx09Pjp+eHD89OX56cuL05MTpyYnTkxOnJydOT06cnpw4PTlxenLi9OTE6cnJ05OTpycnT09Onp6cPD05eXpy8vTk5OnJydOTk6cnp05PTp2enDo9OXV6cur05NTpyanTk1OnJ6dOT86phrxONeR1qiGvUw15nWrI61RDXqca8jrVkNephrxONeR1qiGvUw15nWrI61RDXqca8jrVkNephrxONeR1qiGvUw15nWrI61RDXqca8jrVkNephrxONeR1qiGvUw15nWrI61RDXqca8jrVkNephrxONeR1qiGvUw15nWrI62MN+fm06vlqyd+yan/9LcxPH/3rD1a+fzriff9o3j+b96/e/T/Wt7/j/qt5/928vzTvr837W/P+zfWrzfWrzfWrzfVrzfVrzfVrzfVrzfVrzfVrzfVrzfVrzfVrzfVrzfXrzfXrzfXrzfXrzfXrzfXrzfXrzfXrzfXrzfXr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" }, { "name": "cast_vote", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "candidate", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "candidate": [{ "start": 33, "end": 34 }], "inputs": [{ "start": 0, "end": 33 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466] }, "bytecode": "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", "debug_symbols": "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" }, { "name": "constructor", "is_unconstrained": true, "custom_attributes": ["aztec(public)", "aztec(initializer)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "admin", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "admin": [{ "start": 37, "end": 38 }], "inputs": [{ "start": 0, "end": 37 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239] }, "bytecode": "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", "debug_symbols": "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nCl14kypE2dKnThT6sSZUifOlDpxptSJM6VOnCl14kypE2dKnThT6sSZUifOlDpxptSJM6VOnCl14kypE2dKnThT6sSZUifOlDpxptSJM6VOnCl14kypE2dKnThT6sSZUifOlDpxptSJM6VOnCl14kypE2dKnThT6sSZUifOlDpxptSJM6VOnCl14kypE2dKnThT6sSZUifOlDpxptSJM6VOnCl14kypE2dKnThT6sSZUifOlDpxptSJM6VOnCl14kypE2dKnThT6sSZUifOlDpxptSJM6VOnCl14kypE2dKnThT6sSZUifOlDpxptSJM6VOnCl14kypE+dKnThX6sS5UifOlTpx/gg5sCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJc6VOnCt14lypE+dKnThX6sS5UifOlTpxrtSJC6VOXCh14kKpExdKnbh4hBw4lDpxodSJC6VOXCh14kKpExdKnbhQ6sSFUiculDpxodSJC6VOXCh14kKpExdKnbhQ6sSFUiculDpxodSJC6VOXCh14kKpExdKnbhQ6sSFUiculDpxodSJC6VOXCh14kKpExdKnbhQ6sSFUiculDpxodSJC6VOXCh14kKpExdKnbhQ6sSFUiculDpxodSJC6VOXCh14kKpExdKnbhQ6sSFUiculDpxodSJC6VOXCh14kKpExdKnbhQ6sSFUiculDpxodSJC6VOXCh14kKpExdKnbhQ6sSFUiculDpxodSJC6VOXCh14kKpExdKnbhQ6sSFUiculDpxodSJC6VOXCh14kKpExdKnbhQ6sSFUiculDpxodSJC6VOXCh14kKpExdKnbhQ6sSF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7+aj47v56PhuPjq+m4+O7+aj47v56PhuPjq+m4+O7+Yj5Lsm5Lsm5Lsm5Lsm5Lsm5Lsm5Lsm5Lsm5Lsm5Lsm5Lsu5Lsu5Lsu5Lsu5Lsu5Lsu5Lsu5Lsu5Lsu5Lsu5Lsh5Lsh5Lsh5Lsh5Lsh5Lsh5Lsh5Lsh5Lsh5Lsh5Lsp5Lsp5Lsp5Lsp5LtIy+T1SOFHGj9y8CODH1n4CNIweD1i+BHHjwR+BN9+4dsvfPuFb7/w7Re+/ca33/j2G99+49tvfPuNb7/x7Te+/ca33/j2D779g2//4Ns/+PYPvv2Db//g2z/49g++/YNvf/DtD779wbc/+PYH3/7g2x98+4Nvf/DtD779xbe/+PYX3/7i2198+4tvf/HtL779xbe/8PbrefAjhh9x/EjgRxI/UviRxo8c/MjgR/DtG759w7dv+PYN377h2zd8+4Zv3/DtG759w7fv+PYd377j23d8+45v3/HtO759x7fv+PYd337g2w98+4FvP/DtB779wLcf+PYD337g2w98+4lvP/HtJ779xLePZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32FZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ32NZ30Hz/oOnvUdPOs7eNZ38Kzv4FnfwbO+g2d9B8/6Dp71HTzrO3jWd/Cs7+BZ38GzvoNnfQfP+g6e9R086zt41nfwrO/gWd/Bs76DZ30Hz/oOnvUdPOs7eNZ38Kzv4FnfwbO+g2d9B8/6Dp71HTzrO3jWd/Cs7+BZ38GzvoNnfQfP+g6e9R086zt41nfwrO/gWd/Bs76DZ30Hz/oOnvUdPOs7eNZ38Kzv4FnfwbO+g2d9B8/6Dp71HTzrO3jWd/Cs7+BZ38GzvoNnfQfP+g6e9R086zt41nfwrO/gWd/Bs76DZ30Hz/oOnvUdPOs7eNZ38Kzv4FnfwbO+g2d9B8/6Dp71HTzrO3jWd/Cs7+BZ38GzvoNnfQfP+g6e9R086zt41nfwrO/gWd/Bs76DZ30Hz/oOnvUdPOs7eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNY3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3eNa3cNbXD5z1vRwx/IjjRwI/kviRwo80fuTgRwY/gm/f8O0bvn3Dt2/49g3fvuHbN3z7hm/f8O0bvn3Ht+/49h3fvuPbd3z7jm/f8e07vn3Ht+/49gPffuDbD3z7gW8/8O0Hvv3Atx/49gPffuDbT3z7iW8/8e0nvv3Et5/49hPffuLbT3z7iW+/8O0Xvv3Ct1/49gvffuHbL3z7hW+/8O0Xvv3Gt9/49hvffuPbb3z7jW+/8e03vv3Gt9/49g++/YNv/+DbP/j2D779g2//4Ns/+PYPvv2Db3/w7Q++/cG3P/j2B9/+4NsffPuDb3/w7Q++/cW3v/j2F9/+4ttffPuLb3/x7S++/cW3j2d9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9hmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmd9jmR9f/y71/31CyG+vPSvX/Tw9upz3p6fl59fl5/fl59/Lj9/Lj9/7z4fiUk/9Hy7/Hy//PzL+j1X9Xsgvujvn585X16ZuW+vna9Pz6tPr6tP76tPP1efPlefvjefbs/Vp9vVp/vVp3/Oa57XV9bz7tPz6tPr6tP76tPP1afP1afvzaf7c/XpdvXpfvXpV7XqV7XqV7XqV7XqV7XqV7XqV7Uan/tcPa+fTWXPe0+3q0/3q0+Pq0/Pq0+vq0/vq08/V58+V5++N5+eV7WaV7WaV7WaV7WaV7WaV7WaV7WaV7WaV7WaV7VaV7VaV7VaV7VaV7VaV7VaV7VaV7VaV7VaV7VaV7XaV7XaV7XaV7XaV7XaV7XaV7XaV7XaV7XaV7XaV7X6/n+5iT6vGemTb6de/jPG27H42LH82LH62LH+0LH3efKXT/H8cu7lg+Xrwf56Lj547t035eU/On451j2/GfNtc+/T5d8+1h87dj52bMBjL/+///tP/+1f/vS//+s///vLib/+H/+vP/+Xv/zLv/35y//3L//Pf/3//i//+f8C" }, { "name": "add_to_tally_public", "is_unconstrained": true, "custom_attributes": ["aztec(public)", "aztec(internal)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "candidate", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "candidate": [{ "start": 37, "end": 38 }], "inputs": [{ "start": 0, "end": 37 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239] }, "bytecode": "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", "debug_symbols": "7b3djmRZcqX3Ln1NCMf+zfgqgi6o0QggMOAMhpQAYdDvLm8pIzJzKrqzbFeY1dpVecUi6eccc9/b1vZYuT7z//GX//Jf/9O//Me//td/+/e//PP/+Mvzv7DrX/75f/0ff/n3//Yv//a3/8u//8e//Pf/+Ms/P//0l//8b//H63/+9Z/+8n/+63/5z3/5Z/b66//2T//fFda+wttXRPuKbF9R3Svi+fVX/NMvXidCX14pVu+vzXi7OU3enNvvVdpXtHdStHdStHdStHdStHdStHdSPu0rqH1Fe82zvebZXvNsr3m21zzba57tNc/2mtdvUg+y+vJKSvq2wT94aZC9vTbI319M9V4K4ZTCOKUITimKU4rhlOI4pQROKYlTSqGUIg+M2soDo7bywKitPDBqKw+M2soDo7bywKitPDBqKw+M2sqDo7aEo7aEo7aEo7aEo7aEo7aEo7aEo7aEo7aEo7aEo7aMo7aMo7aMo7aMo7aMo7aMo7aMo7aMo7aMo7aMo7aCo7aCo7aCo7aCo7aCo7aCo7aCo7aCo7aCo7aCo7aKo7aKo7aKo7aKo7aKo7aKo7aKo7aKo7aKo7aKo7aGo7aGo7aGo7aGo7aGo7aGo7aGo7aGo7aGo7aGo7aOo7aOo7aOo7aOo7aOo7aOo7aOo7aOo7aOo7aOo7aBo7aBo7aBo7aBo7aBo7aBo7aBo7aBo7aBo7aBo7aJo7aJo7aJo7aJo7aJo7aJo7aJo7aJo7aJo7aJo7Y4LJngsGSCw5IJDksmOCyZ4LBkgsOSCQ5LJjgsmeCwZIrDkikOS6Y4LJnisGT6wKit4rBkisOSKQ5LpjgsmeKwZIrDkikOS6Y4LJnisGSKw5IpDkumOCyZ4rBkisOSKQ5LpjgsmeKwZIrDkikOS6Y4LJnisGSKw5IpDkumOCyZ4rBkisOSKQ5LpouokvN7KSkfleI4pWxtW345kF9e+/rP/KCUNSjnV5RCOKUwTimCU4pudRC/XvL24td/f+0hfvitGEMqxpGKCaRiEqmYAipmD9D5NcUQUjGMVIwgFYOkwIakwIakwIakwGvADqu8fe9lLf7uC0Tv1V8Kr0sLX4OBeoVn2VsN9ZB+VDjdWjjfWnh3Zrq2f3FB27+4oO1fXND2Ly5oPO0rftPu/PFa/DZ+4lfcX4bvr8P3t+H7+/D9f9OprPn4l5e+/jPeXx3xdvucvX2N3v63hfx/fHuavT3P3r776xna/vUMbf96hrZ/PUPbv56h7V/P0PavZ2i1T4Ki9hXcvqK95tVe82qvebXXvNprXu01r+6a2/O0r6D2Fdy+QtpXaPsKa1/h7SuifUW2r2ivObXXnNprTu01p/aaU3vNqb3m1F5zaq85tdec2mvO7TXn9ppze825vebcXnNurzm315zba87tNef2mkt7zaW95tJec2mvubTXXNprLu01l/aaS3vNpb3m2l5zba+5ttdc22uu7TXX9ppre821vebaXnNtr7m119zaa27tNbf2mlt7za295tZec2uvubXX3Npr7u019/aae3vNvb3m7d/GtbZTa22n1tpOrbWdWms7tdZ2ai3aa97+FVtr/4qttX/F1tq/YmvtX7G19q/YWvtXbK39K7bW/hVba/+KrbV/xdbaPpy1fThr+3DW9uGs7cNZ24eztg9nbR/O2j6ctX04a/tw1vbhrO3DWduHs7YPZ20fzto+nLd9OG/7cN724bztw3nbh/O2D+dtH87bPpy3fThv+3De9uG87cN524fztg/nbR/O2z6ct304b/tw3vbhvO3DeduH87YP520fzts+nLd9OG/7cN724bztw3nbh/O2D+dtH87bPpy3fThv+3De9uG87cN524fztg/nbR/O2z6ct304b/tw3vbhvO3DeduH87YP520fzts+nLd9OG/7cN724bztw3nbh/O2D+dtH87bPpy3fThv+3De9uG87cN524fztg/nbR/O2z6ct304b/tw3vbhvO3DeduH87YP520fzts+nLd9OG/7cN724bztw3nbh/O2D+dtH87bPpy3fThv+3De9uG87cN524fztg/nbR/O2z6ct304b/tw3vbhvO3DeduH87YP520fzts+nLd9OG/7cN724bztw0Xbh4u2DxdtHy7aPly0fbho+3DR9uGi7cNF24eLtg8XbR8u2j5ctH24aPtw0fbhou3DRduHi7YPF20fLto+XLR9uGj7cNH24aLtw0Xbh4u2DxdtHy7aPly0fbho+3DR9uGi7cNF24eLtg8XbR8u2j5ctH24aPtw0fbhou3DRduHi7YPF20fLto+XLR9uGj7cNH24aLtw0Xbh4u2DxdtHy7aPly0fbho+3DR9uGi7cNF24eLtg8XbR8u2j5ctH24aPtw0fbhou3DRduHi7YPF20f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9Vnf67O+12d9r8/6Xp/1vT7re33W9/qs7/VZ3+uzvtdnfa/P+l6f9b0+73t93vf6vO/1ed/r877X532vz/ten/e9Pu97fd73+rzv9Xnf6/O+1+d9r8/7Xp/3vT7ve33e9/q87/V53+vzvtfnfa/P+16f970+73t93vf6vO/1ed/r877X532vz/ten/e9Pu97fd73+rzv9Xnf6/O+1+d9r8/7Xp/3vT7ve33e9/q87/V53+vzvtfnfa/P+16f970+73t93vf6vO/1ed/r877X532vz/ten/e9Pu97fd73+rzv9Xnf6/O+1+d9r8/7Xp/3vT7ve33e9/q87/V53+vzvtfnfa/P+16f970+73t93vf6vO/1ed/r877X532vz/ten/e9Pu97fd73+rzv9Xnf6/O+1+d9r8/7Xp/3vT7ve33e9/q87/V53+vzvtfnfa/P+16f970+73t93vf6vO/1ed/ri77XF32vL/peX/S9vuh7fdH3+qLv9UXf64u+1xd9ry/6Xl/0vb7oe33R9/qi7/VF3+uLvtcXfa8v+l5f9L2+6Ht90ff6ou/1Rd/ri77XF32vL/peX/S9vuh7fdH3+qLv9UXf64u+1xd9ry/6Xl/0vb7oe33R9/qi7/VF3+uLvtcXfa8v+l5f9L2+6Ht90ff6ou/1Rd/ri77XF32vL/peX/S9vuh7fdH3+qLv9UXf64u+1xd9ry/6Xl/0vb7oe33R9/qi7/VF3+uLvtcXfa8v+l5f9L2+6Ht90ff6ou/1Rd/ri77XF32vL/peX/S9vuh7fdH3+qLv9UXf64u+1xd9ry/6Xl/0vb7oe33R9/qi7/VF3+uLvtcXfa8v+l5f9L2+6Ht90ff6ou/1Rd/ri77XF32vL/peX/S9vux7fdn3+rLv9WXf68u+15d9ry/7Xl/2vb7se33Z9/qy7/Vl3+vLvteXfa8v+15f9r2+7Ht92ff6su/1Zd/ry77Xl32vL/teX/a9vux7fdn3+rLv9WXf68u+15d9ry/7Xl/2vb7se33Z9/qy7/Vl3+vLvteXfa8v+15f9r2+7Ht92ff6su/1Zd/ry77Xl32vL/teX/a9vux7fdn3+rLv9WXf68u+15d9ry/7Xl/2vb7se33Z9/qy7/Vl3+vLvteXfa8v+15f9r2+7Ht92ff6su/1Zd/ry77Xl32vL/teX/a9vux7fdn3+rLv9WXf68u+15d9ry/7Xl/2vb7se33Z9/qy7/Vl3+vLvteXfa8v+15f9r2+7Ht92ff6su/1Zd/ry77Xl32vL/teX/a9vux7fdn3+rLv9WXf66u+11d9r6/6Xl/1vb7qe33V9/qq7/VV3+urvtdXfa+v+l5f9b2+6nt91ff6qu/1Vd/rq77XV32vr/peX/W9vup7fdX3+qrv9VXf66u+11d9r6/6Xl/1vb7qe33V9/qq7/VV3+urvtdXfa+v+l5f9b2+6nt91ff6qu/1Vd/rq77XV32vr/peX/W9vup7fdX3+qrv9VXf66u+11d9r6/6Xl/1vb7qe33V9/qq7/VV3+urvtdXfa+v+l5f9b2+6nt91ff6qu/1Vd/rq77XV32vr/peX/W9vup7fdX3+qrv9VXf66u+11d9r6/6Xl/1vb7qe33V9/qq7/VV3+urvtdXfa+v+l5f9b2+6nt91ff6qu/1Vd/rq77XV32vr/peX/W9vup7fdX3+qrv9VXf66u+11d9r6/6Xl+1vT5+2l7f6xLqX8L9S6R/ifYvsf4l3r8k+pdk/5L+6lN/9am/+tRffeqvPvVXn/qrT/3Vp/7qU3/1qb/63F997q8+91ef+6vP/dXn/upzf/W5v/rcX33ur770V1/6qy/91Zf+6kt/9aW/+tJffemvvvRXX/qrr/3V1/7qa3/1tb/62l997a++9ldf+6uv/dXX/upbf/Wtv/rWX33rr771V9/6q2/91bf+6lt/9a2/+t5ffe+vvvdX3/ur7/3V9/7qe3/1vb/63l99769+9Fc/+qsf/dWP/upHf/Wjv/rRX/3or370Vz/6q5/91c/+6md/9bO/+tlf/eyvfvZXP/urn/3Vz/7qV3/1q7/61V/96q9+9Ve/+qtf/dWv/upXf/X7Xh/1vT7qe33U9/qo7/VR3+ujvtdHfa+P+l4f9b0+6nt91Pf6qO/1Ud/ro77XR32vj/peH/W9Pup7fdT3+qjv9VHf66O+10d9r4/6Xh/1vT7qe33U9/qo7/VR3+ujvtdHfa+P+l4f9b0+6nt91Pf6qO/1Ud/ro77XR32vj/peH/W9Pup7fdT3+qjv9VHf66O+10d9r4/6Xh/1vT7qe33U9/qo7/VR3+ujvtdHfa+P+l4f9b0+6nt91Pf6qO/1Ud/ro77XR32vj/peH/W9Pup7fdT3+qjv9VHf66O+10d9r4/6Xh/1vT7qe33U9/qo7/VR3+ujvtdHfa+P+l4f9b0+6nt91Pf6qO/1Ud/ro77XR32vj/peH/W9Pup7fdT3+qjv9VHf66O+10d9r4/6Xh/1vT7qe33U9/qo7/Vx3+vjvtfHfa+P+17f61+4+5dY/xLvXxL9S7J/SX/1+14f970+7nt93Pf6uO/1cd/r477Xx32vj/teH/e9Pu57fdz3+rjv9XHf6+O+18d9r4/7Xh/3vT7ue33c9/q47/Vx3+vjvtfHfa+P+14f970+7nt93Pf6uO/1cd/r477Xx32vj/teH/e9Pu57fdz3+rjv9XHf6+O+18d9r4/7Xh/3vT7ue33c9/q47/Vx3+vjvtfHfa+P+14f970+7nt93Pf6uO/1cd/r477Xx32vj/teH/e9Pu57fdz3+rjv9XHf6+O+18d9r4/7Xh/3vT7ue33c9/q47/Vx3+vjvtfHfa+P+14f970+7nt93Pf6uO/1cd/r477Xx32vj/teH/e9Pu57fdz3+rjv9XHf6+O+18d9r4/7Xh/3vT7pe33S9/qk7/VJ3+uTvtcnfa9P+l6f9L0+6Xt90vf6pO/1Sd/rk77XJ32vT/pen/S9Pul7fdL3+qTv9Unf65O+1yd9r0/6Xp/0vT7pe33S9/qk7/VJ3+uTvtcnfa9P+l6f9L0+6Xt90vf6pO/1Sd/rk77XJ32vT/pen/S9Pul7fdL3+qTv9Unf65O+1yd9r0/6Xp/0vT7pe33S9/qk7/VJ3+uTvtcnfa9P+l6f9L0+6Xt90vf6pO/1Sd/rk77XJ32vT/pen/S9Pul7fdL3+qTv9Unf65O+1yd9r0/6Xp/0vT7pe33S9/qk7/VJ3+uTvtcnfa9P+l6f9L0+6Xt90vf6pO/1Sd/rk77XJ32vT/pen/S9Pul7fdL3+qTj9f3TL16nxV9eaRzvryXN99vT7O159vYye3udvb3N3t5nbx+zt8/Z29fk7fV5Zm9Ps7fn2dvL7O119vY2e3ufvX3M3j5nbz/btTTbtTTbtTTbtTTbtfSbujbUvrwyyr/envSD15rIWymiX+/71HsphlOK45QSOKUkTikFUwo/OKUQTimMU4rglIKjtoyjtrymtlX55bX08PPdi99qCaBaEqiWwqlFHqBaCKgWBqpFgGpRoFoMqBYg3RUg3ZU13aXH460Y4h+/mv391cIfll7Xlq7PvaXTvaXzvaXLvaXrvaXbvaX7vaXHvaXfe5rqvaepLZ6mf7+YDwxppvry6tf3cvn66vqojix7K7ke0u9e/fZG6c/yRvnP8kblz/JG9c/yRu3P8kb9z/JG48/yRvPP8kbrT/JG/c/yzcj/LN+M/M/yzcj/LN+MOqzC3W/0z/LNyIe+Gb3dPmZvn7O3r9HbxzN7e5q9Pc/eXmZvr7O3t9nbz3ZtzHZtzHZtzHZtznZtznZtznZtznZtznZtznZtznZtznZtznZtznZtzXZtzXZtzXZtzXZtzXZtzXZtzXZtzXZtzXZtjXatPc/s7Wn29jx7e5m9vc7e3mZv77O3j9nb5+ztZ7uWZruWZruWZruWZruWZruWZruWZruWZruWZruWZruWZ7uWZ7uWZ7uWZ7uWZ7uWZ7uWZ7uWZ7uWZ7uWZ7tWZrtWZrtWZrtWZrtWZrtWZrtWZrtWZrtWZrtWZrtWZ7tWZ7tWZ7tWZ7tWZ7tWZ7tWZ7tWZ7tWZ7tWZ7vWZrvWZrvWZrvWZrvWZrvWZrvWZrvWZrvWZrvWZrvWZ7vWZ7vWZ7vWZ7vWZ7vWZ7t2Nhtls9kom81G2Ww2ymazUTabjbLZbJTNZqNsNhtls9kom81G2Ww2ymazUTabjbLZbJTNZqNsNhtls9kom81G2Ww2ymazUTabjbLZbJTNZqNsNhtls9kom81G2Ww2ymazUTabjbLZbJTNZqNsNhtls9kon81G+Ww2ymezUT6bjfJHZ29vs7f32dvH7O1z9vazXTubjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbJTPZqN8Nhvls9kon81G+Ww2ymezUT6bjfLZbFTMZqNiNhsVs9momM1GxaOzt7fZ2/vs7WP2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xOnOidOdE6c7J053TpzunDzdOXm6c/J05+TpzsnTnZOnOydPd06e7pw83Tl5unPqdOfU6c6p051TpzunTndOne6cOt05dbpz6nTn1OHOkec5vZBOL+TTC+X0Qj290E4v9NML4/TCPL3wdOfQ6c6h051DpzuHTncOne4cOt05dLpz6HTn0OnOodOdw6c7h093Dp/uHD7dOXy6c/h05/DpzuHTncOnO4dPd46c7hw53TlyunPkdOfI6c6R050jpztHTneOnO4cOd05erpz9HTn6OnO0dOdo6c7R093jp7uHD3dOXq6c/R059jpzrHTnWOnO8dOd46d7hw73Tl2unPsdOeceshy6iHLqYcspx6ynHrIcuohy6mHLKcespx6yHLqIcuphyynHrKceshy6iHLqYcspx6ynHrIcuohy6mHLKcespx6yHLqIcuphyynHrKceshy6iHLqYcspx6y/B0PuZ7n7cLi+O7CX/4zZ5F9eXH5N1mV54OXZtnbjeshfX8x1deKAq6ihKuo0Cr6Oz7971kRwVXEcBUJXEUKV5HBVQSn2QWn2QWn2YWm2fqgabY+aJqtD5pm6zOp2W/P0IVn2MIzfOEZsfCMXHhGzT+DnoVn0MIzeOEZC31OC31OC31OC31OC31OC31OC33OC33OC33OC33OC33OC33OC33OC33OC33OC33OC30uC30uC30uC30uC30uC30uC30uC30uC30uC30uC32uC32uC32uC32uC32uC32uC32uC32uC32uC32uC31uC31uC31uC31uC31uC31uC31uC31uC31uC31uC33uC33uC33uC33uC33uC33uC33uC33uC33uC33uC30eC30eC30eC30eC30eC30eC30eC30eC30eC30eC32eC32eC32eC32eC32eC32eC32eC32eC32eC32eC31eC31eC31eC31eC31eC31eC31eC31eC31eC31e831uz7PwDFp4Bi88QxaeoQvPsIVn+MIzYuEZufCMhT5fyMPZQh7OFvJwtpCHs4U8nC3k4WwhD2cLeThbyMPZQh7OFvJwtpCHs4U8nC3k4WwhD2cLeThbyMPZZ+Th6NH3Qbj0PN8+5Zcv9niDVr3s60vlvaBEK6jACvqMWN7nFkRoBTFaQYJWkKIVZGgFOVpBaEotaEotaEqtaEqtaEqtaEqtaEqtaEqtaEqtaEqtaEqtaEqtaEptaEptaEptaEptaEptaEptaEptaEptaEptaEptaErtaErtaErtaErtaErtaErtaErtaErtaErtaErtaEodaEodaEodaEodaEodaEodaEodaEodaEodaEodaEqdaEqdaEqdaEqdaEqdaEqdaEqdaEqdaEqdaEqdaEpdaEpdaEpdaEpdaEpdaEpdaEpdaEpdaEpdaEpdYErtD5hS+wOm1P6AKbU/YErtD5hS+wOm1P6AKbU/YErtD5hS+4Om1ISm1ISm1ISm1ISm1ISm1ISm1ISm1ISm1ISm1ISm1Iym1Iym1Iym1Iym1Iym1Iym1Iym1GiMoqMxio7GKDoao+hojKKjMYqOxig6GqPoaIyiozGKjsYoOhqj6GiMoqMxio7GKDoao+hojKKjMYqOxig6GqPoaIyiozGKjsYoOhqj6OuM4tt9nx/c9IeF862Fy62F662F262F+62Fx62F562F16WFr7Ogn1b4rSen33py+q0n5zqr+mmF33py+q0np996cvqtJ6ffenLGrSdn3Hpyxq0nZ9x6cq6zw59W+K0nZ9x6csatJ2fcenLGrSdn3npy5q0nZ956cuatJ+c6y/1phd96cuatJ2feenLmrSdn3npy1q0nZ916ctatJ2fdenKus/WfVvitJ2fdenLWrSdn3Xpy1qUnZzyXnpzxXHpyxnPpyRnPpSdnPJeenPFcenLGc+nJGc+lJ2c8l56c8dx6ctKtJyfdenLSrScn3Xpyrs+e+LTCbz056daTk249OenWk5NuPTn51pOTbz05+daTk289OddngXxa4beenHzrycm3npx868nJt56ccuvJKbeenHLrySm3npzrs1k+rfBbT0659eSUW09OufXklFtPTr315NRbT0699eTUW0/O9Vk5n1b4rSen3npy6q0np956cuqtJ6fdenLeOkMobp0hFLfOEIpbZwjFrTOE4tYZQnHrDKG4dYZQ3DpDKG6dIRS3zhCKW2cIxa0zhOLWGUJx6wyhuHWGUNw6QyhunSEUt84QiltnCMWtM4Ti1hlCcesMobh1hlDcOkMobp0hFLfOEIpbZwjFrTOEoj9D6O1COr2QTy+U0wv19EI7vdBPL4zTC/P0wjq8sE53Tp3unDrdOXW6c+p059TpzqnTnVOnO6dOd04d7px8ntML6fRCPr1QTi/U0wvt9EI/vTBO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DtLhOEiH4yAdjoN0OA7S4ThIh+MgHY6DdDgO0uE4SIfjIB2Og3Q4DtLhOEiH4yAdjoN0OA7S4ThIh+MgHY6DdDgO0uE4SIfjIB2Og3Q4DtLhOEiH4yAdjoN0OA7S4ThIh+MgHY6DdDgO0uE4SIfjIB2Og3Q4DtLhOEiH4yAdjoN0OA7S4ThIh+MgHY6DdDgO0uE4SIfjIB2Og3Q4DtLhOEiH4yAdjoN0OA7S4ThIh+MgHY6DdDgO0uE4SIfjIB2Og3Q4DtLhOEiH4yAdjoN0OA7S4ThIh+MgHY6DdDgO0uE4SIfjIAOOgww4DjLgOMiA4yDjQdPsgOMgA46DDDgOMuA4yIDjIAOOgww4DjLgOMiA4yADjoMMOA4y4DjIgOMgA46DDDgOMuA4yIDjIAOOgww4DjLgOMiA4yADjoMMOA4y4DjIgOMgA46DDDgOMuA4yIDjIAOOgww4DjLgOMiA4yADjoMMOA4y4DjIgOMgA46DDDgOMuA4yIDjIAOOgww4DjLgOMiA4yADjoMMOA4y4DjIgOMgA46DDDgOMuA4yIDjIAOOgww4DjLgOMiA4yADjoMMOA4y4DjIgOMgA46DDDgOMuA4yIDjIAOOgww4DjLgOMiA4yADjoMMOA4y4DjIgOMgA46DDDgOMuA4yIDjIAOOgww4DjLgOMiA4yADjoMMOA4y4DjIgOMgA46DDDgOMuA4yIDjIAOOgww4DjLgOMiA4yADjoMMOA4y4TjIhOMgE46DTDgOMh80zU44DjLhOMiE4yATjoNMOA4y4TjIhOMgE46DTDgOMuE4yITjIBOOg0w4DjLhOMiE4yATjoNMOA4y4TjIhOMgE46DTDgOMuE4yITjIBOOg0w4DjLhOMiE4yATjoNMOA4y4TjIhOMgE46DTDgOMuE4yITjIBOOg0w4DjLhOMiE4yATjoNMOA4y4TjIhOMgE46DTDgOMuE4yITjIBOOg0w4DjLhOMiE4yATjoNMOA4y4TjIhOMgE46DTDgOMuE4yITjIBOOg0w4DjLhOMiE4yATjoNMOA4y4TjIhOMgE46DTDgOMuE4yITjIBOOg0w4DjLhOMiE4yATjoNMOA4y4TjIhOMgE46DTDgOMuE4yITjIBOOg0w4DjLhOMiE4yATjoNMOA4y4TjIhOMgE46DTDgOMuE4yITjIAuOgyw4DrLgOMiC4yDrQdPsguMg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yq0np956cuqtJ6feenLqrSfn+myMTyv81pNTbz059daTU289OfXWk9NuPTnt1pPTbj057daTc31WyacVfuvJabeenHbryWm3npx268npt56cfuvJ6beenH7rybk+O+bTCr/15PRbT06/9eT0W09Ov/XkjFtPzrj15IxbT8649eRcn+XzaYXfenLGrSfnrTOE9NYZQnrrDCG9dYaQ3jpDSG+dIaS3zhDSW2cI6a0zhPTWGUJ66wwhvXWGkN46Q0hvnSGkt84Q0ltnCOmtM4T01hlCeusMIb11hpDeOkNIb50hpLfOELJbZwjZrTOE7NYZQnbrDCF7Lj057dYZQnbrDCHrzxB6uzBPL6zDC/szbN4upNML+fRCOb1QTy+00wv99MLTnUOnO4dOdw6f7hw+3Tl8unP4dOfw6c7h053DpzuHT3cOn+4cPt05crpz5HTnyOnOkdOdI6c7R053jpzuHDndOXK6c+R05+jpztHTnaOnO0dPd46e7hw93Tl6unP0dOfo6c7R051jpzvHTneOne4cO905drpz7HTn2OnOsdOdY6c7x053jp/uHD/dOX66c/x05/jpzvHTneOnO8dPd46f7hw/3TlxunPidOfE6c6J050TpzsnTndOnO6cON05cbpz4nTn5OnOydOdk6c7J093Tp7unDzdOXm6c/J05+TpzsnTnVOnO6dOd06d7pw63Tl1unPqdOfU6c6p051TpzunDneOP8/phXR6IZ9eKKcX6umFdnqhn14Ypxfm6YWnO+fUQ/ZTD9lPPWQ/9ZD91EP2Uw/ZTz1kP/WQ/dRD9lMP2U89ZD/1kP3UQ/ZTD9lPPWQ/9ZD91EP2Uw/ZTz1kP/WQ/dRD9l/hIRf/9R//+9/rTwn+8urXf8r7qyPen8IrT5GVp+jKU2zlKb7ylFh5Sq48pTae8iuM/c94ykrv60rv60rv60rv60rv60rv60rv60rv60rv20rv20rv20rv20rv20rv20rv20rv20rv20rv20rv+0rv+0rv+0rv+0rv+0rv+0rv+0rv+0rv+0rv+0rvx0rvx0rvx0rvx0rvx0rvx0rvx0rvx0rvx0rvx0rv50rv50rv50rv50rv50rv50rv50rv50rv50rv50rv10rv10rv10rv10rv10rv10rv10rv10rv10rv10bvx/OsPIVWnsIrT5GVp+jKU2zlKb7ylFh5Sq48ZaX3aaX3aaX3aaX3aaX3aaX3aaX3aaX3aaX3aaX3aaX3eaX3eaX3eaX3eaX3eaX3eaX3eaX3eaX3eaX3eaX3ZaX3V3J9sZLri5VcX6zk+mIl1xcrub5YyfXFSq4vVnJ9sZLri5VcX6zk+mIl1xcrub5YyfXFSq4vVnJ9sZLri5VcX6zk+mIl1xcrub5YyfXFSq4vVnJ9sZLri5VcX6zk+mIl1xcrub5YyfXFSq4vVnJ9sZLri5VcX3xGro+M9e3V5vr+6vdZjvEZub5f8ZRceUptPOUzcn2/4im08hReeYqsPEVXnmIrT1np/Vjp/Vjp/Vjp/Vzp/Vzp/Vzp/Vzp/Vzp/Vzp/Vzp/Vzp/Vzp/Vzp/Vrp/Vrp/Vrp/Vrp/Vrp/Vrp/Vrp/Vrp/Vrp/dro/XyelafQylN45Smy8hRdeYqtPMVXnhIrT8mVp6z0Pq30Pq30Pq30Pq30Pq30Pq30Pq30Pq30Pq30Pq30Pq/0Pq/0Pq/0Pq/0Pq/0Pq/0Pq/0Pq/0Pq/0Pq/0vqz0vqz0vqz0vqz0vqz0vqz0vqz0vqz0vqz0vqz0vq70vq70vq70vq70vq70vq70vq70vq70vq70vq70vq30vq30vq30vq30vq30vq30vq30vq30vq30vq30vq/0vq/0vq/0vq/0vq/0vq/0/kquL1dyfbmS68uVXF+u5PpyJdeXK7m+XMn15UquL1dyfbmS68uVXF+u5PpyJdeXK7m+XMn15UquL1dyfbmS68uVXF+u5PpyJdeXK7m+XMn15UquL1dyfbmS68uVXF+u5PpyJdeXK7m+XMn15UquL1dyfbWS66uVXF+t5PpqJddXj648xVae4itPiZWn5MpTVnp/JddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXK7m+Wsn11Uqur1ZyfbWS66uVXF+t5PpqJddXG7m+fDZyfa+n0MpTeOUpsvIUXXmKrTzFV54SK0/Jlaes9D6t9D6t9D6t9D6t9D6t9D6t9D6t9D6t9D6t9D6t9D6v9D6v9D6v9D6v9D6v9D6v9D6v9D6v9D6v9D6v9L6s9L6s9L6s9L6s9L6s9L6s9L6s9L6s9L6s9L6s9L6u9L6u9L6u9L6u9L6u9L6u9L6u9L6u9L6u9L6u9L6t9L6t9L6t9L6t9L6t9L6t9L6t9L6t9L6t9L6t9L6v9L6v9L6v9L6v9L6v9L6v9L6v9L6v9L6v9L6v9H6s9H6s9H6s9H6s9H6s9H6s9H6s9H6s9H6s9H6s9H6u9H6u9H6u9H6u9H6u9H6u9H6u9H6u9H6u9H6u9H6t9H6t9H6t9H6t9H6t9H6t9H6t9H6t9H6t9P5Kro9Wcn20kuujlVwfreT66NGVp9jKU3zlKbHylFx5ykrvr+T6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXRyu5PlrJ9dFKro9Wcn20kuujlVwfreT6aCXXxyu5Pl7J9fFKro9Xcn386MpTbOUpvvKUWHlKrjxlpfdXcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuvjlVwfr+T6eCXXxyu5Pl7J9fFKro9Xcn28kuuTlVyfrOT6ZCXXJyu5Pnl05Sm28hRfeUqsPCVXnrLS+yu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9clKrk9Wcn2ykuuTlVyfrOT6ZCXXJyu5PlnJ9elKrk9Xcn26kuvTlVyfPrryFFt5iq88JVaekitPWen9lVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6dCXXpyu5Pl3J9elKrk9Xcn26kuvTlVyfruT6bCXXZyu5PlvJ9dlKrs8eXXmKrTzFV54SK0/Jlaes9P5Krs9Wcn22kuuzlVyfreT6bCXXZ/1c39uFcXphnl5Yhxf2M3JvF9LphXx6oZxeqKcX2umFpzuHT3cOn+4cPt05crpz5HTnyOnO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" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "H4sIAAAAAAAA/+2YzW6DMAyATYECBbq/bmXrJnHcsUg99MhD7AWqDmm9tFNhe/xpuIuFoesuMwdLtRQlhBB/dkKwmQGABT9i18WFY6H7uann/5NMcK55n5yWEs6BEk5bkBPZJtDvPnV68Ks0o6uAcaiA0VPA6CtgDBQwjhQwhgoYIwWMsQLGsQLGCwWMlwoYrxQwXitgvFHAOFHAeKuA8U4B41SQ0WKMjmkndbmvy0NdZnVZmn4fGsmlGBbZGmN2Up5AWzA2GdCF0/TZxM36iH/A+ugfg+00NgzFbZgvcF5Pel6TKyTM/468/5c+85Mge18+OexZ2ouU75Eel/kqMG3BfysZ122ZEjCdYNaI2lM2lsaRP2hfE3sEzd4M/njO6TwXszHDX+zPQdZ+r8PjdZhdYwsKxkmJ0/ilyyb53wvnHcnP21pzt7MmpI+v+ZOpL0xfJL8OixDa5zHZzCVn7Yj5PpTnyXqy87CmsZnrC2TPkHHHV37HVzEbEzP/jXvwn8X00tx0TfrOzGfmU8whtN9x6uP3qR50bOHxFI0P4Pg8ETWIFPKAzzJweA8PVDxs8YPmQfPRGDFjaRHwoMUPDSa8mFBiwoYJESYcGNBPmY5TQS4PhEkeTf1s6pe3TZmud9tqv1pX6euuKNPtrko/yiJ9328+V1WB10UJ3zr8F0fqGgAA", "debug_symbols": "nZBLCoAgFEX38sYSEf10K9HgZQaCqKgFIe49JVpAzu6HMzkRlOEYpNEeWIS26XpgSwRvUZfBB3QBWDcPBITec6JtInBIJXIeaVpJgYYaaKyBphpo/gnldqGTuClRtJTz1PyzlGu47fukBw==" }, { "name": "get_vote", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "candidate", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "candidate": [{ "start": 0, "end": 1 }] }, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [1] }, "bytecode": "H4sIAAAAAAAA/81X20rDQBDdTdJLmjbtq6CwX1A2xSf1IT77pl8QSSpC20CSov68mLYzeFyWgnQDGWh3dnYyc+bsJRsphJDiJD7oKGxLqdWXSeIwlpYGzifSx2BPXeW71avhIUjwlxeWqP153CGfUfsbwrgkO/stwCYB+8A1dq1Xh/y+gdmsIQV9AHgC93iSjurUY+D82yF/kuYTufINrmbgMwT+Rh3wJyEvx+Y+5/svZq8HmHFdKOF2XYzd17SK2xgh8Do2+MW6JqQ7XJdaUH7OyfkmkHdKuhRuz94I8krAwfkC8Lmhdi5Oa05Y+Andz09y7ozjfIhH9gBPJOzvl9DgDN85OJbCONfmgS0m3bfEnoGN5y62PIs8zaCWlHR9mRx5wlwp9DnfFHDEPcEzsuDp6izl+eHY3B/1JHcH83A8x+cd1bSgWEOKy/g5XwA+9zCGzzIucz/h2mDfyMIb7mkeC4lP3q8O3x8J3pdSh3Ej8XtvZDl39uF9qYN7YTIBPuumrLK34rnIcgnQAgMmtuanxkE8sKHuW2yC0nOZAdh46gdg8wxa8PrO/qGwfLKl1OrL5LgffKNgFCTHs/hdU/tA7cuJc1VvykZptWv/s82m/CjypcKxWm33daPqJqsata7KrUqWGPeO2itqH6sq+1Lvu7z4VOW+UeVavZb7XV6LH+hQctHeDgAA", "debug_symbols": "1ZrdaoNAEIXfZa+lzOzOzu7mVUovbJpCIJiQ2EIJvnsN8adgiFQSOd45eGbnQ9ZPhD2b3X6dl9t9cTKrs6EXNavXszkd8uJSn8r8WJqVdUkzsyk+6kuxrsrM53a3qQtNVTZIJ/ZNOGnssko3ojF5arPE0oU5peotq3ECFk7EwklYOExgPAzGY8F4HBiPgPF4MB4wOTOYnRlMzwzmZwvmZwvmZwvmZ/sAPzOJa9LMRPeJWhwaWVRDbJKafL+ka7Blmdh+mdi6TOywTOy4TOzxL5Ebm8DMocOW+HfGMOyCbbLC/fNgClceR2A8DMZjwXgcGI+A8XgwHgXjCWA8EYwHzM8C5mcB87OA+VnA/CxgfhYwPwuYnwXMzwLmZwHzs3+un68zeIYZdoYZboYZD/Gdj92MSPf3BxN3/5Bkbb9DUmyIPByRwhEFOKIIR5TQiJTgiG6//doqw5EMFa5+SpNOaQpTmuKUpvTPprr6zo/b/H23uZw/uNz8KtbtcYS6LH8O1zvVLw==" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "30": { "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\n// TODO: add implementations for the remainder of primitive types.\nimpl Hash for Field{\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        let input: [Field] = [self];\n        H::write(state, input);\n    }\n}\n", "path": "std/hash.nr" }, "33": { "source": "// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n", "path": "std/merkle.nr" }, "35": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "60": { "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr" }, "63": { "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T> Storage<T> for PublicMutable<T> {}\n\nimpl<T> PublicMutable<T> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable reads only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr" }, "71": { "source": "use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::{PrivateContext, ContextInterface},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\nfn _nullifier_inclusion(nullifier: Field, header: Header) {\n    // 1) Get the membership witness of the nullifier\n    let witness = get_nullifier_membership_witness(header.global_variables.block_number as u32, nullifier);\n\n    // 2) Check that the witness we obtained matches the nullifier\n    assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n    // 3) Compute the nullifier tree leaf\n    let nullifier_leaf = witness.leaf_preimage.hash();\n\n    // 4) Prove that the nullifier is in the nullifier tree\n    assert(\n        header.state.partial.nullifier_tree.root\n        == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n    );\n    // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n    //     was included in the nullifier tree.\n}\n\npub fn prove_nullifier_inclusion<TContext>(\n    nullifier: Field,\n    context: TContext\n) where TContext: ContextInterface {\n    _nullifier_inclusion(nullifier, context.get_header());\n}\n\npub fn prove_nullifier_inclusion_at(\n    nullifier: Field,\n    block_number: u32, // The block at which we'll prove that the nullifier exists in the nullifier tree\n    context: PrivateContext\n) {\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n\npub fn prove_note_is_nullified<Note, N>(\n    note: Note,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n\n    _nullifier_inclusion(nullifier, context.historical_header);\n}\n\npub fn prove_note_is_nullified_at<Note, N>(\n    note: Note,\n    block_number: u32,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr" }, "77": { "source": "use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_non_existent_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL>,\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_non_existent_read_requests: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_non_existent_read_requests: self.nullifier_non_existent_read_requests.storage,\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address,\n            reverted: false\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_non_existent_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_non_existent_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let side_effect_counter = self.side_effect_counter;\n        // TODO get next value from output of `call_public_function_internal`\n        self.side_effect_counter += 1;\n\n        call_public_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "94": { "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr" }, "99": { "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, \n    address::AztecAddress, \n    constants::ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr" }, "100": { "source": "use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nfn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nfn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr" }, "103": { "source": "use dep::protocol_types::{address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr" }, "107": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "114": { "source": "use dep::protocol_types::{\n    hash::{silo_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, ContextInterface},\n    oracle::get_contract_instance::get_contract_instance,\n    history::nullifier_inclusion::prove_nullifier_inclusion,\n};\n\npub fn mark_as_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(*context);\n    ContextInterface::push_new_nullifier(context, init_nullifier, 0);\n}\n\npub fn assert_is_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_contract_initialization_nullifier(*context);\n    prove_nullifier_inclusion(init_nullifier, *context);\n}\n\npub fn compute_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    let address = context.this_address();\n    silo_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(context)\n    )\n}\n\npub fn compute_unsiloed_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    context.this_address().to_field()\n}\n\npub fn assert_initialization_args_match_address_preimage<TContext>(context: TContext) where TContext: ContextInterface {\n    let address = context.this_address(); \n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash([init_selector.to_field(), init_args_hash], GENERATOR_INDEX__CONSTRUCTOR)\n}", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr" }, "132": { "source": "struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr" }, "144": { "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr" }, "145": { "source": "use crate::{\n    address::eth_address::EthAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash,\n    traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, portal_contract_address: EthAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            portal_contract_address.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr" }, "146": { "source": "use crate::{\n    address::{eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::ToField\n};\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "163": { "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize}\n};\n\nstruct FunctionData {\n    // First four bytes of the abi encoding \n    // of a function. \n    selector : FunctionSelector,\n    is_internal : bool,\n    is_private : bool,\n    is_constructor : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        self.is_internal == other.is_internal &\n        self.is_private == other.is_private &\n        self.is_constructor == other.is_constructor\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_internal: serialized[1] as bool,\n            is_private: serialized[2] as bool,\n            is_constructor: serialized[3] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty item hash\" test\n    assert_eq(hash, 0x200569267c0f73ac89aaa414239398db9445dd4ad3a8cf37015cd55b8d4c5e8d);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr" }, "168": { "source": "use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, abis::side_effect::Ordered\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    portal_contract_address : EthAddress,\n\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        assert(self.msg_sender.to_field() == 0);\n        assert(self.storage_contract_address.to_field() == 0);\n        assert(self.portal_contract_address.to_field() == 0);\n        assert(self.function_selector.to_field() == 0);\n        assert(self.is_delegate_call == false);\n        assert(self.is_static_call == false);\n        assert(self.side_effect_counter == 0);\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, call_context: CallContext) -> bool {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        call_context.msg_sender.eq(self.msg_sender)\n            & call_context.storage_contract_address.eq(self.storage_contract_address)\n            & call_context.portal_contract_address.eq(self.portal_contract_address)\n            & call_context.function_selector.eq(self.function_selector)\n            & (call_context.is_delegate_call == self.is_delegate_call)\n            & (call_context.is_static_call == self.is_static_call)\n            & (call_context.side_effect_counter == self.side_effect_counter)\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender.to_field(),\n            self.storage_contract_address.to_field(),\n            self.portal_contract_address.to_field(),\n            self.function_selector.to_field(),\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.side_effect_counter as Field,\n        ]\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        CallContext {\n            msg_sender: AztecAddress::from_field(serialized[0]),\n            storage_contract_address: AztecAddress::from_field(serialized[1]),\n            portal_contract_address: EthAddress::from_field(serialized[2]),\n            function_selector: FunctionSelector::from_field(serialized[3]),\n            is_delegate_call: serialized[4] as bool,\n            is_static_call: serialized[5] as bool,\n            side_effect_counter: serialized[6] as u32,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let _hashed = context.hash();\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr" }, "183": { "source": "use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem, side_effect::SideEffect\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_internal: false, is_private: false, is_constructor: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0xedd2f10c0cdf776ee2fff3c799bae6df5771f5013a2d5d7154601dffdcf869;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_internal: false, is_private: false, is_constructor: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x1cec0b51f9394405a626c3b77081c96f1bdcb8bacf96960ae4749068f9b4da0d;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr" }, "185": { "source": "use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_field(value: Field) -> Self {\n        Self { inner: value as u32 }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr" }, "194": { "source": "global NULLIFIER_LEAF_PREIMAGE_LENGTH: u64 = 3;\n\nuse crate::{merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u64,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u64 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr" }, "196": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::AztecAddress,\n    constants::{\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs{\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    prover_address: AztecAddress,\n\n    reverted: bool,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.reverted as Field);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            reverted: reader.read() as bool,\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x083ac560a513d670a7f50f0a3052d42cb9816b7b643e62025b8278652ad637ab;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr" }, "198": { "source": "use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<1> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<1> for U128 {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr" }, "199": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "202": { "source": "global ARGS_LENGTH: u64 = 16;\nglobal RETURN_VALUES_LENGTH: u64 = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_NOTE_HASHES_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX  MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_NOTE_HASHES_PER_TX  MAX_NEW_NOTE_HASHES_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX  MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_CALL: u64 = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: u64 = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: u64 = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: u64 = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: u64 = 16;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_CALL: u64 = 32;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_CALL: u64 = 2; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL: u64 = 2;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: u64 = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 56;\n\nglobal MAX_NEW_NULLIFIERS_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 56;\n\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: u64 = 8;\n\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 8;\nglobal MAX_NON_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 3;\nglobal MAX_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 5;\n\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\n\nglobal MAX_PUBLIC_DATA_READS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\n\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: u64 = 2;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_TX: u64 = 128;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_TX: u64 = 8; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX: u64 = 8;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: u64 = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: u64 = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: u64 = 3;\nglobal FUNCTION_TREE_HEIGHT: u64 = 5;\nglobal NOTE_HASH_TREE_HEIGHT: u64 = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: u64 = 40;\nglobal NULLIFIER_TREE_HEIGHT: u64 = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: u64 = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: u64 = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\nglobal NULLIFIER_TREE_ID = 0;\nglobal NOTE_HASH_TREE_ID = 1;\nglobal PUBLIC_DATA_TREE_ID = 2;\nglobal L1_TO_L2_MESSAGE_TREE_ID = 3;\nglobal ARCHIVE_TREE_ID = 4;\n\n// SUB-TREES RELATED CONSTANTS\nglobal NOTE_HASH_SUBTREE_HEIGHT: u64 = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: u64 = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: u64 = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: u64 = 5;\nglobal ARCHIVE_HEIGHT: u64 = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: u64 = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: u64 = 35;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: u64 = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: u64 = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: u64 = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u64 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u64 = 32;\n// The following is used in immutable state variables to compute an initialization slot whose value is used to\n// determine whether a given variable has been initialized (by asserting that the value in the slot is 0).\n// The initialization slot is computed by adding the constant bellow to the variable's storage slot. This constant has\n// to be large enough so that it's ensured that it doesn't collide with storage slots of other variables.\nglobal INITIALIZATION_SLOT_SEPARATOR: Field = 1000_000_000;\nglobal INITIAL_L2_BLOCK_NUM: Field = 1;\n// 126976 = 31 * 4096;\nglobal BLOB_SIZE_IN_BYTES: Field = 126976;\n\n// CONTRACT CLASS CONSTANTS\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: u64 = 15000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: u64 = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: u64 = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\nglobal DEPLOYER_CONTRACT_ADDRESS = 0x0bffa876f07f9fe1802579dfef599810202f9c25b9a2f58921064a267d1ad1d3;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\nglobal MAX_NOTE_FIELDS_LENGTH: u64 = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: u64 = 23;\nglobal MAX_NOTES_PER_PAGE: u64 = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: u64 = 212;\n\n// LENGTH OF STRUCTS SERIALIZED TO FIELDS\nglobal AZTEC_ADDRESS_LENGTH = 1;\nglobal CALL_CONTEXT_LENGTH: u64 = 7;\nglobal CONTENT_COMMITMENT_LENGTH: u64 = 7;\nglobal CONTRACT_INSTANCE_LENGTH: u64 = 6;\nglobal CONTRACT_STORAGE_READ_LENGTH: u64 = 2;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: u64 = 2;\nglobal ETH_ADDRESS_LENGTH = 1;\nglobal FUNCTION_DATA_LENGTH: u64 = 4;\nglobal FUNCTION_LEAF_PREIMAGE_LENGTH: u64 = 5;\nglobal GLOBAL_VARIABLES_LENGTH: u64 = 6;\nglobal HEADER_LENGTH: u64 = 23; // 2 for last_archive, 7 for content commitment, 8 for state reference, 6 for global vars\nglobal L1_TO_L2_MESSAGE_LENGTH: u64 = 8;\nglobal L2_TO_L1_MESSAGE_LENGTH: u64 = 2;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH = 5;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: u64 = 6;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: u64 = 215;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 210;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 202;\nglobal STATE_REFERENCE_LENGTH: u64 = 8; // 2 for snap + 8 for partial\nglobal TX_CONTEXT_DATA_LENGTH: u64 = 4;\nglobal TX_REQUEST_LENGTH: u64 = 10;\n\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH: Field = 13; // 2 + FUNCTION_DATA_LENGTH + CALL_CONTEXT_LENGTH\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: u64 = 674;\nglobal NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal NUM_MSGS_PER_BASE_PARITY: u64 = 4;\n// NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP / NUM_MSGS_PER_BASE_PARITY\nglobal NUM_BASE_PARITY_PER_ROOT_PARITY: u64 = 4;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n  8                         | 0 < hash_index  32  |\n * | MID       | 8 < n  16                    | 32 < hash_index  40 |\n * | HIGH      | 16 < n  48                   | 40 < hash_index  48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size  8\nglobal GENERATOR_INDEX__NOTE_HASH = 1;\nglobal GENERATOR_INDEX__NOTE_HASH_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size  16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size  44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\nglobal GENERATOR_INDEX__AUTHWIT_INNER = 45;\nglobal GENERATOR_INDEX__AUTHWIT_OUTER = 46;\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/constants.nr" }, "209": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "225": { "source": "use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    portal_contract_address : EthAddress,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt) &\n        self.portal_contract_address.eq(other.portal_contract_address)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.portal_contract_address.to_field(),\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            portal_contract_address: EthAddress::from_field(serialized[4]),\n            public_keys_hash: PublicKeysHash::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.portal_contract_address\n            )\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr" }, "269": { "source": "contract EasyPrivateVoting {\n    // docs:start:imports\n    use dep::aztec::prelude::{\n        AztecAddress, FunctionSelector, NoteHeader, NoteInterface, NoteGetterOptions, PrivateContext,\n        Map, PublicMutable\n    };\n    use dep::aztec::context::Context;\n    // docs:end:imports\n    // docs:start:storage_struct\n    struct Storage {\n        admin: PublicMutable<AztecAddress>, // admin can end vote\n        tally: Map<Field, PublicMutable<Field>>, // we will store candidate as key and number of votes as value\n        voteEnded: PublicMutable<bool>, // voteEnded is boolean\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)] // annotation to mark function as a constructor\n    fn constructor(admin: AztecAddress) {\n        storage.admin.write(admin);\n        storage.voteEnded.write(false);\n    }\n    // docs:end:constructor\n\n    // docs:start:cast_vote\n    #[aztec(private)] // annotation to mark function as private and expose private context\n    fn cast_vote(candidate: Field) {\n        let secret = context.request_nullifier_secret_key(context.msg_sender()); // get secret key of caller of function\n        let nullifier = dep::std::hash::pedersen_hash([context.msg_sender().to_field(), secret.low, secret.high]); // compute nullifier with this secret key so others can't descrypt it\n        context.push_new_nullifier(nullifier, 0); // push nullifier\n        context.call_public_function(\n            context.this_address(),\n            FunctionSelector::from_signature(\"add_to_tally_public(Field)\"),\n            [candidate]\n        );\n    }\n    // docs:end:cast_vote\n\n    // docs:start:add_to_tally_public\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn add_to_tally_public(candidate: Field) {\n        assert(storage.voteEnded.read() == false, \"Vote has ended\"); // assert that vote has not ended\n        let new_tally = storage.tally.at(candidate).read() + 1;\n        storage.tally.at(candidate).write(new_tally);\n    }\n    // docs:end:add_to_tally_public\n\n    // docs:start:end_vote\n    #[aztec(public)] \n    fn end_vote() {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Only admin can end votes\"); // assert that caller is admin\n        storage.voteEnded.write(true);\n    }\n    // docs:end:end_vote\n    // docs:start:get_vote\n    unconstrained fn get_vote(candidate: Field) -> pub Field {\n        storage.tally.at(candidate).read()\n    }\n    // docs:end:get_vote\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/easy_private_voting_contract/src/main.nr" } } }
