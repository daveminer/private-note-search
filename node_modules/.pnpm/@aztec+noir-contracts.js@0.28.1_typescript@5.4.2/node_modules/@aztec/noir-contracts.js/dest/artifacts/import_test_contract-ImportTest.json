{ "noir_version": "0.25.0+589a6cb62caf38445c768429150eee469ae35d77", "name": "ImportTest", "functions": [{ "name": "callOpenFn", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "target", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "target": [{ "start": 33, "end": 34 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320] }, "bytecode": "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", "debug_symbols": "7Z1tT9swEID/Sz5XyHd+vf6VaR86xiQkVBB0kybEf5/DsJMS16eWCBxdPtGq53D3KImfa5L6ubu7v94dbu/3T932uQPVbb89d08Pu33/9umwezx0W7XpbvY/49+XTffr9u6m26IPL5tJHFh6i4QAOTb4QigihbdY1NbmYCAqRAeyKQdSYI6iv286gEVmjZ+VtdGYsjaEH8xafyRrCy4BtKjCkDeWSlQq5Q0KhyLB6kJ0rCxv2Q+xJrxmbRaZtV1k1q6UNVqdDx2nDJO71j6VqS34UXRpBweHw9Hg0Jt6rfMexV5UtUFUtdR6tXOe2VF9frVamVyt1nZcbZ8RfAF/glpG+AWMjMsZGauY83gwzmcxcGTeF6BbL4AA8kxEYH093GHatnOj/V8XNx2zTVvWIzIxw0I0qcSRgIbYYF8xmhXjHBjtinEOjG7FOAdGv2KcA2NYMc6BkVaMM2DUasU4B0ZYMc6Bsfn+YRkYJXcxBjNGY/AIY4/GrGhOoZHcbTBoJHcQDBrJXQGDRrLpM2gk23sdjZFs5AwayZbNoJFszgwa0TacL3LHy880QWNWNKfQiLbhOhrRNlxHI9qG62hE23AdjWgbrqKxom24jka0DdfRiLbhOhrJNmwh3z1mjZqgMSuaU2gk2zCDRrINM2gk2zCDRrINM2gk23AdjZNswwwayTbMoJFswwya9m0YTX4GgDCE+dCgVwkNeuNGaEpVkk7B5EZNhTGFWG8TPj+6kQXVK3EjmbjPxAMiR7x2i49rX8gXgbF9eV8ExvZFfxEY228KFoGx/QZiCRh9+83GIjC235gsAmP7TcwiMIpueObDaFaMc2CU3MUEazJGb48w9mgkdyYMGsndBoNGcgfBoJHcFdTRBMmmz6CRbO8MGslGzqCRbNkMGiMYDSmbqiR0EzSSbZhBI9mGGTSSbZhBI9mGGTSSbbiOhiTbMINGsg0zaCTbMINGsg0zaIxkNA4ymtGPdCc0om24jka0DdfRiLbhOhrRNlxHI9qGq2hAidZhho1oH2bYiBZiho1oI2bYmJXNSTatOzGqWGTKRXn1/vf1QbWurjFrHFXgYVJB64YZsw46VxAKFbQughgn1nwNKZ4QcFJB677GVgCtW1XM2qlcQSxnUkHr7oOA+dQbX0/W+gBo3VAQdH4uLr72blJB6x6BQJT3ojg5+EkFrc/22B8IuQJU0yO5+TkZ0eNQQdD18EDpC0vC0fOSQRczwbyajqPjpyuLW64vU9i8GyyGZPOOch5J0mkyJUsMSTc8feqCHn3jTu4Sks270nkkfT4dxy927BHK7/0aZ1fFPcdTyohG7U5aF+0qXDCmaHAwTBYjTnHm7sfgFZ7/j+IgumBQeVkMbhBcMgjPGxTf/Nk93u5+3N30S9L2n/3eX6cVauPbw9+H/5+8/AM=" }, { "name": "callNoArgs", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "target", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "target": [{ "start": 33, "end": 34 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468] }, "bytecode": "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", "debug_symbols": "7b3RjiQ9dqT5Ln3dGDjpdJKuV1nMRe+sFhAgtAaj3gUWQr/7Rk9XeGb1z2x6/rSin0OzK0lQVOWxr/7IY+aZYee//vDv//E//vSXf/uPP//nH/7lv/4Qtj/8y//xX3/4z//5pz//7f/8z7/86X/95Q//sv3xD//65//r9T//+sc//N//9u//+od/iaX+9Y+/eV04zh+vDDVcr62l8dIYz/rjtXE/juvF4Twbr67n8Z7h3EL66dX//Y9/CMHl1HHW1GmP76nTGQen3kemPkJ+AzziVj/mji2J2/aeO2zxQ2Q49sarX8quv7l8vDbV/z11cjn14XLq3Jo6husLxPDprfPF7FsJ11cI56dXt/4DD6Gk/J4+lFI+a/3bROWBifb9n01UH5io1muieu6d/x5SiNc3mLSn8x8FnM4FxM27gOBdQPQuYPcuIHkXcHgXkL0LKN4FeN/E0fsm3r1v4t37Jt69b+Ld+ybevW/i3fsm3r1v4t37Jt69b+Ld+yZO3jdx8r6Jk/dNnLxv4uR9Eyfvmzh538TJ+yZO3jdx8r6JD++b+PC+iQ/vm/jwvokP75v48L6JD++b+PC+iQ/vm/jwvomz902cvW/i7H0TZ++bOHvfxNn7Js7eN3H2vomz902cvW/i4n0TF++buHjfxMX7Ji7eN3HxvomL901cvG/i4n0TF++buHrfxNX7Jq7eN3H1vomr901cvW/i6n0TV++buHrfxNX7Jj69b+LT+yY+vW/i0/smPr1v4tP7Jj69b+LT+yY+vW/i0/4m3vN2CUip/oOAsNlfxem4Xp6O/fyNAvu7+CjX5/xTjvE3Cuwv454C+9s4p4/3Qa6/VWB/HZftQ0H5bbXBZn8fl/zxTq7bbxXYX8jnnt4vP7btt/8Vmd/Ixxa3DwU1/UaB+ZV85KvNKBylHL9RYH4nHzV8/Fd0hu0fFQTzO/k4a/hQcMZ//vK41/d/c/G1za8Xh+aru61Z5vf9k3Tyf2t+CwrH1etzfPpDe/zxh+rv+UPNN1o4LzXhoz/oTH/vD/pvsf0xk1LfNvusH++Hs15/qv6uP3X+nj/V/hRD90+F3/Wn4u/6U/vv+lPpd/2p43f9qeYqP2t5/we1xfr5j/3xG699f4ny679EHf0S4Twu43yWs/PmTvn48eL0qR3v/Yb720CnsYHav2eMGuj9RcKMLxJnfJF9xhdJM77IMeOL5BlfpMz4InXGFzknfJEy4x1fZrzjy4x3fJnxji/D7/i47VdF7Fb3zlrIx3st5CO31kI5rA2UrQ1UrA1UrQ10GhuobtYGCtYGitYG2icPdL0455/9cuO1MV+vjc3hk+fhD8/DZ8/DF8/DV8/Dn46HPzfPwwfPw0fPw3vesKfnDXt63rCn5w17et6wp+cNezresPvmeMPum+Hv8/v5/nHrfraHN/x9vj+84e826fpFhhSO5vCGv9v0hzf83aY7fDD83aY/vGE/3x/esJ/vD2/4+3zvp9F7MPx9vj+8YT/fH96wn+8Pb3nDdoe3vGG7w1vesL3ho+UN2x3e8obtDm95w3aH97xho5kN+x7IzNZ8DzR7E36Z3H/72rBdPzANW/70K72pXuMX3+NX3+OfrsffN9/jB9/jR9/j/9K9+P4iacYXOWZ8kTzji4xvgxA+fS6n9P6T6vxCz75XawOdxgZKm7WBgrWBorWBdmsDJWsDHdYGypMHQv4sLxXPw1fPw5+Ohz82z8MHz8NHz8PvnodPnoc/PA/vecMenjfs4XnDHp43bPa8YbPnDZs9b9jsecOOf1r9yeE9b9jsecNmzxs2e96w2fOGLZ43bPG8YYvnDVs8b1hAO8SDw3vesMXw9/nu5w6K4e/z3eGr4e823d/Broa/2/SHN/zdpj+84e82/eEN+/n+8Ib9fH94w9/nu7/SWQ1/n+8Ofxr28/3hDfv5/vCWN2x3eMsbtju85Q3bHd7yhu0Ob3nDdoe3vGG7w3vesKeZDfv3gdJmZmu+B5q9Cb/zq8sf/exh/9T9HvJ+jR99j7/7Hj/5Hv/wPX72PX7xPX61PP4RPsZPP43/21ef23vmM3wuOT4uqSeN1LDxSLW8+VO8pKY9td5/wfLmvzG+5c1/Y/zke3zLm//G+JY3/43xLW/+G+Nb3vyfx0+xOb7lbd4fP1re0DfGN711P1+JDM3xTW/d/vimt25/fNNbtz++6a3bH9/01u2Pb3rr9sc3vXU/j382xze9dbvj76a3bn98y1v3CNeh+2Nvmobd8ta9Mb7lrXtjfMtb98b4lrfujfEtb90b41veujfGt7x1P4+ftub4lrduf/xkeeveGP+Xbt33F4kzvsg+44ukGV8EsA3q+7+SGLtX03t9LgnR54IdqFgbqFob6DQ2EKIfBTtQsDZQtDbQbm2gNHkg4Med0nF4Hj57Hr54Hr56Hv50PHzePA8fPA8fPQ+/ex7e84bNnjds9rxhs+cNmz1v2Ox5wxbPG7Z43rDF84Ytnjcsom/kueE9b9jiecMWzxu2eN6wxfOGrZ43bPW8YavnDVs9b1hEx85zw3vesNXzhq2eN2z1vGGr5w17et6wp+cNe3resKfnDYvo2HlueM8b9vS8YU/PG/b0vGFPxxv22Bxv2GNzvGGPzfGGPTbHG/bYHG/YY3O8YY/N8YY9Nscb9tgcb9hj87xhg+cNGzxv2OB5wwbPGxbRjvPc8J43bPC8YYPnDRs8b9jgecNGzxs2et6w0fOGjZ43LKIJ57nhPW/Y6HnDRs8bNnresNHzht09b9jd84bdPW/Y3fOGRbTePDe85w27e96wu+cNu3vesLvnDZs8b9jkecMmzxs2ed6wiL6f54b3vGGT5w2bPG/Y5HnDJs8b9vC8YQ/PG/bwvGEPzxvWc6fT4bnT6fDc6XR47nQ6PHc6HZ47nQ7PnU6H506nw3On0+G50+nw3Ol0eO50Ojx3Oh2eO50Oz51Oh+dOp8Nzp9PhudPp8NzpdHjudDo8dzodnjudDs+dTofnTqfDc6fT4bnT6fDc6XR47nQ6PHc6HZ47nQ7PnU6H506nw3On0+G50+nw3Ol0eO50Ojx3Oh2eO50Oz51Oh+dOp8Nzp9PhudPp8NzpdHjudDo8dzodnjudsudOp+y50yl77nTKnjud8uZ4w2bPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzplD13OmXPnU7Zc6dT9tzpVDx3OhXPnU7Fc6dT8dzpVDbHG7Z47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+K506l47nQqnjudiudOp+q506l67nSqnjudqudOp7o53rDVc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13OlXPnU7Vc6dT9dzpVD13Op2eO51Oz51Op+dOp9Nzp9O5Od6wp+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO53C5rnU6TW94x37mt7xkn1N73jLvqZ3vGZf0zves6/pHS/a1/SON+1reser9jW9613rud7pNb3rXeu54Ok1vetd67ni6TW9613rueTpNb3rXeu55uk1vetd67no6TWb613ruerpNZvrXeu57Ok1m+td67nu6TWb613rufDpNZvrXeu58uk1vetd67n06TW9613rufbpNb3rXeu5+Ok1vetd67n66TW9613rufzpNb3rXeu5/uk1vetd67kA6jW9613ruQLqNb3rXeu5BOo1vetd67kG6jW9613ruQjqNb3rXeu5Cuo1vetd67kM6jW9613ruQ7qNb3rXeu5EOo1vetd67kS6jW9613ruRTqNb3rXeu5Fuo1vetd67kY6jW9613ruRrqNb3rXeu5HOo1vetd67ke6jW9613ruSDqNb3rXeu5Iuo1vetd67kk6jW9613ruSbqNb3rXeu5KOo1vetd67kq6jW9613ruSzqNb3rXeu5Luo1vetd67kw6jW9613ruTLqNb3rXeu5NOo1vetd67k26jW9510bXPdGBde9UcF1b1Rw3RsVNs+7NrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o4Lo3KrjujQque6OC696o6Lo3KrrujYque6Oi696ouHnetdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdGRde9UdF1b1R03RsVXfdG7a57o3bXvVG7696o3XVv1L553rW7696o3XVv1O66N2q33F20n+HHa/fzi+kNf7+/Mb3h7zkppB+vTeFoT2/4e86N6Q1/z7kxveHvOTemN+zvb0xv2N/3p7fcn5Py8Z6+hvb0hr/f35jesL+/Mb1hf39jesu7tj+95V3bn97yru1Pb3nX9qe3vGv701vetd3pLffn3Jje9a613J9zY3rXu9Zyf86N6V3vWjv9OddEZvbnNdHsnfjlU7jfvvY89h+vPevenv70PP30nptvTJ/T8Y7POZXy8erz970Xp7fiPKk1+tR6zb87nz85n/9wPn92Pn9xPr/hnX5rfsNb/c78h9O9fs3vdFdf8zvfv4fz/Tu9Wwc9v/P9e1jev8f+jkX56HrtfBzXi3PTax+WdzVaq+W9jtZq2QOAtWbLfgGt1bK3QGu17EPQWi17FrTWRKTVshf6nlbo74rmdTwWlss6fgzLZR3vhuWyjs+DcinreEIsl3X8I5bLOl4Ty2UdX4rlksSlyUV+t81FfrfNRX63zUV+t81FfrfJpcrvtrnI77a5yO+2ucjvtrkkcWlykd9tc5HfbXOR321zkd9tc5HfbXI55XfbXOR321zkd9tc5HfbXJK4NLnI77a5yO+2ucjvtrnI77a5yO+2uKRNfrfNRX63zUV+t81FfrfNJYlLk4v8bpuL/G6bC6V/6fbTpkDpX25wodxH3W7RNL3P2AsXyn10gwvlPrrBhfL5yw0ulM9fbnCh9C/dTqoUKf3LDS6Uz19ucKF8/nKDC6ff7XNJ4tLkwul3+1w4/W6fC6ff7XPh9Lt9LgR+9611J/Cwl9Z1fOk3/ub4+uveMx/n9vHqXD/IrONM0WTW8aZoMklkviCzjj9Fk1nHoaLJrONR0WTWcanfIZOPa+aczzaZdXwqmIzpKxDPkuH0wHfIcHrgO2Q4PfAdMklkviDD6YHLHt8zl88zfybD6YHvkOH0wHfIcHrgO2Q4PfANMqYvpjxLhtMD3yHD6YHLdn6QyT+R+e2rz/394vOz90mp8dpyvH8mUc50vTZuH8A5rfWDwJOAzwVOGgSeA06aL54Dzhlb6vbmEmsMbTvBGVvukOGMLTfILHS4CU2GM7bcIcMZW+6Q4cwXd8gkTptUzg8ysWeTtjeNM3yySfX4oEjq7sEUSS07mCKpD7+O18aaS/t7HakPv0GG1If3ySx0LAtNhtSH3yBD6sNvkCH14TfIJHoypf3DuIXOZqHJcPrlO2Q4PfC5vT/TF89Q22Q4PfAdMpwe+AaZhQ5ooclweuA7ZDg98B0ynB74DplETybmNhlOD3yHDKcHvkOG1APncJEpqU2G1APfIEPqgftkFjqqhSZD6oFvkCH1wDfIkHrgG2QSPZna/k2Vhc5rocmQeuAbZJx64Gt+p071mt+pn/zvf5//8Hpa6prfsjfLW7xe/Llyu/mdIca32J+m2D9ptey20Fot+ye01kSk1bLHQWu17FrQWi37kO9pPa4HjyW0tVr2LGitlv0NWKvpM1Vorev4pr5W074pXx4359T0uKbPhN2ZPzmf37RnuTG/aR9yY37T3uLG/Kb9wo35TXuA/vymzzfdmd/0rk7penGtnV1drxfXL3KE6dNJaK2m9zpYayLSatovgLWa9hZgraZ9CFirac8C1mra32C1mj4DhNZK5JtMH/ZBayXyTaaP76C1Evkm0wdy0FqJfJPpIzZorUS+yfShGbRWIt9k+hgMWiuRbzJ9sAWtlcg3mT6qgtZK5JtMHz5BayXyTaaPk6C1LrNf9/P9wYP9jG2ty+zXG1qX+T6cwvvFKXzx3/Ay34dvaF3m+3Bfq+m2dbTWZfLrDa3L5NcbWpfZrym/f2c11fbvrJpuLUdrXSa/3tC6TH69oXUd39TXuo5v6mtdxzd1tZpux0ZrXcc39bWu45v6Wp36pmv+5Hx+p/7mmt+pZ7nmd+pDrvmdeotrfst+oezvC1K5HKHzvbb/OWjTTcJorZb9AlqrZb+A1mrZL6C1JiKtln3I97R2P/NtujUXrdWyv0FrteyF0FrX8U1drabbZ9Fa3fimtp833fp6Z343/uaL+ZPh+Wu65v/pEtjn+S37kDvzW/YWd+a37BfuzG/ZA9yZ3/Je78+fTXeG3pnf8v69M7/l/XtnftP793yPkc+t1+Yccnk//Qyvl3969f6h1vK2xqs1/YwBrtb0Uwa4WtPPGeBqTT9pgKs1/awBrdZ00yderennDXC1pp9OwNVSeSnTTaJ4tVReynRLKV4tlZcy3YCKV0vlpUy3q+LVUnkp022seLVUXsp0IyteLZWXMt3KildL5aVMN7Pi1VJ5KdPtrHi1VF7KdEMrXi2VlzLd0opXS+WlTDe14tVSeSnTba14tVReynRjK14tlZcy3dqKV0vlpUw3t+LVUnkp0+2teLVUXsp0gyteLZWXMt3iildL5aUOKi9luqMXrzZRqaXyUgeVlzLdwYxXS+WlTPcww9WabmLGq6XyUqbbmPFqqbyU6UZmvFoqL2W6lRmvlspLmW5mxqul8lKm25nxaqm8lOmGZrxaKi9lutEZr5bKS5lui8arpfJSppuo8WqpvJTt5mq4WiovZbu9Gq6WykvZbrCGq6XyUrZbrOFqqbyU7SZruFoqL2W7zRqulspL2W6/hqul8lKmm7Xxaqm8lOnWbrxaKi9luhEcr5bJSxXTbeN4tUxeqphuMserZfJSZUtUapm8VKHqPS9UveeFqve8UPWeF6re80LVe16oes8LVe95oeo9L1S954Wq97xQ9Z4Xqt7zQtV7Xqh6zwtV73mh6j0vVL3nhar3vFD1nheq3vNC1XteqHrPC1XveaHqPS9UveeFqve8UPWeF6re80LVe16oes8LVe95oeo9L1S954Wq97xQ9Z4Xqt7zQtV7Xqh6zwtV73mh6j0vVL3nhar3vFD1nheq3vNC1XteqHrPC1XveaHqPS9UveeFqve8UPWeF6re80LVe16oes8LVe95oeo9L1S954Wq97xQ9Z4Xqt7zQtV7Xqh6zwtV73mh6j0vVL3nhar3vFD1nheq3vNC1XteqHrPC1XveaHqPS9UveeFqve8UPWeF6re80LVe16oes8LVe95oeo9L1S954Wq97xQ9Z4Xqt7zQtV7Xqh6zwtV73mh6j0vVL3nhar3vFD1nheq3vNC1XteqXrPK1XveaXqPa9Uved1S1RqmbxUpeo9r1S955Wq97xS9Z5Xqt7zStV7Xql6zytV73ml6j2vVL3nlar3vFL1nleq3vNK1XteqXrPK1XveaXqPa9UveeVqve8UvWeV6re80rVe16pes8rVe95peo9r1S955Wq97xS9Z5Xqt7zStV7Xql6zytV73ml6j2vVL3nlar3vFL1nleq3vNK1XteqXrPK1XveaXqPa9UveeVqve8UvWeV6re80rVe16pes8rVe95peo9r1S955Wq97xS9Z5Xqt7zStV7Xql6zytV73ml6j2vVL3nlar3vFL1nleq3vNK1XteqXrPK1XveaXqPa9UveeVqve8UvWe13XaomsMP15c489/86V1mf3T17pOm/Drx9BvrZ+n+Kx1me9PN7Qu893phtZEpHWZlHdDq9OMd83vdGde81veg+dZf7y4bKG257ecrG7Mb7qL9878lr3Fnfkt+4U781v2AHfmt7zX78xveVffmd/y/r0zv+X9e2d+5/vXdNtrf/7TdH/rmfI1//Hz/I0nPOFj6LjtH6/O5UOt6W0NV2t6t8PVmnYCcLWJSq1plwFXa9qTwNWadjBwtab9DlytaXeEVmu6vxWvlspLme5vxaul8lKm+1vxaqm8lOn+VrxaKi9lur8Vr5bKS5nub8WrpfJSpvtb8WqpvJTp/la8WiovZbq/Fa+WykuZ7m/Fq6XyUqb7W/Fql9lA3d9sPk13XqK1LvMdqvtboafpTkSwVtONiGity+S8G1qXSXk3tDrNeNf8TnfmNb/hPVhCeY9RYjja8xtOVrfmN5yVbs1v2Fvcmt+wX7gzv+Umv1vzG97rt+Y3vKtvzW94/96a3/D+vTW/8/1rubXu1vym9+/2MX/+ef7GE55UtvfQx09qw4da09sartb0bkertdxD9wvUmvYNcLWmXQZcrWlPAleb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p7e8a/vTm9613elN79ru9KZ3bXd607u2O73pXdubPpvetd3pXe/a7HrXZte7dnpnOXZ617s2u9612fWuza53bXa9a4vrXVtc79rietcW17t2em83dnrXu7a43rXF9a4trndtcb1rq+tdW13v2up611bXu3Z6ZzB2ete7trretdX1rq2ud211vWsRPZ8hvqcPRwFO3//dKEQb54PTJ9fTH66nz66nL66nr66nPx1PnxC9iA9OH1xP73nXps3wru3+NmnaDO/aG9Mb3rU3pje8a29Mb3jXdn+jMW2Gd+2N6Q3v2v70wfCuvTG94V17Y3rDu/bG9JZ3be+ZQkJ0hT04veVd25/e8q7tT29613anN71ru9Ob3rW96aPpXdud3vSu7U5vetd2p3e9axE9RQ9O73rXRte7NrretdH1ro2ud+3uetfurnft7nrX7q53LaK76MHpXe/a3fWu3V3v2t31rt1d79rketcm17s2ud61yfWuRXQXPTi9612bXO/a5HrXJte7NrnetYfrXXu43rWA/pztGihudQdO3//dKEB/zpPTZ9fTF9fTV9fTn56nB/TnPDl9cD19dD397np617s2G961/d8mzYZ37Y3pDe/aG9Mb3rU3pje8a/u/0VgM79ob0xvetTemN7xrb0xveNfemN7wrr0xveVd232mUCzv2v70lndtf3rLu7Y/veld25u+mt613elN79ru9KZ3bXd607u2O73pXdud3vWura53bXW9a6vrXVtd79rT9a49Xe/a0/WuPV3vWkB30ZPTu961p+tde7retafrXXt63rXH5nnXHpvnXXtsnnftsXnetcfmedcem+dde2yed+2xed61x+Z51x6b610bXO/a4HrXBte7Nvjcta//6//90//6tz/9n//+r//5+hN/+3/+P3/+H3/5t//484//8y//3//8+//nr/8/" }, { "name": "main", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "target", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "target": [{ "start": 33, "end": 34 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472] }, "bytecode": "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", "debug_symbols": "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rQ10GhsI0Y+CHShYGyhaG2i3NlCaPBDw407pODwPnz0PXzwPXz0PfzoePm+ehw+eh4+eh989D+95w2bPGzZ73rDZ84bNnjds9rxhi+cNWzxv2OJ5wxbPGxbRN/Lc8J43bPG8YYvnDVs8b9jiecNWzxu2et6w1fOGrZ43LKJj57nhPW/Y6nnDVs8btnresNXzhj09b9jT84Y9PW/Y0/OGRXTsPDe85w17et6wp+cNe3resKfjDXtsjjfssTnesMfmeMMem+MNe2yON+yxOd6wx+Z4wx6b4w17bI437LF53rDB84YNnjds8Lxhg+cNi2jHeW54zxs2eN6wwfOGDZ43bPC8YaPnDRs9b9joecNGzxsW0YTz3PCeN2z0vGGj5w0bPW/Y6HnD7p437O55w+6eN+zuecMiWm+eG97zht09b9jd84bdPW/Y3fOGTZ43bPK8YZPnDZs8b1hE389zw3vesMnzhk2eN2zyvGGT5w17eN6wh+cNe3jesIfnDeu50+nw3Ol0eO50Ojx3Oh2eO50Oz51Oh+dOp8Nzp9PhudPp8NzpdHjudDo8dzodnjudDs+dTofnTqfDc6fT4bnT6fDc6XR47nQ6PHc6HZ47nQ7PnU6H506nw3On0+G50+nw3Ol0eO50Ojx3Oh2eO50Oz51Oh+dOp8Nzp9PhudPp8NzpdHjudDo8dzodnjudDs+dTofnTqfDc6fT4bnT6fDc6XR47nQ6PHc6HZ47nQ7PnU7Zc6dT9tzplD13OmXPnU55c7xhs+dOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nTKnjudsudOp+y50yl77nQqnjudiudOp+K506l47nQqm+MNWzx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT8dzpVDx3OhXPnU7Fc6dT9dzpVD13OlXPnU7Vc6dT3Rxv2Oq506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudqudOp+q506l67nSqnjudTs+dTqfnTqfTc6fT6bnT6dwcb9jTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTmHzXOr0mt7xjn1N73jJvqZ3vGVf0ztes6/pHe/Z1/SOF+1reseb9jW941X7mt71rvVc7/Sa3vWu9Vzw9Jre9a71XPH0mt71rvVc8vSa3vWu9Vzz9Jre9a71XPT0ms31rvVc9fSazfWu9Vz29JrN9a71XPf0ms31rvVc+PSazfWu9Vz59Jre9a71XPr0mt71rvVc+/Sa3vWu9Vz89Jre9a71XP30mt71rvVc/vSa3vWu9Vz/9Jre9a71XAD1mt71rvVcAfWa3vWu9VwC9Zre9a71XAP1mt71rvVcBPWa3vWu9VwF9Zre9a71XAb1mt71rvVcB/Wa3vWu9VwI9Zre9a71XAn1mt71rvVcCvWa3vWu9VwL9Zre9a71XAz1mt71rvVcDfWa3vWu9VwO9Zre9a71XA/1mt71rvVcEPWa3vWu9VwR9Zre9a71XBL1mt71rvVcE/Wa3vWu9VwU9Zre9a71XBX1mt71rvVcFvWa3vWu9VwX9Zre9a71XBj1mt71rvVcGfWa3vWu9Vwa9Zre9a71XBv1mt7zrg2ue6OC696o4Lo3KrjujQqb510bXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1Rw3RsVXPdGBde9UcF1b1R03RsVXfdGRde9UdF1b1TcPO/a6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6Oi696o6Lo3KrrujYque6N2171Ru+veqN11b9Tuujdq3zzv2t11b9Tuujdqd90btVvuLtrP8OO1+/nF9Ia/39+Y3vD3nBTSj9emcLSnN/w958b0hr/n3Jje8PecG9Mb9vc3pjfs7/vTW+7PSfl4T19De3rD3+9vTG/Y39+Y3rC/vzG95V3bn97yru1Pb3nX9qe3vGv701vetf3pLe/a7vSW+3NuTO9611ruz7kxvetda7k/58b0rnetnf6cayIz+/OaaPZO/PIp3O9fex77j9eedW9Pf3qefnrPzTemz+l4x+ecSvl49fnH3ovTW3Ge1Bp9ar3m353Pn5zPfzifPzufvzif3/BOvzW/4a1+Z/7D6V6/5ne6q6/5ne/fw/n+nd6tg57f+f49LO/fY3/Honx0vXY+juvFuem1D8u7Gq3V8l5Ha7XsAcBas2W/gNZq2VugtVr2IWitlj0LWmsi0mrZC31PK/R3RfM6HgvLZR0/huWyjnfDclnH50G5lHU8IZbL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q+/Mb3n/3pnf8v69Mb/pDtY78zvfv6a7UlOs1/w5/PUfe+09hLfaPeyfX71/qDW9reFqTe92uFrTTgCu1rRvgKs17TLgak17Erha0w4GrdZ0dyperWl3BFdL5aVMN6ji1SYqtVReynSPKl4tlZcy3aWKV8vkpaLpPlW8WiYvFU13quLVMnmpuCUqtUxeKpruVsWrZfJS0XS/Kl4tlZcy3bGKV0vlpUz3rOLVUnkp012reLVUXsp03ypeLZWXMt25ildL5aVM967i1VJ5KdPdq3i1VF7KdP8qXi2VlzLdwYpXS+WlTPew4tVSeSnTXax4tVReynQfK14tlZcy3cmKV0vlpUz3suLVUnkp092seLVUXsp0PyteLZWXMt3RildL5aVM97Ti1VJ5KdNdrXi1VF7KdF8rXi2VlzLd2YpXS+WlTPe24tVSeSnT3a14tVRe6qDyUgeVlzqovJTpJmK4WtNdxHi1VF4qU3kp003TeLWJSi2VlzLdN41XS+WlTHdO49VSeSnbfdZwtVReynZXNlwtlZey3cMNV0vlpWx3fMPVUnkp2/3hcLVUXsp2NzlcLZWXouo9j1S955Gq9zxS9Z5Hqt7zSNV7Hql6zyNV73mk6j2PVL3nkar3PFL1nkeq3vNI1XseqXrPI1XveaTqPY9Uvec7Ve/5TtV7vlP1nu9Uvef7lqjUMnmpnar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes93qt7znar3fKfqPd+pes/3ddqiaww/Xlzjz3/zpXWZ/XND6zLfoWpKb62fp/isdZnvTze0LvPd6YbWZXJeV2tap0X4hlanGe+a3+nOvOa3vAfz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/vSH4V17Y3rLu7b7TOGwvGv701vetf3pLe/a/vSmd213etO7tju96V3bnd70ru1Ob3rX9qbPpndtd3rXuza73rXZ9a6d3lmOnd71rs2ud212vWuz612bXe/a4nrXFte7trjetcX1rp3e242d3vWuLa53bXG9a4vrXVtc79rqetdW17u2ut611fWund4ZjJ3e9a6trndtdb1rq+tdW13vWkTPZ4jv6cNRgNP3fzcK0cb54PTJ9fSH6+mz6+mL6+mr6+lPx9MnRC/ig9MH19N73rVpM7xru79NmjbDu/bG9IZ37Y3pDe/aG9Mb3rXd32hMm+Fde2N6w7u2P30wvGtvTG94196Y3vCuvTG95V3be6aQEF1hD05vedf2p7e8a/vTm9613elN79ru9KZ3bW/6aHrXdqc3vWu705vetd3pXe9aRE/Rg9O73rXR9a6NrndtdL1ro+tdu7vetbvrXbu73rW7612L6C56cHrXu3Z3vWt317t2d71rd9e7Nrnetcn1rk2ud21yvWsR3UUPTu961ybXuza53rXJ9a5Nrnft4XrXHq53LaA/Z7sGilvdgdP3fzcK0J/z5PTZ9fTF9fTV9fSn5+kB/TlPTh9cTx9dT7+7nt71rs2Gd23/t0mz4V17Y3rDu/bG9IZ37Y3pDe/a/m80FsO79sb0hnftjekN79ob0xvetTemN7xrb0xvedd2nykUy7u2P73lXduf3vKu7U9vetf2pq+md213etO7tju96V3bnd70ru1Ob3rXdqd3vWur611bXe/a6nrXVte79nS9a0/Xu/Z0vWtP17sW0F305PSud+3peteernft6XrXnp537bF53rXH5nnXHpvnXXtsnnftsXnetcfmedcem+dde2yed+2xed61x+Z61wbXuza43rXB9a4NPnft6//6//70P//1T//Xv/3Lf7z+xN/+n//vn//7X/713//84//8y///P/7r//PX/wU=" }, { "name": "pubCallOpenFn", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "target", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 37 }], "target": [{ "start": 37, "end": 38 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239] }, "bytecode": "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", "debug_symbols": "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OYMwzxmEec4gzHMGYZ4zCPOcQZjnDMI8ZxDmOYMwzxmEec4gzHMGYZ4zCPOcQZjnDMI8ZxDmOYMwzxmEec4gzHMGYZ4zCPOcQZjnDMI8ZxDmOYMwzxmEec4gzHMGYZ4zCPOcQZjnDMI8ZxDmOYMwzxmEec4gzHMGYZ4zCPOcQZjnDMI8ZxDmOYMwzxmEec4gzHMGYZ4zCPOcQZjnDMI8ZxDmOYMwzxmEec4gzHMGYZ4zCPOcQZjnDMI8ZxDmOYMwzxmEec4gzHMGYZ4zCPOcQZjnDMI8ZxDmOYMwzxmEec4gzHMGYZ4zCPOcQZjnDMI8ZxLmOZMwz5mEec4kzHPmxafjSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ4zCfOcSZjnTMI8ZxLmOZMwz5mEec4kzHMmYZ6zCPOcRZjnLMI8ZxHmOevi0/EizHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6zCPOcRZjnLMI8ZxHmOYswz1mEec4izHMWYZ6z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" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "H4sIAAAAAAAA/+2YzW6DMAyATYECBbq/bmXrJnHcsUg99MhD7AWqDmm9tFNhe/xpuIuFoesuMwdLtRQlhBB/dkKwmQGABT9i18WFY6H7uann/5NMcK55n5yWEs6BEk5bkBPZJtDvPnV68Ks0o6uAcaiA0VPA6CtgDBQwjhQwhgoYIwWMsQLGsQLGCwWMlwoYrxQwXitgvFHAOFHAeKuA8U4B41SQ0WKMjmkndbmvy0NdZnVZmn4fGsmlGBbZGmN2Up5AWzA2GdCF0/TZxM36iH/A+ugfg+00NgzFbZgvcF5Pel6TKyTM/468/5c+85Mge18+OexZ2ouU75Eel/kqMG3BfysZ122ZEjCdYNaI2lM2lsaRP2hfE3sEzd4M/njO6TwXszHDX+zPQdZ+r8PjdZhdYwsKxkmJ0/ilyyb53wvnHcnP21pzt7MmpI+v+ZOpL0xfJL8OixDa5zHZzCVn7Yj5PpTnyXqy87CmsZnrC2TPkHHHV37HVzEbEzP/jXvwn8X00tx0TfrOzGfmU8whtN9x6uP3qR50bOHxFI0P4Pg8ETWIFPKAzzJweA8PVDxs8YPmQfPRGDFjaRHwoMUPDSa8mFBiwoYJESYcGNBPmY5TQS4PhEkeTf1s6pe3TZmud9tqv1pX6euuKNPtrko/yiJ9328+V1WB10UJ3zr8F0fqGgAA", "debug_symbols": "nZBLCoAgFEX38sYSEX3MrUSDlxkIoqIWhLj3lGgBObsfzuREUIZjkEZ7YBHapuuBLRG8RV0GH9AFYB0dCAi95zS3icAhlch5omklBRpqoLEGmmog+hPK7UIncVOiaCnnqflnKddw2/dJDw==" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "77": { "source": "use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_non_existent_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL>,\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_non_existent_read_requests: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_non_existent_read_requests: self.nullifier_non_existent_read_requests.storage,\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address,\n            reverted: false\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_non_existent_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_non_existent_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let side_effect_counter = self.side_effect_counter;\n        // TODO get next value from output of `call_public_function_internal`\n        self.side_effect_counter += 1;\n\n        call_public_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "94": { "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr" }, "98": { "source": "use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr" }, "99": { "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, \n    address::AztecAddress, \n    constants::ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr" }, "105": { "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, constants::RETURN_VALUES_LENGTH};\n\n#[oracle(callPublicFunction)]\nfn call_public_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; RETURN_VALUES_LENGTH] {}\n\nunconstrained pub fn call_public_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; RETURN_VALUES_LENGTH] {\n    call_public_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/public_call.nr" }, "130": { "source": "use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{\n    GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, NUM_FIELDS_PER_SHA256, STATE_REFERENCE_LENGTH,\n    CONTENT_COMMITMENT_LENGTH\n},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::{arr_copy_slice}, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr" }, "132": { "source": "struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr" }, "144": { "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "150": { "source": "use crate::{address::EthAddress, constants::L2_TO_L1_MESSAGE_LENGTH, traits::{Deserialize, Empty, Serialize}};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "155": { "source": "use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Hash, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial: PartialStateReference = dep::std::unsafe::zeroed();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr" }, "163": { "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize}\n};\n\nstruct FunctionData {\n    // First four bytes of the abi encoding \n    // of a function. \n    selector : FunctionSelector,\n    is_internal : bool,\n    is_private : bool,\n    is_constructor : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        self.is_internal == other.is_internal &\n        self.is_private == other.is_private &\n        self.is_constructor == other.is_constructor\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_internal: serialized[1] as bool,\n            is_private: serialized[2] as bool,\n            is_constructor: serialized[3] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty item hash\" test\n    assert_eq(hash, 0x200569267c0f73ac89aaa414239398db9445dd4ad3a8cf37015cd55b8d4c5e8d);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr" }, "167": { "source": "use crate::{\n    abis::side_effect::{OrderedValue, ContractScopedOrderedValue},\n    traits::{Empty, Serialize, Deserialize}, address::AztecAddress\n};\nuse dep::std::cmp::Eq;\n\nglobal READ_REQUEST_SERIALIZED_LEN = 2;\nglobal READ_REQUEST_CONTEXT_SERIALIZED_LEN = 3;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl OrderedValue<Field> for ReadRequest {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_SERIALIZED_LEN> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_SERIALIZED_LEN] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_SERIALIZED_LEN> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> ReadRequestContext {\n        ReadRequestContext { value: self.value, counter: self.counter, contract_address }\n    }\n}\n\nstruct ReadRequestContext {\n    value: Field,\n    counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl OrderedValue<Field> for ReadRequestContext {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl ContractScopedOrderedValue<Field> for ReadRequestContext {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ReadRequestContext {\n    fn eq(self, read_request: ReadRequestContext) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n        & (self.contract_address.eq(read_request.contract_address))\n    }\n}\n\nimpl Empty for ReadRequestContext {\n    fn empty() -> Self {\n        ReadRequestContext {\n            value: 0,\n            counter: 0,\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_CONTEXT_SERIALIZED_LEN> for ReadRequestContext {\n    fn serialize(self) -> [Field; READ_REQUEST_CONTEXT_SERIALIZED_LEN] {\n        [self.value, self.counter as Field, self.contract_address.to_field()]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_CONTEXT_SERIALIZED_LEN> for ReadRequestContext {\n    fn deserialize(values: [Field; READ_REQUEST_CONTEXT_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            contract_address: AztecAddress::from_field(values[2]),\n        }\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr" }, "168": { "source": "use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, abis::side_effect::Ordered\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    portal_contract_address : EthAddress,\n\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        assert(self.msg_sender.to_field() == 0);\n        assert(self.storage_contract_address.to_field() == 0);\n        assert(self.portal_contract_address.to_field() == 0);\n        assert(self.function_selector.to_field() == 0);\n        assert(self.is_delegate_call == false);\n        assert(self.is_static_call == false);\n        assert(self.side_effect_counter == 0);\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, call_context: CallContext) -> bool {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        call_context.msg_sender.eq(self.msg_sender)\n            & call_context.storage_contract_address.eq(self.storage_contract_address)\n            & call_context.portal_contract_address.eq(self.portal_contract_address)\n            & call_context.function_selector.eq(self.function_selector)\n            & (call_context.is_delegate_call == self.is_delegate_call)\n            & (call_context.is_static_call == self.is_static_call)\n            & (call_context.side_effect_counter == self.side_effect_counter)\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender.to_field(),\n            self.storage_contract_address.to_field(),\n            self.portal_contract_address.to_field(),\n            self.function_selector.to_field(),\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.side_effect_counter as Field,\n        ]\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        CallContext {\n            msg_sender: AztecAddress::from_field(serialized[0]),\n            storage_contract_address: AztecAddress::from_field(serialized[1]),\n            portal_contract_address: EthAddress::from_field(serialized[2]),\n            function_selector: FunctionSelector::from_field(serialized[3]),\n            is_delegate_call: serialized[4] as bool,\n            is_static_call: serialized[5] as bool,\n            side_effect_counter: serialized[6] as u32,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let _hashed = context.hash();\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr" }, "182": { "source": "use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item: PrivateCallStackItem = dep::std::unsafe::zeroed();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item: PrivateCallStackItem = dep::std::unsafe::zeroed();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x19196a5f02621a64ce289fb09fada7fd650a6874cb63e7d10c0d9a9bf5a366f5;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr" }, "183": { "source": "use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem, side_effect::SideEffect\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_internal: false, is_private: false, is_constructor: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0xedd2f10c0cdf776ee2fff3c799bae6df5771f5013a2d5d7154601dffdcf869;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_internal: false, is_private: false, is_constructor: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x1cec0b51f9394405a626c3b77081c96f1bdcb8bacf96960ae4749068f9b4da0d;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr" }, "185": { "source": "use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_field(value: Field) -> Self {\n        Self { inner: value as u32 }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr" }, "188": { "source": "use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : Field,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n}\n// docs:end:global-variables\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        [\n            self.chain_id,\n            self.version,\n            self.block_number,\n            self.timestamp,\n            self.coinbase.to_field(),\n            self.fee_recipient.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        GlobalVariables {\n            chain_id: serialized[0],\n            version: serialized[1],\n            block_number: serialized[2],\n            timestamp: serialized[3],\n            coinbase: EthAddress::from_field(serialized[4]),\n            fee_recipient: AztecAddress::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient)\n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars: GlobalVariables = dep::std::unsafe::zeroed();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr" }, "191": { "source": "use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    constants::{NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH, NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, grumpkin_point::GrumpkinPoint,\n    grumpkin_private_key::GrumpkinPrivateKey\n};\n\nstruct NullifierKeyValidationRequest {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\nimpl Eq for NullifierKeyValidationRequest {\n    fn eq(self, request: NullifierKeyValidationRequest) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequest {\n    fn empty() -> Self {\n        NullifierKeyValidationRequest {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH> for NullifierKeyValidationRequest {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH> for NullifierKeyValidationRequest {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n        }\n    }\n}\n\nimpl NullifierKeyValidationRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> NullifierKeyValidationRequestContext {\n        NullifierKeyValidationRequestContext { public_key: self.public_key, secret_key: self.secret_key, contract_address }\n    }\n}\n\nstruct NullifierKeyValidationRequestContext {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n    contract_address: AztecAddress,\n}\n\nimpl Eq for NullifierKeyValidationRequestContext {\n    fn eq(self, request: NullifierKeyValidationRequestContext) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n            & (request.contract_address.eq(self.contract_address))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequestContext {\n    fn empty() -> Self {\n        NullifierKeyValidationRequestContext {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH> for NullifierKeyValidationRequestContext {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n            self.contract_address.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH> for NullifierKeyValidationRequestContext {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n            contract_address: AztecAddress::from_field(fields[4]),\n        }\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_key_validation_request.nr" }, "192": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, nullifier_key_validation_request::NullifierKeyValidationRequest,\n    read_request::ReadRequest, side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize}, utils::reader::Reader\n};\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    min_revertible_side_effect_counter: u32,\n\n    note_hash_read_requests: [SideEffect; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_key_validation_requests: [NullifierKeyValidationRequest; MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack_hashes: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The following 2 values are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    chain_id: Field,\n    version: Field,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.return_values == other.return_values) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.nullifier_key_validation_requests == other.nullifier_key_validation_requests) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_stack_hashes == other.private_call_stack_hashes) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.encrypted_logs_hash == other.encrypted_logs_hash) &\n        (self.unencrypted_logs_hash == other.unencrypted_logs_hash) &\n        (self.encrypted_log_preimages_length == other.encrypted_log_preimages_length) &\n        (self.unencrypted_log_preimages_length == other.unencrypted_log_preimages_length) &\n        self.historical_header.eq(other.historical_header) &\n        self.chain_id.eq(other.chain_id) &\n        self.version.eq(other.version)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.nullifier_key_validation_requests[i].serialize());\n        }\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL{\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL{\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        fields.extend_from_array(self.private_call_stack_hashes);\n        fields.extend_from_array(self.public_call_stack_hashes);\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        fields.extend_from_array(self.encrypted_logs_hash);\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            note_hash_read_requests: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_key_validation_requests: reader.read_struct_array(NullifierKeyValidationRequest::deserialize, [NullifierKeyValidationRequest::empty(); MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_stack_hashes: reader.read_array([0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            encrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            encrypted_log_preimages_length: reader.read(),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            chain_id: reader.read(),\n            version: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PrivateCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PrivateCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x2b5ba01a6b73b68b4f44196e2dea49afd4076333e2dee8eddc9186e080f18201;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr" }, "193": { "source": "use crate::{\n    address::AztecAddress, constants::{GENERATOR_INDEX__SIDE_EFFECT},\n    traits::{Empty, Hash, Serialize, Deserialize}\n};\nuse dep::std::cmp::Eq;\n\nglobal SIDE_EFFECT_SERIALIZED_LEN = 2;\n\ntrait Ordered {\n    fn counter(self) -> u32;\n}\n\ntrait OrderedValue<T> where T: Eq {\n    fn value(self) -> T;\n    fn counter(self) -> u32;\n}\n\ntrait ContractScopedOrderedValue<T> where T: Eq {\n    fn value(self) -> T;\n    fn counter(self) -> u32;\n    fn contract_address(self) -> AztecAddress;\n}\n\nstruct SideEffect {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffect {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for SideEffect {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffect {\n    fn eq(self, side_effect: SideEffect) -> bool {\n        (self.value == side_effect.value)\n        & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffect {\n    fn empty() -> Self {\n        SideEffect {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffect {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize() , GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<SIDE_EFFECT_SERIALIZED_LEN> for SideEffect {\n    fn serialize(self) -> [Field; SIDE_EFFECT_SERIALIZED_LEN] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<SIDE_EFFECT_SERIALIZED_LEN> for SideEffect {\n    fn deserialize(values: [Field; SIDE_EFFECT_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nstruct SideEffectLinkedToNoteHash{\n    value: Field,\n    note_hash: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffectLinkedToNoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for SideEffectLinkedToNoteHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffectLinkedToNoteHash {\n    fn eq(self, side_effect: SideEffectLinkedToNoteHash) -> bool {\n        (self.value == side_effect.value)\n            & (self.note_hash == side_effect.note_hash) \n            & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffectLinkedToNoteHash {\n    fn empty() -> Self {\n        SideEffectLinkedToNoteHash {\n            value: 0,\n            note_hash: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffectLinkedToNoteHash {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize(),\n        GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<3> for SideEffectLinkedToNoteHash {\n    fn serialize(self) -> [Field; 3] {\n        [self.value, self.note_hash, self.counter as Field]\n    }\n}\n\nimpl Deserialize<3> for SideEffectLinkedToNoteHash {\n    fn deserialize(values: [Field; 3]) -> Self {\n        Self {\n            value: values[0],\n            note_hash: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/side_effect.nr" }, "196": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::AztecAddress,\n    constants::{\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs{\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    prover_address: AztecAddress,\n\n    reverted: bool,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.reverted as Field);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            reverted: reader.read() as bool,\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x083ac560a513d670a7f50f0a3052d42cb9816b7b643e62025b8278652ad637ab;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr" }, "197": { "source": "use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u64 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr" }, "199": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "200": { "source": "use crate::{\n    constants::{NUM_FIELDS_PER_SHA256, CONTENT_COMMITMENT_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::{arr_copy_slice}\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: [Field; NUM_FIELDS_PER_SHA256],\n  in_hash: [Field; NUM_FIELDS_PER_SHA256],\n  out_hash: [Field; NUM_FIELDS_PER_SHA256],\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array([self.tx_tree_height]);\n    fields.extend_from_array(self.txs_effects_hash);\n    fields.extend_from_array(self.in_hash);\n    fields.extend_from_array(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n    let mut offset = 1;\n\n    let txs_effects_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n    offset = offset + NUM_FIELDS_PER_SHA256;\n\n    let in_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n    offset = offset + NUM_FIELDS_PER_SHA256;\n\n    let out_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: [0; NUM_FIELDS_PER_SHA256],\n      in_hash: [0; NUM_FIELDS_PER_SHA256],\n      out_hash: [0; NUM_FIELDS_PER_SHA256],\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr" }, "202": { "source": "global ARGS_LENGTH: u64 = 16;\nglobal RETURN_VALUES_LENGTH: u64 = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_NOTE_HASHES_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX ≥ MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_NOTE_HASHES_PER_TX ≥ MAX_NEW_NOTE_HASHES_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX ≥ MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_CALL: u64 = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: u64 = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: u64 = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: u64 = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: u64 = 16;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_CALL: u64 = 32;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_CALL: u64 = 2; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL: u64 = 2;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: u64 = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 56;\n\nglobal MAX_NEW_NULLIFIERS_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 56;\n\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: u64 = 8;\n\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 8;\nglobal MAX_NON_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 3;\nglobal MAX_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 5;\n\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\n\nglobal MAX_PUBLIC_DATA_READS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\n\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: u64 = 2;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_TX: u64 = 128;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_TX: u64 = 8; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX: u64 = 8;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: u64 = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: u64 = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: u64 = 3;\nglobal FUNCTION_TREE_HEIGHT: u64 = 5;\nglobal NOTE_HASH_TREE_HEIGHT: u64 = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: u64 = 40;\nglobal NULLIFIER_TREE_HEIGHT: u64 = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: u64 = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: u64 = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\nglobal NULLIFIER_TREE_ID = 0;\nglobal NOTE_HASH_TREE_ID = 1;\nglobal PUBLIC_DATA_TREE_ID = 2;\nglobal L1_TO_L2_MESSAGE_TREE_ID = 3;\nglobal ARCHIVE_TREE_ID = 4;\n\n// SUB-TREES RELATED CONSTANTS\nglobal NOTE_HASH_SUBTREE_HEIGHT: u64 = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: u64 = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: u64 = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: u64 = 5;\nglobal ARCHIVE_HEIGHT: u64 = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: u64 = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: u64 = 35;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: u64 = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: u64 = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: u64 = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u64 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u64 = 32;\n// The following is used in immutable state variables to compute an initialization slot whose value is used to\n// determine whether a given variable has been initialized (by asserting that the value in the slot is 0).\n// The initialization slot is computed by adding the constant bellow to the variable's storage slot. This constant has\n// to be large enough so that it's ensured that it doesn't collide with storage slots of other variables.\nglobal INITIALIZATION_SLOT_SEPARATOR: Field = 1000_000_000;\nglobal INITIAL_L2_BLOCK_NUM: Field = 1;\n// 126976 = 31 * 4096;\nglobal BLOB_SIZE_IN_BYTES: Field = 126976;\n\n// CONTRACT CLASS CONSTANTS\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: u64 = 15000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: u64 = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: u64 = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\nglobal DEPLOYER_CONTRACT_ADDRESS = 0x0bffa876f07f9fe1802579dfef599810202f9c25b9a2f58921064a267d1ad1d3;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\nglobal MAX_NOTE_FIELDS_LENGTH: u64 = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: u64 = 23;\nglobal MAX_NOTES_PER_PAGE: u64 = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: u64 = 212;\n\n// LENGTH OF STRUCTS SERIALIZED TO FIELDS\nglobal AZTEC_ADDRESS_LENGTH = 1;\nglobal CALL_CONTEXT_LENGTH: u64 = 7;\nglobal CONTENT_COMMITMENT_LENGTH: u64 = 7;\nglobal CONTRACT_INSTANCE_LENGTH: u64 = 6;\nglobal CONTRACT_STORAGE_READ_LENGTH: u64 = 2;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: u64 = 2;\nglobal ETH_ADDRESS_LENGTH = 1;\nglobal FUNCTION_DATA_LENGTH: u64 = 4;\nglobal FUNCTION_LEAF_PREIMAGE_LENGTH: u64 = 5;\nglobal GLOBAL_VARIABLES_LENGTH: u64 = 6;\nglobal HEADER_LENGTH: u64 = 23; // 2 for last_archive, 7 for content commitment, 8 for state reference, 6 for global vars\nglobal L1_TO_L2_MESSAGE_LENGTH: u64 = 8;\nglobal L2_TO_L1_MESSAGE_LENGTH: u64 = 2;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH = 5;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: u64 = 6;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: u64 = 215;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 210;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 202;\nglobal STATE_REFERENCE_LENGTH: u64 = 8; // 2 for snap + 8 for partial\nglobal TX_CONTEXT_DATA_LENGTH: u64 = 4;\nglobal TX_REQUEST_LENGTH: u64 = 10;\n\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH: Field = 13; // 2 + FUNCTION_DATA_LENGTH + CALL_CONTEXT_LENGTH\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: u64 = 674;\nglobal NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal NUM_MSGS_PER_BASE_PARITY: u64 = 4;\n// NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP / NUM_MSGS_PER_BASE_PARITY\nglobal NUM_BASE_PARITY_PER_ROOT_PARITY: u64 = 4;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n ≤ 8                         | 0 < hash_index ≤ 32  |\n * | MID       | 8 < n ≤ 16                    | 32 < hash_index ≤ 40 |\n * | HIGH      | 16 < n ≤ 48                   | 40 < hash_index ≤ 48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size ≤ 8\nglobal GENERATOR_INDEX__NOTE_HASH = 1;\nglobal GENERATOR_INDEX__NOTE_HASH_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size ≤ 16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size ≤ 44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\nglobal GENERATOR_INDEX__AUTHWIT_INNER = 45;\nglobal GENERATOR_INDEX__AUTHWIT_OUTER = 46;\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/constants.nr" }, "208": { "source": "use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::{arr_copy_slice}\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state: StateReference = dep::std::unsafe::zeroed();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr" }, "209": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "277": { "source": "/* Autogenerated file, do not edit! */\n\nuse dep::std;\nuse dep::aztec::context::{PrivateContext, PublicContext};\nuse dep::aztec::protocol_types::{address::AztecAddress, abis::function_selector::FunctionSelector, constants::RETURN_VALUES_LENGTH};\n\nstruct AStructTestCodeGenStruct {\n  amount: Field,\n  secret_hash: Field,\n}\n\nstruct ADeepStructTestCodeGenStruct {\n  a_field: Field,\n  a_bool: bool,\n  a_note: ANoteADeepStructTestCodeGenStruct,\n  many_notes: [ManyNotesADeepStructTestCodeGenStruct;3],\n}\n\nstruct ANoteADeepStructTestCodeGenStruct {\n  amount: Field,\n  secret_hash: Field,\n}\n\nstruct ManyNotesADeepStructTestCodeGenStruct {\n  amount: Field,\n  secret_hash: Field,\n}\n\nstruct AddressGetPublicKeyStruct {\n  inner: Field,\n}\n\nstruct AztecAddressGetPortalContractAddressStruct {\n  inner: Field,\n}\n\nstruct CancellerConsumeMintPrivateMessageStruct {\n  inner: Field,\n}\n\nstruct ToConsumeMintPublicMessageStruct {\n  inner: Field,\n}\n\nstruct CancellerConsumeMintPublicMessageStruct {\n  inner: Field,\n}\n\n// Interface for calling Test functions from a private context\nstruct TestPrivateContextInterface {\n  address: AztecAddress,\n}\n\nimpl TestPrivateContextInterface {\n    pub fn at(address: AztecAddress) -> Self {\n        Self { address }\n    }\n\n    pub fn test_code_gen(\n        self,\n        context: &mut PrivateContext,\n        a_field: Field,\n        a_bool: bool,\n        a_number: u32,\n        an_array: [Field; 2],\n        a_struct: AStructTestCodeGenStruct,\n        a_deep_struct: ADeepStructTestCodeGenStruct\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 17];\n        serialized_args[0] = a_field;\n        serialized_args[1] = a_bool as Field;\n        serialized_args[2] = a_number as Field;\n        serialized_args[3] = an_array[0];\n        serialized_args[4] = an_array[1];\n        serialized_args[5] = a_struct.amount;\n        serialized_args[6] = a_struct.secret_hash;\n        serialized_args[7] = a_deep_struct.a_field;\n        serialized_args[8] = a_deep_struct.a_bool as Field;\n        serialized_args[9] = a_deep_struct.a_note.amount;\n        serialized_args[10] = a_deep_struct.a_note.secret_hash;\n        serialized_args[11] = a_deep_struct.many_notes[0].amount;\n        serialized_args[12] = a_deep_struct.many_notes[0].secret_hash;\n        serialized_args[13] = a_deep_struct.many_notes[1].amount;\n        serialized_args[14] = a_deep_struct.many_notes[1].secret_hash;\n        serialized_args[15] = a_deep_struct.many_notes[2].amount;\n        serialized_args[16] = a_deep_struct.many_notes[2].secret_hash;\n\n        context.call_private_function(\n            self.address,\n            FunctionSelector::from_field(0x0f054f9b),\n            serialized_args\n        )\n    }\n\n    pub fn get_public_key(\n        self,\n        context: &mut PrivateContext,\n        address: AddressGetPublicKeyStruct\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 1];\n        serialized_args[0] = address.inner;\n\n        context.call_private_function(\n            self.address,\n            FunctionSelector::from_field(0x501e4f48),\n            serialized_args\n        )\n    }\n\n    pub fn create_nullifier_public(self, context: &mut PrivateContext, amount: Field, secret_hash: Field) {\n        let mut serialized_args = [0; 2];\n        serialized_args[0] = amount;\n        serialized_args[1] = secret_hash;\n\n        context.call_public_function(\n            self.address,\n            FunctionSelector::from_field(0xdf02db8d),\n            serialized_args\n        )\n    }\n\n    pub fn emit_msg_sender(self, context: &mut PrivateContext) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 0];\n\n        context.call_private_function(\n            self.address,\n            FunctionSelector::from_field(0x11fb5d45),\n            serialized_args\n        )\n    }\n\n    pub fn get_portal_contract_address(\n        self,\n        context: &mut PrivateContext,\n        aztec_address: AztecAddressGetPortalContractAddressStruct\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 1];\n        serialized_args[0] = aztec_address.inner;\n\n        context.call_private_function(\n            self.address,\n            FunctionSelector::from_field(0x30e5344b),\n            serialized_args\n        )\n    }\n\n    pub fn emit_unencrypted(self, context: &mut PrivateContext, value: Field) {\n        let mut serialized_args = [0; 1];\n        serialized_args[0] = value;\n\n        context.call_public_function(\n            self.address,\n            FunctionSelector::from_field(0x817a64cb),\n            serialized_args\n        )\n    }\n\n    pub fn get_this_portal_address(self, context: &mut PrivateContext) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 0];\n\n        context.call_private_function(\n            self.address,\n            FunctionSelector::from_field(0xc71384f5),\n            serialized_args\n        )\n    }\n\n    pub fn get_this_address(self, context: &mut PrivateContext) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 0];\n\n        context.call_private_function(\n            self.address,\n            FunctionSelector::from_field(0x95a7b2ae),\n            serialized_args\n        )\n    }\n\n    pub fn is_time_equal(self, context: &mut PrivateContext, time: Field) {\n        let mut serialized_args = [0; 1];\n        serialized_args[0] = time;\n\n        context.call_public_function(\n            self.address,\n            FunctionSelector::from_field(0x61fa2bda),\n            serialized_args\n        )\n    }\n\n    pub fn consume_mint_private_message(\n        self,\n        context: &mut PrivateContext,\n        secret_hash_for_redeeming_minted_notes: Field,\n        amount: Field,\n        canceller: CancellerConsumeMintPrivateMessageStruct,\n        secret_for_L1_to_L2_message_consumption: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 4];\n        serialized_args[0] = secret_hash_for_redeeming_minted_notes;\n        serialized_args[1] = amount;\n        serialized_args[2] = canceller.inner;\n        serialized_args[3] = secret_for_L1_to_L2_message_consumption;\n\n        context.call_private_function(\n            self.address,\n            FunctionSelector::from_field(0x260712c7),\n            serialized_args\n        )\n    }\n\n    pub fn emit_nullifier(\n        self,\n        context: &mut PrivateContext,\n        nullifier: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 1];\n        serialized_args[0] = nullifier;\n\n        context.call_private_function(\n            self.address,\n            FunctionSelector::from_field(0x82a8b183),\n            serialized_args\n        )\n    }\n\n    pub fn create_l2_to_l1_message_public(\n        self,\n        context: &mut PrivateContext,\n        amount: Field,\n        secret_hash: Field\n    ) {\n        let mut serialized_args = [0; 2];\n        serialized_args[0] = amount;\n        serialized_args[1] = secret_hash;\n\n        context.call_public_function(\n            self.address,\n            FunctionSelector::from_field(0x9749ca06),\n            serialized_args\n        )\n    }\n\n    pub fn consume_mint_public_message(\n        self,\n        context: &mut PrivateContext,\n        to: ToConsumeMintPublicMessageStruct,\n        amount: Field,\n        canceller: CancellerConsumeMintPublicMessageStruct,\n        secret: Field\n    ) {\n        let mut serialized_args = [0; 4];\n        serialized_args[0] = to.inner;\n        serialized_args[1] = amount;\n        serialized_args[2] = canceller.inner;\n        serialized_args[3] = secret;\n\n        context.call_public_function(\n            self.address,\n            FunctionSelector::from_field(0x04ee3bb0),\n            serialized_args\n        )\n    }\n\n    pub fn set_constant(\n        self,\n        context: &mut PrivateContext,\n        value: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 1];\n        serialized_args[0] = value;\n\n        context.call_private_function(\n            self.address,\n            FunctionSelector::from_field(0x1b3b9e18),\n            serialized_args\n        )\n    }\n}\n\n// Interface for calling Test functions from a public context\nstruct TestPublicContextInterface {\n  address: AztecAddress,\n}\n\nimpl TestPublicContextInterface {\n    pub fn at(address: AztecAddress) -> Self {\n        Self { address }\n    }\n\n    pub fn create_nullifier_public(\n        self,\n        context: &mut PublicContext,\n        amount: Field,\n        secret_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 2];\n        serialized_args[0] = amount;\n        serialized_args[1] = secret_hash;\n\n        context.call_public_function(\n            self.address,\n            FunctionSelector::from_field(0xdf02db8d),\n            serialized_args\n        )\n    }\n\n    pub fn emit_unencrypted(\n        self,\n        context: &mut PublicContext,\n        value: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 1];\n        serialized_args[0] = value;\n\n        context.call_public_function(\n            self.address,\n            FunctionSelector::from_field(0x817a64cb),\n            serialized_args\n        )\n    }\n\n    pub fn is_time_equal(self, context: &mut PublicContext, time: Field) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 1];\n        serialized_args[0] = time;\n\n        context.call_public_function(\n            self.address,\n            FunctionSelector::from_field(0x61fa2bda),\n            serialized_args\n        )\n    }\n\n    pub fn create_l2_to_l1_message_public(\n        self,\n        context: &mut PublicContext,\n        amount: Field,\n        secret_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 2];\n        serialized_args[0] = amount;\n        serialized_args[1] = secret_hash;\n\n        context.call_public_function(\n            self.address,\n            FunctionSelector::from_field(0x9749ca06),\n            serialized_args\n        )\n    }\n\n    pub fn consume_mint_public_message(\n        self,\n        context: &mut PublicContext,\n        to: ToConsumeMintPublicMessageStruct,\n        amount: Field,\n        canceller: CancellerConsumeMintPublicMessageStruct,\n        secret: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut serialized_args = [0; 4];\n        serialized_args[0] = to.inner;\n        serialized_args[1] = amount;\n        serialized_args[2] = canceller.inner;\n        serialized_args[3] = secret;\n\n        context.call_public_function(\n            self.address,\n            FunctionSelector::from_field(0x04ee3bb0),\n            serialized_args\n        )\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/import_test_contract/src/test_contract_interface.nr" }, "278": { "source": "mod test_contract_interface;\n\n// Contract that uses the autogenerated interface of the Test contract for calling its functions.\n// Used for testing calling into other contracts via autogenerated interfaces.\ncontract ImportTest {\n    use dep::aztec::prelude::AztecAddress;\n\n    use crate::test_contract_interface::{\n        TestPrivateContextInterface, TestPublicContextInterface, AStructTestCodeGenStruct,\n        ADeepStructTestCodeGenStruct, ANoteADeepStructTestCodeGenStruct,\n        ManyNotesADeepStructTestCodeGenStruct\n    };\n\n    // Calls the testCodeGen on the Test contract at the target address\n    // Used for testing calling a function with arguments of multiple types\n    // See yarn-project/simulator/src/client/private_execution.ts\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[aztec(private)]\n    fn main(target: AztecAddress) -> Field {\n        let test_contract_instance = TestPrivateContextInterface::at(target);\n        let return_values = test_contract_instance.test_code_gen(\n            &mut context,\n            1,\n            true,\n            1 as u32,\n            [1, 2],\n            AStructTestCodeGenStruct { amount: 1, secret_hash: 2 },\n            ADeepStructTestCodeGenStruct {\n            a_field: 1,\n            a_bool: true,\n            a_note: ANoteADeepStructTestCodeGenStruct { amount: 1, secret_hash: 2 },\n            many_notes: [\n                ManyNotesADeepStructTestCodeGenStruct { amount: 1, secret_hash: 2 },\n                ManyNotesADeepStructTestCodeGenStruct { amount: 1, secret_hash: 2 },\n                ManyNotesADeepStructTestCodeGenStruct { amount: 1, secret_hash: 2 }\n            ]\n        }\n        );\n\n        return_values[0]\n    }\n\n    // Calls the getThisAddress on the Test contract at the target address\n    // Used for testing calling a function with no arguments\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[aztec(private)]\n    fn callNoArgs(target: AztecAddress) -> Field {\n        let test_contract_instance = TestPrivateContextInterface::at(target);\n        let return_values = test_contract_instance.get_this_address(&mut context);\n\n        return_values[0]\n    }\n\n    // Calls the createNullifierPublic on the Test contract at the target address\n    // Used for testing calling an open function\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[aztec(private)]\n    fn callOpenFn(target: AztecAddress) {\n        let test_contract_instance = TestPrivateContextInterface::at(target);\n        test_contract_instance.create_nullifier_public(&mut context, 1, 2);\n    }\n\n    // Calls the createNullifierPublic on the Test contract at the target address\n    // Used for testing calling an open function from another open function\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[aztec(public)]\n    fn pubCallOpenFn(target: AztecAddress) -> Field {\n        let test_contract_instance = TestPublicContextInterface::at(target);\n        let ret = test_contract_instance.create_nullifier_public(&mut context, 1, 2);\n\n        ret[0]\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/import_test_contract/src/main.nr" } } }
