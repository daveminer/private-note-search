{ "noir_version": "0.25.0+589a6cb62caf38445c768429150eee469ae35d77", "name": "Escrow", "functions": [{ "name": "constructor", "is_unconstrained": false, "custom_attributes": ["aztec(private)", "aztec(initializer)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "address_note::aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "address_note::aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "public" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "owner": [{ "start": 33, "end": 34 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275] }, "bytecode": "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", "debug_symbols": "3VnbbhpBDP2XfY7Q2OPLmF+p+kDTVIoUkSihlaqIf+8uMBdgkhG7FQGe0Irj2TNnbI/tfe+enu8Xq8fn5Vs3f+/AdfNv793by2I5PL6tFq+rbu7uuoflz/53fdf9enx66OaouL47wgHbDgkBEjZoBYpoYYdFz5zAYFZBB+PIwRzQHvr7XQdwlazxXKzJY2RNhhNZ+ymsGSQKyOhC5l3donORNzjMmwT2FXS/s7SyZiyFDWu6StZ8laxlkl+TQSTCJZHBFY/36COYNa8Mzm+I6BmJuEwE9ohUVlaiuLIWwYvIFbT5GOgmVmhdY6EcT1wtRy66jRrhjGqEuEFx3FADATXlVLCGGmqRcdBiZZIKVjguHKRgTDwi69ktiCdZvNASD3pykbMHbKAb8qG7UPkcZ/mwJR9YypG9Ie7lvdMlgS+RBPQwS+LEMoSigiCFA9aJQEjuClZqUkW3FJxUiYCkoghEdY/KsDjVFhdMQjI1XuDB8Q7s+2Aq0FvZq3e7SHyBFs5bfwGyJucVkIRmq/puurJxEwufgVvCy/VS18nUBSVRlwZ1CiFe3n3AalmCDWTCJZGx6WTyoapvnVMqgUIoMimEapY2Sw6AuZCFIfEdr6w+OQA3sOBdSJccu70YPdm3vLsRBU0ktQJFcH4gd0MUOKso4FLPA5v2tpBlYINfxgYBj9j487Lpq5rERkLDZYgpVhjEReOxzRaerpc6n5m65RRDvhWolDymH9VQIyFRiKmOfSZtm3bPy81sU1MnoiTlNiupK1ej4IpkRDoidenNKCipglKhzxX8r02OD7fjhIlHcHoYa3bJ22SfakRlaGzTq6XJXjEy5GGbNKmLZ/a1JrTa+X1eqhJcBg+QWX0u5CUeJpVJaDeVlFl9HNK0glFWOMrKn2yFNKverKnyhKICMt4Wh7P6Byc0jjd47+t42DsPdjDSrioHQ54ZFSnP0bZg+OiYKYaht3CYEvijU24YwRgjHGPkTzayWX1qwZ7S8BsPksZgJGOM6revTxNMV47ZZf29f/qzeH1c/Hh6GD5lDn/+Xt7HL5v94+rvy/af9T8=" }, { "name": "withdraw", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "address_note::aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "address_note::aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "token", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "amount", "type": { "kind": "field" }, "visibility": "private" }, { "name": "recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "amount": [{ "start": 34, "end": 35 }], "inputs": [{ "start": 0, "end": 33 }], "recipient": [{ "start": 35, "end": 36 }], "token": [{ "start": 33, "end": 34 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639] }, "bytecode": "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", "debug_symbols": "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nrqS76kr+Z66ku+pK/meupLvqSv5nrqS76kr+Z66ku+pK/meupLvqSv5nrqS76kr+Z66ku+pK/meupLvqSv5nrqS76kr+Z66ku+pK/meupLvqSv5nrqS76kr+Z66ku+pK/meupLvqSv5nrqS76kr+Z66ku+pK/meupLvqSv5nrqS76kr+Z66ku+pK/meupLvqSv5nrqS76kr+Z66ku+pK/meupLvqSv5nrqS76kr+Z66ku+pK/meupLvqSv5nrqS76kr+Z66ku+pK/meupLvqSv5nrqS76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5nrqR76kb+Z66ke+pG/meupHvqRv5trmRb5sb+ba5kW+bG/m22W3bHTGjj7cJ97xNvOdt0j1vk+95G47c1Oj3t3maIPX9beo9b9NueRu33fM2HKnZoR5vEy7ext/zNuGet4n3vE26523yPW9zR3rybxmj97xNu+Vt/HbP27h73sbf8zbhnreJ97xNuudt8j1vc88p4O85Bfw9p0C45xQI95wC4Z5TINxzCoR7ToFwzykQ7jkFwj2nQLjnFAj3nALxnlMg3nMKxHtOgXjPKRDvOQXiPadAvOcUiPecAvGeUyDecwqke06BdM8pkO45BdI9p0C65xRI95wCr/8IPvJgIz74+k/gIw866oMv95/LLn896XIs31Cejwb6o5H+aKI/mumPFvqjlf5oIz/6+g/hY486+qP03VTou6nQd1Oh76ZysZvS/jvnmncXjxb6o5X+aCM/Wjf6o47yaIn/8prR+djzTO7g96cq6anXZNo+CMS7cw+0rwXm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c6Oy6tyorDo3KqvOjcqqc6Oy6tyorDo3KqvOjcqqc6Oy6tyorDo3KqvOjcqqc6Oy6tyorDo3KqvOjcqqc6Oy6tyorDo3KqvOjcqqc6Oy6tyorDo3KqvOjcqqc6Oy6tyorDo3KqvOjcqqc6Oy6tyorDo3KqvOjcqqc6Oy6tyoojo3qqjOjSqqc6OK6tyosmmutUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGFdW5UUV1blRRnRtVVOdGVdW5UVV1blRVnRtVVedG1U1zra2qc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqrOjaqqc6Oq6tyoqjo3qqnOjWqqc6Oa6tyopjo3qm2aa21TnRvV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rWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdjKVi+2stWLrWz1YitbvdrKVq+2stWrrWz1aitbvW7RllxTrqraylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW73aylavtrLVq61s9WorW72uE0ddvft6cfXf/+VT7DJlaEDsOmHFjz9T72KfV/FN7DKH1IjYZY6oEbHRkthlmr4RsUpbvlOA0tp5CpBcD1urXy8um6sXAiQ3WiMCREf9DgmQ7DKGBEh2DkMCJLuBIQGSK/yQAMlVe0iA5Eo8JEByJR4SoL0Siw6THRDQRMfDtpgPAem7gBf3Pu5ctN/C+epcnuSKrtv8ckVXeX65oj0Bv9xoS65ov8EvV7Q74Zcr2svwyxXtfPjlivZJ7HJFx8N+QK4tVyU6HvYDcm25KtHxsB+Qa8tViY6H/YBcW65KdDzsB+TaclWi42E/INeWqxIdD/sBubZcleh42A/IteWqRMfDfkCuLVclOh72A3JtuSrR8bAfkLtMIep/GLqJ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" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "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", "debug_symbols": "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" }], "events": [], "file_map": { "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "30": { "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\n// TODO: add implementations for the remainder of primitive types.\nimpl Hash for Field{\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        let input: [Field] = [self];\n        H::write(state, input);\n    }\n}\n", "path": "std/hash.nr" }, "33": { "source": "// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n", "path": "std/merkle.nr" }, "35": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "59": { "source": "use dep::protocol_types::{address::AztecAddress, constants::{GENERATOR_INDEX__INITIALIZATION_NULLIFIER}, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, Context};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes}, note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateImmutable<Note> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateImmutable<T> {}\n\nimpl<Note> PrivateImmutable<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context: context.private, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor. \n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<N>(self) -> Note where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot)\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N>(self) -> Note  where Note: NoteInterface<N> {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr" }, "71": { "source": "use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::{PrivateContext, ContextInterface},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\nfn _nullifier_inclusion(nullifier: Field, header: Header) {\n    // 1) Get the membership witness of the nullifier\n    let witness = get_nullifier_membership_witness(header.global_variables.block_number as u32, nullifier);\n\n    // 2) Check that the witness we obtained matches the nullifier\n    assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n    // 3) Compute the nullifier tree leaf\n    let nullifier_leaf = witness.leaf_preimage.hash();\n\n    // 4) Prove that the nullifier is in the nullifier tree\n    assert(\n        header.state.partial.nullifier_tree.root\n        == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n    );\n    // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n    //     was included in the nullifier tree.\n}\n\npub fn prove_nullifier_inclusion<TContext>(\n    nullifier: Field,\n    context: TContext\n) where TContext: ContextInterface {\n    _nullifier_inclusion(nullifier, context.get_header());\n}\n\npub fn prove_nullifier_inclusion_at(\n    nullifier: Field,\n    block_number: u32, // The block at which we'll prove that the nullifier exists in the nullifier tree\n    context: PrivateContext\n) {\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n\npub fn prove_note_is_nullified<Note, N>(\n    note: Note,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n\n    _nullifier_inclusion(nullifier, context.historical_header);\n}\n\npub fn prove_note_is_nullified_at<Note, N>(\n    note: Note,\n    block_number: u32,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "85": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/log.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "90": { "source": "use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "94": { "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr" }, "95": { "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/rand.nr" }, "98": { "source": "use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr" }, "100": { "source": "use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nfn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nfn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr" }, "103": { "source": "use dep::protocol_types::{address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr" }, "104": { "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr" }, "106": { "source": "use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr" }, "114": { "source": "use dep::protocol_types::{\n    hash::{silo_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, ContextInterface},\n    oracle::get_contract_instance::get_contract_instance,\n    history::nullifier_inclusion::prove_nullifier_inclusion,\n};\n\npub fn mark_as_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(*context);\n    ContextInterface::push_new_nullifier(context, init_nullifier, 0);\n}\n\npub fn assert_is_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_contract_initialization_nullifier(*context);\n    prove_nullifier_inclusion(init_nullifier, *context);\n}\n\npub fn compute_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    let address = context.this_address();\n    silo_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(context)\n    )\n}\n\npub fn compute_unsiloed_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    context.this_address().to_field()\n}\n\npub fn assert_initialization_args_match_address_preimage<TContext>(context: TContext) where TContext: ContextInterface {\n    let address = context.this_address(); \n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash([init_selector.to_field(), init_args_hash], GENERATOR_INDEX__CONSTRUCTOR)\n}", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr" }, "118": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr" }, "121": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "122": { "source": "use dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note: Note) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index].lt(fields_1[sort.field_index]);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter.nr" }, "130": { "source": "use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{\n    GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, NUM_FIELDS_PER_SHA256, STATE_REFERENCE_LENGTH,\n    CONTENT_COMMITMENT_LENGTH\n},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::{arr_copy_slice}, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr" }, "132": { "source": "struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr" }, "144": { "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr" }, "145": { "source": "use crate::{\n    address::eth_address::EthAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash,\n    traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, portal_contract_address: EthAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            portal_contract_address.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr" }, "146": { "source": "use crate::{\n    address::{eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::ToField\n};\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr" }, "147": { "source": "use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl Eq for PublicKeysHash {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    assert(actual.to_field() == 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/public_keys_hash.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "150": { "source": "use crate::{address::EthAddress, constants::L2_TO_L1_MESSAGE_LENGTH, traits::{Deserialize, Empty, Serialize}};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "155": { "source": "use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Hash, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial: PartialStateReference = dep::std::unsafe::zeroed();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr" }, "163": { "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize}\n};\n\nstruct FunctionData {\n    // First four bytes of the abi encoding \n    // of a function. \n    selector : FunctionSelector,\n    is_internal : bool,\n    is_private : bool,\n    is_constructor : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        self.is_internal == other.is_internal &\n        self.is_private == other.is_private &\n        self.is_constructor == other.is_constructor\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_internal: serialized[1] as bool,\n            is_private: serialized[2] as bool,\n            is_constructor: serialized[3] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty item hash\" test\n    assert_eq(hash, 0x200569267c0f73ac89aaa414239398db9445dd4ad3a8cf37015cd55b8d4c5e8d);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr" }, "167": { "source": "use crate::{\n    abis::side_effect::{OrderedValue, ContractScopedOrderedValue},\n    traits::{Empty, Serialize, Deserialize}, address::AztecAddress\n};\nuse dep::std::cmp::Eq;\n\nglobal READ_REQUEST_SERIALIZED_LEN = 2;\nglobal READ_REQUEST_CONTEXT_SERIALIZED_LEN = 3;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl OrderedValue<Field> for ReadRequest {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_SERIALIZED_LEN> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_SERIALIZED_LEN] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_SERIALIZED_LEN> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> ReadRequestContext {\n        ReadRequestContext { value: self.value, counter: self.counter, contract_address }\n    }\n}\n\nstruct ReadRequestContext {\n    value: Field,\n    counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl OrderedValue<Field> for ReadRequestContext {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl ContractScopedOrderedValue<Field> for ReadRequestContext {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ReadRequestContext {\n    fn eq(self, read_request: ReadRequestContext) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n        & (self.contract_address.eq(read_request.contract_address))\n    }\n}\n\nimpl Empty for ReadRequestContext {\n    fn empty() -> Self {\n        ReadRequestContext {\n            value: 0,\n            counter: 0,\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_CONTEXT_SERIALIZED_LEN> for ReadRequestContext {\n    fn serialize(self) -> [Field; READ_REQUEST_CONTEXT_SERIALIZED_LEN] {\n        [self.value, self.counter as Field, self.contract_address.to_field()]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_CONTEXT_SERIALIZED_LEN> for ReadRequestContext {\n    fn deserialize(values: [Field; READ_REQUEST_CONTEXT_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            contract_address: AztecAddress::from_field(values[2]),\n        }\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr" }, "168": { "source": "use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, abis::side_effect::Ordered\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    portal_contract_address : EthAddress,\n\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        assert(self.msg_sender.to_field() == 0);\n        assert(self.storage_contract_address.to_field() == 0);\n        assert(self.portal_contract_address.to_field() == 0);\n        assert(self.function_selector.to_field() == 0);\n        assert(self.is_delegate_call == false);\n        assert(self.is_static_call == false);\n        assert(self.side_effect_counter == 0);\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, call_context: CallContext) -> bool {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        call_context.msg_sender.eq(self.msg_sender)\n            & call_context.storage_contract_address.eq(self.storage_contract_address)\n            & call_context.portal_contract_address.eq(self.portal_contract_address)\n            & call_context.function_selector.eq(self.function_selector)\n            & (call_context.is_delegate_call == self.is_delegate_call)\n            & (call_context.is_static_call == self.is_static_call)\n            & (call_context.side_effect_counter == self.side_effect_counter)\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender.to_field(),\n            self.storage_contract_address.to_field(),\n            self.portal_contract_address.to_field(),\n            self.function_selector.to_field(),\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.side_effect_counter as Field,\n        ]\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        CallContext {\n            msg_sender: AztecAddress::from_field(serialized[0]),\n            storage_contract_address: AztecAddress::from_field(serialized[1]),\n            portal_contract_address: EthAddress::from_field(serialized[2]),\n            function_selector: FunctionSelector::from_field(serialized[3]),\n            is_delegate_call: serialized[4] as bool,\n            is_static_call: serialized[5] as bool,\n            side_effect_counter: serialized[6] as u32,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let _hashed = context.hash();\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr" }, "182": { "source": "use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item: PrivateCallStackItem = dep::std::unsafe::zeroed();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item: PrivateCallStackItem = dep::std::unsafe::zeroed();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x19196a5f02621a64ce289fb09fada7fd650a6874cb63e7d10c0d9a9bf5a366f5;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr" }, "185": { "source": "use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_field(value: Field) -> Self {\n        Self { inner: value as u32 }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr" }, "188": { "source": "use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : Field,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n}\n// docs:end:global-variables\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        [\n            self.chain_id,\n            self.version,\n            self.block_number,\n            self.timestamp,\n            self.coinbase.to_field(),\n            self.fee_recipient.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        GlobalVariables {\n            chain_id: serialized[0],\n            version: serialized[1],\n            block_number: serialized[2],\n            timestamp: serialized[3],\n            coinbase: EthAddress::from_field(serialized[4]),\n            fee_recipient: AztecAddress::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient)\n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars: GlobalVariables = dep::std::unsafe::zeroed();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr" }, "191": { "source": "use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    constants::{NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH, NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, grumpkin_point::GrumpkinPoint,\n    grumpkin_private_key::GrumpkinPrivateKey\n};\n\nstruct NullifierKeyValidationRequest {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\nimpl Eq for NullifierKeyValidationRequest {\n    fn eq(self, request: NullifierKeyValidationRequest) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequest {\n    fn empty() -> Self {\n        NullifierKeyValidationRequest {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH> for NullifierKeyValidationRequest {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH> for NullifierKeyValidationRequest {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n        }\n    }\n}\n\nimpl NullifierKeyValidationRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> NullifierKeyValidationRequestContext {\n        NullifierKeyValidationRequestContext { public_key: self.public_key, secret_key: self.secret_key, contract_address }\n    }\n}\n\nstruct NullifierKeyValidationRequestContext {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n    contract_address: AztecAddress,\n}\n\nimpl Eq for NullifierKeyValidationRequestContext {\n    fn eq(self, request: NullifierKeyValidationRequestContext) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n            & (request.contract_address.eq(self.contract_address))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequestContext {\n    fn empty() -> Self {\n        NullifierKeyValidationRequestContext {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH> for NullifierKeyValidationRequestContext {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n            self.contract_address.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH> for NullifierKeyValidationRequestContext {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n            contract_address: AztecAddress::from_field(fields[4]),\n        }\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_key_validation_request.nr" }, "192": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, nullifier_key_validation_request::NullifierKeyValidationRequest,\n    read_request::ReadRequest, side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize}, utils::reader::Reader\n};\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    min_revertible_side_effect_counter: u32,\n\n    note_hash_read_requests: [SideEffect; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_key_validation_requests: [NullifierKeyValidationRequest; MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack_hashes: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The following 2 values are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    chain_id: Field,\n    version: Field,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.return_values == other.return_values) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.nullifier_key_validation_requests == other.nullifier_key_validation_requests) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_stack_hashes == other.private_call_stack_hashes) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.encrypted_logs_hash == other.encrypted_logs_hash) &\n        (self.unencrypted_logs_hash == other.unencrypted_logs_hash) &\n        (self.encrypted_log_preimages_length == other.encrypted_log_preimages_length) &\n        (self.unencrypted_log_preimages_length == other.unencrypted_log_preimages_length) &\n        self.historical_header.eq(other.historical_header) &\n        self.chain_id.eq(other.chain_id) &\n        self.version.eq(other.version)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.nullifier_key_validation_requests[i].serialize());\n        }\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL{\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL{\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        fields.extend_from_array(self.private_call_stack_hashes);\n        fields.extend_from_array(self.public_call_stack_hashes);\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        fields.extend_from_array(self.encrypted_logs_hash);\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            note_hash_read_requests: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_key_validation_requests: reader.read_struct_array(NullifierKeyValidationRequest::deserialize, [NullifierKeyValidationRequest::empty(); MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_stack_hashes: reader.read_array([0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            encrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            encrypted_log_preimages_length: reader.read(),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            chain_id: reader.read(),\n            version: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PrivateCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PrivateCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x2b5ba01a6b73b68b4f44196e2dea49afd4076333e2dee8eddc9186e080f18201;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr" }, "193": { "source": "use crate::{\n    address::AztecAddress, constants::{GENERATOR_INDEX__SIDE_EFFECT},\n    traits::{Empty, Hash, Serialize, Deserialize}\n};\nuse dep::std::cmp::Eq;\n\nglobal SIDE_EFFECT_SERIALIZED_LEN = 2;\n\ntrait Ordered {\n    fn counter(self) -> u32;\n}\n\ntrait OrderedValue<T> where T: Eq {\n    fn value(self) -> T;\n    fn counter(self) -> u32;\n}\n\ntrait ContractScopedOrderedValue<T> where T: Eq {\n    fn value(self) -> T;\n    fn counter(self) -> u32;\n    fn contract_address(self) -> AztecAddress;\n}\n\nstruct SideEffect {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffect {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for SideEffect {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffect {\n    fn eq(self, side_effect: SideEffect) -> bool {\n        (self.value == side_effect.value)\n        & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffect {\n    fn empty() -> Self {\n        SideEffect {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffect {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize() , GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<SIDE_EFFECT_SERIALIZED_LEN> for SideEffect {\n    fn serialize(self) -> [Field; SIDE_EFFECT_SERIALIZED_LEN] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<SIDE_EFFECT_SERIALIZED_LEN> for SideEffect {\n    fn deserialize(values: [Field; SIDE_EFFECT_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nstruct SideEffectLinkedToNoteHash{\n    value: Field,\n    note_hash: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffectLinkedToNoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for SideEffectLinkedToNoteHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffectLinkedToNoteHash {\n    fn eq(self, side_effect: SideEffectLinkedToNoteHash) -> bool {\n        (self.value == side_effect.value)\n            & (self.note_hash == side_effect.note_hash) \n            & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffectLinkedToNoteHash {\n    fn empty() -> Self {\n        SideEffectLinkedToNoteHash {\n            value: 0,\n            note_hash: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffectLinkedToNoteHash {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize(),\n        GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<3> for SideEffectLinkedToNoteHash {\n    fn serialize(self) -> [Field; 3] {\n        [self.value, self.note_hash, self.counter as Field]\n    }\n}\n\nimpl Deserialize<3> for SideEffectLinkedToNoteHash {\n    fn deserialize(values: [Field; 3]) -> Self {\n        Self {\n            value: values[0],\n            note_hash: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/side_effect.nr" }, "194": { "source": "global NULLIFIER_LEAF_PREIMAGE_LENGTH: u64 = 3;\n\nuse crate::{merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u64,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u64 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr" }, "197": { "source": "use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u64 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr" }, "199": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "200": { "source": "use crate::{\n    constants::{NUM_FIELDS_PER_SHA256, CONTENT_COMMITMENT_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::{arr_copy_slice}\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: [Field; NUM_FIELDS_PER_SHA256],\n  in_hash: [Field; NUM_FIELDS_PER_SHA256],\n  out_hash: [Field; NUM_FIELDS_PER_SHA256],\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array([self.tx_tree_height]);\n    fields.extend_from_array(self.txs_effects_hash);\n    fields.extend_from_array(self.in_hash);\n    fields.extend_from_array(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n    let mut offset = 1;\n\n    let txs_effects_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n    offset = offset + NUM_FIELDS_PER_SHA256;\n\n    let in_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n    offset = offset + NUM_FIELDS_PER_SHA256;\n\n    let out_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: [0; NUM_FIELDS_PER_SHA256],\n      in_hash: [0; NUM_FIELDS_PER_SHA256],\n      out_hash: [0; NUM_FIELDS_PER_SHA256],\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr" }, "208": { "source": "use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::{arr_copy_slice}\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state: StateReference = dep::std::unsafe::zeroed();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr" }, "209": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "225": { "source": "use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    portal_contract_address : EthAddress,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt) &\n        self.portal_contract_address.eq(other.portal_contract_address)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.portal_contract_address.to_field(),\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            portal_contract_address: EthAddress::from_field(serialized[4]),\n            public_keys_hash: PublicKeysHash::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.portal_contract_address\n            )\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr" }, "272": { "source": "// Sample escrow contract that stores a balance of a private token on behalf of an owner.\ncontract Escrow {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, FunctionSelector, NoteHeader, PrivateContext, PrivateImmutable};\n\n    use dep::aztec::{context::{PublicContext, Context}, oracle::get_public_key::get_public_key};\n\n    use dep::address_note::address_note::{AddressNote, ADDRESS_NOTE_LEN};\n\n    struct Storage {\n        owner: PrivateImmutable<AddressNote>,\n    }\n\n    // Creates a new instance\n    #[aztec(private)]\n    #[aztec(initializer)]\n    fn constructor(owner: pub AztecAddress) {\n        let mut note = AddressNote::new(owner, owner);\n        storage.owner.initialize(&mut note, true);\n    }\n\n    // Withdraws balance. Requires that msg.sender is the owner.\n    #[aztec(private)]\n    fn withdraw(token: AztecAddress, amount: Field, recipient: AztecAddress) {\n        let this = context.this_address();\n        let sender = context.msg_sender();\n\n        let note = storage.owner.get_note();\n        assert(note.address == sender);\n\n        let selector = FunctionSelector::from_signature(\"transfer((Field),(Field),Field,Field)\");\n        let _callStackItem = context.call_private_function(\n            token,\n            selector,\n            [this.to_field(), recipient.to_field(), amount, 0]\n        );\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/escrow_contract/src/main.nr" }, "273": { "source": "// docs:start:encrypted_import\nuse dep::aztec::log::emit_encrypted_log;\n// docs:end:encrypted_import\nuse dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::Empty},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    hash::pedersen_hash, context::PrivateContext\n};\n\nglobal ADDRESS_NOTE_LEN: Field = 3;\n\n// docs:start:address_note_def\n// Stores an address\nstruct AddressNote {\n    address: AztecAddress,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n\nimpl NoteInterface<ADDRESS_NOTE_LEN>  for AddressNote {\n    fn serialize_content(self) -> [Field; ADDRESS_NOTE_LEN]{\n        [self.address.to_field(), self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; ADDRESS_NOTE_LEN]) -> Self {\n        AddressNote {\n            address: AztecAddress::from_field(serialized_note[0]),\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(), 0)\n    }\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(note: Self) -> NoteHeader {\n        note.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        // docs:start:encrypted\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n        // docs:end:encrypted\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'AddressNote')))\"\n        6510010011410111511578111116101\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        AddressNote { address, owner, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n", "path": "/usr/src/noir-projects/aztec-nr/address-note/src/address_note.nr" } } }
