{ "noir_version": "0.25.0+589a6cb62caf38445c768429150eee469ae35d77", "name": "Delegator", "functions": [{ "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "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", "debug_symbols": "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" }, { "name": "view_public_value", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [], "param_witnesses": {}, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [0] }, "bytecode": "H4sIAAAAAAAA/81UwU7DMAx12rTr6BBcOYAqcUeZxAeEX+APiloQl1XqNgl+HkGYrb5lFpeFaU+q7DpO7Dw7JiIytENOEwzt44FlBTbPX4A7Bo9uWYZDLKmY/XwF6zX4ZWy7BpuBPGX9K1Wezi0v6ZCjCrjzCWPFNfCg58BH7FfDega2LNobeL2H9ULZUyrxRMeaSOlKZS/yVMBdPOvuOPzyhLE8/Eu8BeRRniAfbGUP/8WZxJ6lj+0qmuZD6jvNoXYe8pd4FnzuWF7RruZil7yw/wMWwI341gpv+IYs+OP7TzlrKpp61Sc8F+8m+GvW/Pd7uWBuA9abYWzf+ue+7QykZqM0URrlGhnYUM8VG9H+uLJgkxbRWgBHXdxSczqkNOl7yEmHRgbablnesHwax/azeV91/UczbDfN8Nq8DNtVt6Zvd/PeXBoIAAA=", "debug_symbols": "zZfNaoNAFIXf5a6l3J/JzOirlC6mqQVBTIi2UMR3r5JoFwmFSCJn52XO5XyL8YPpqT7sU1cdmpaKnvhlR8VrT+0xNdPcdunUUSFRfEZl8zF9Ojdk9FnVJRXqZciu0yJhTouLS9rbjbAFvWSd2BIVDsNbNuJ4LJyAhROxcHIsHGEwHgHjUTAeA+NxYDxgbhYwOQuYnQVMzwLmZwXzsz7Xz+cO3aDDNuhwG3Q8xHe7uHRE/v9+CIvNYVb9uyF5vBB5OKIARxThiHI0ImM4IoEjuvn3q5+VYeyuFW5+zVJYsxTXLOUrlhzfuTRO3+lUpfe6nB710+FXs5/f+OPY/RzPJ8Mv" }, { "name": "enqueued_delegate_set_value", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "targetContract", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "targetSelector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "args", "type": { "kind": "array", "length": 1, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "args": [{ "start": 35, "end": 36 }], "inputs": [{ "start": 0, "end": 33 }], "targetContract": [{ "start": 33, "end": 34 }], "targetSelector": [{ "start": 34, "end": 35 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320] }, "bytecode": "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", "debug_symbols": "7Z3dTttAEIXfxdcR2pn9nbxK1YuUUgkJBQRppQrx7rUpu3bwsCNCFMNkryDK2j7fie18xGbz2N3cXm5217fbh2792AF062+P3cPdZjs8fNht7nfd2qy6q+3P/ufTqvt1fXPVrTHA02o2Djy9jIQEZWyKzFBESi9j0XpfBgMRMzqRzxnIgNsb/X3VAX7J1PZUqZ3FnNoRfjC1+0hqDyEX6NGkMTdyiMbk3GBwhARvmdE9WVlzHMe69Jzaf8nU4UumjlxqMD7kDYAFae+OMOaJALGe/rjHZTp9/qMeoXSU/C6O+ePe3tNvA81RtmFdbRtwlG2kcp6MOKmWPwqSCwU7BXKvI+HpIxFA2ZMIvLAnBcxRQpjsR5ZdtfWQ12wnrBC4Y55MboaAxrHJPxdjWzF8Ma4VwxfjWzF8MaEVwxcTWzF8MakVwxdDrRi2GGtaMXwx0Irhi2nm+0YxuszXYSnGOdwrZoB15wSry1AFWF3WKcDqMkkBVpcdCrC6jK8O63RZnACry8wEWF22JcAqM6hy1aW/HkIzWHdOsMoMqg6rzKDqsMoMqg6rzKDqsMoMqgrrlRlUHVaZQdVhlRlUHVaXQXkoQbwzM1h3TrC6DEqA1WVQAqwugxJgdRmUAKvLoOqwQZdBCbC6DEqA1WVQAuwSBoWu3P5ImNLxYDGaHASjCxPYxF3etHkwhYlaOseMjT57aJxcNkXz3KHT1WEsHSZEqcPaJeLgWzF8MaEVwxcTWzF8MakVwxdDrRi2mGhaMXwx0Irhi8FWDF+MMkk+XjGuFcMXo8t8k3elmOj3ihlgddmsAKvLUAVYXdYpwOoyyTps0mWHAqwu4xNgdVmcAKvLzARYpwqWjM+whGEGq8ugBFhdBiXA6jIoAVaXQQmwugyqDku6DEqA1WVQAqwugxJgdRmUAOt0wQYosJO50DKsMoOqwyozqDqsMoOqwyozqDqsMoOqwoJRplACrTKHEmiVSZRAq8yiBFp3VrSn9yg0feycyUTzejpGMGGBTBEnmSLMMsUlMiVbMiUm0+nlAfsTffkUtz9UcJaJPl8mMEtkCqZk6gPOMsECmbCcOPrfZ9OgAuACmWy5N7z/PYZZJrtAJj/eKtGfJ2mWyS2QKeK4jycz72mB8zhiLK8dYrL14YnyhxeEkzv1Ezc3FwQsE/YG2r+vn11zdeZkCJ+9GypTJpMnoZsw3q0fkp18CkThkG5i6+bNbtJn7yZSBuj/3PR75QwAdMG+upEyAE1UM08zfpEOWIZ/16fxLXD8p5/+fef7MA34Bb57Q8NCdMBC/MSY0kJwyEL4voX6B38299ebHzdXwzd1DM/93l7mL+7oH+7+3v1/5ukf" }, { "name": "public_delegate_set_value", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "targetContract", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "targetSelector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "args", "type": { "kind": "array", "length": 1, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "args": [{ "start": 39, "end": 40 }], "inputs": [{ "start": 0, "end": 37 }], "targetContract": [{ "start": 37, "end": 38 }], "targetSelector": [{ "start": 38, "end": 39 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241] }, "bytecode": "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", "debug_symbols": "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iSm2xBRHYoqSmKIVpshHYgqTmMIlpgiJKSTYmRLsTAl2pgQ7U4KdKcHOJcHOJcHOJcHOJcHOJcHOJcHOJcHOJcHOde871nXvO9Z97zvWfe871n3vO9Z97zvWnfdufc8f7Xv+aN/zR/veadz3TuO5dxrPvdN47p3Gc+80nnun8dw7jefeaTz3TuO5dxrPvdNY905j3TuNde801r3TWPdOY907jXXvNNa901j3TmPdO4197zT2vdPY905j3zuNfe809r3T2PdOY987jX3vNPa103ie596t7d6t/d6t496t896t171bj7ihqvz2yX7s87PbP6c4ElOUxBStMIU9ElOYxBQuMUVITJESUyyJKSTYaRLsNAl2mgQ7XYKdLsFOl2CnS7DTJdjpEux0CXa6BDtdgp0uwc572dxzL5t77mVzz71s7rmRzf249b3vWGPfu/W5d+u6d+t7/ijvnca8dxrz3mnMe6cx753GvHca895pzHunMe+dxrx3Gte907juncZ17zSue6eR5Ac/Lln8ks0vOfyS4pfgxvHZD7/E+CXOLwl+Cd/+5tvffPubb3/z7W++/cO3f/j2D9/+4ds/fPuHb//w7R++/cO3f/j2i2+/+PaLb7/49otvv/j2+c+ZOfznzBz+c2YO/zkzh/+cmcN/zszhP2fm8J8zc/jPmTn858wc/nNmDv85M4f/nJnDf85M8Z8zU/znzBT/OTPFf85MPckvWfySzS85/JLil/DtG9++8e0b377x7RvfvvHtG9++8e0b377x7TvfvvPtO9++8+07377z7TvfvvPtO9++8+0H337w7QfffvDtB99+8O0H337w7QfffvDtJ99+8u0n337y7SfffvLtJ99+8u0n337y7S++/cW3v/j2F98+d33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d32NXZ8/2PW9LjF+ifNLgl+S/JLFL9n8ksMvKX4J377x7RvfvvHtG9++8e0b377x7RvfvvHtG9++8+07377z7TvfvvPtO9++8+07377z7TvffvDtB99+8O0H337w7QfffvDtB99+8O0H337y7SfffvLtJ99+8u0n337y7SfffvLtJ9/+4ttffPuLb3/x7S++/cW3v/j2F9/+4ttffPubb3/z7W++/c23v/n2N9/+5tvffPubb3/z7R++/cO3f/j2D9/+4ds/fPuHb//w7R++/cO3X3z7xbdffPvFt198+8W3X3z7xbdffPvFt998+82333z7zbfffPvNt998+82333z73PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Tl3fc5dn3PX59z1vf4LN79k8Us2v+TwS4pfwrfPXZ9z1+fc9Tl3fc5dn3PX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PXF9z1BXd9wV1fcNcX3PUFd33BXV9w1xfc9QV3fcFdX3DXF9z1BXd9wV1fcNcX3PUFd33BXV9w1xfc9QV3fcFdX3DXF9z1BXd9wV1fcNcX3PUFd33BXV9w1xfc9QV3fcFdX3DXF9z1BXd9wV1fcNcX3PUFd33BXV9w1xfc9QV3fcFdX3DXF9z1BXd9wV1fcNcX3PUFd33BXV9w1xfc9QV3fcFdX3DXF9z1BXd9wV1fcNcX3PUFd33BXV9w1xfc9QV3fcFdX3DXF9z1BXd9wV1fcNcX3PUFd33BXV9w1xfc9QV3fcFdX3DXF9z1BXd9wV1fcNcX3PUFd33BXV9w1xfc9QV3fcFdX3DXF9z1BXd9wV1fcNeX3PUld33JXV9y15fc9SV3fcldX3LXl9z1JXd9yV1fcteX3PUld33JXV9y15fc9SV3fcldX3LXl9z1JXd9yV1fcteX3PUld33JXV9y15fc9SV3fcldX3LXl9z1JXd9yV1fcteX3PUld33JXV9y15fc9SV3fcldX3LXl9z1JXd9yV1fcteX3PUld33JXV9y15fc9SV3fcldX3LXl9z1JXd9yV1fcteX3PUld33JXV9y15fc9SV3fcldX3LXl9z1JXd9yV1fcteX3PUld33JXV9y15fc9SV3fcldX3LXl9z1JXd9yV1fcteX3PUld33JXV9y15fc9SV3fcldX3LXl9z1JXd9yV1fcteX3PUld33JXV9y17e461vc9S3u+hZ3fYu7vsVd3+Kub3HXt7jrW9z1Le76Fnd9i7u+xV3f4q5vcde3uOtb3PUt7voWd32Lu77FXd/irm9x17e461vc9S3u+hZ3fYu7vsVd3+Kub3HXt7jrW9z1Le76Fnd9i7u+xV3f4q5vcde3uOtb3PUt7voWd32Lu77FXd/irm9x17e461vc9S3u+hZ3fYu7vsVd3+Kub3HXt7jrW9z1Le76Fnd9i7u+xV3f4q5vcde3uOtb3PUt7voWd32Lu77FXd/irm9x17e461vc9S3u+hZ3fYu7vsVd3+Kub3HXt7jrW9z1Le76Fnd9i7u+xV3f4q5vcde3uOtb3PUt7voWd32Lu77FXd/irm9x17e461vc9S3u+hZ3fZu7vs1d3+aub3PXt7nr29z1be76Nnd9m7u+zV3f5q5vc9e3uevb3PVt7vo2d32bu77NXd/mrm9z17e569vc9W3u+jZ3fZu7vs1d3+aub3PXt7nr29z1be76Nnd9m7u+zV3f5q5vc9e3uevb3PVt7vo2d32bu77NXd/mrm9z17e569vc9W3u+jZ3fZu7vs1d3+aub3PXt7nr29z1be76Nnd9m7u+zV3f5q5vc9e3uevb3PVt7vo2d32bu77NXd/mrm9z17e569vc9W3u+jZ3fZu7vs1d3+aub3PXt7nr29z1be76Nnd9m7u+zV3f5q5vc9e3uevb3PVt7vo2d32bu77NXd/mrm9z17e569vc9W3u+jZ3fZu7vs1d3+aub3PXd7jrO9z1He76Dnd9h7u+w13f4a7vcNd3uOs73PUd7voOd32Hu77DXd/hru9w13e46zvc9R3u+g53fYe7vsNd3+Gu73DXd7jrO9z1He76Dnd9h7u+w13f4a7vcNd3uOs73PUd7voOd32Hu77DXd/hru9w13e46zvc9R3u+g53fYe7vsNd3+Gu73DXd7jrO9z1He76Dnd9h7u+w13f4a7vcNd3uOs73PUd7voOd32Hu77DXd/hru9w13e46zvc9R3u+g53fYe7vsNd3+Gu73DXd7jrO9z1He76Dnd9h7u+w13f4a7vcNd3uOs73PUd7voOd32Hu77DXd/hru9w13e46zvc9R3u+g53fYe7vsNd3+Gu73DXd7jrO9z1He76Dnd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33FXV9x11fc9RV3fcVdX3HXV9z1FXd9xV1fcddX3PUVd33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV3fc1dX3PX19z1NXd9zV1fc9fX3PU1d33NXV9z19fc9TV2ffFg1/e6xPglzi8JfknySxa/ZPNLDr+k+CV8+8a3b3z7xrdvfPvGt298+8a3b3z7xrdvfPvOt+98+86373z7zrfvfPvOt+98+86373z7wbcffPvBtx98+8G3H3z7wbcffPvBtx98+8m3n3z7ybeffPvJt598+8m3n3z7ybeffPuLb3/x7S++/cW3v/j2F9/+4ttffPuLb3/x7W++/c23v/n2N9/+5tvffPubb3/z7W++/c23f/j2D9/+4ds/fPuHb//w7R++/cO3f/j2D99+8e0X337x7RfffvHtF99+8e0X337x7RfffvPtN99+8+03337z7TfffvPtN99+8+1z12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HXZ9z1GXd9xl2fcddn3PUZd33GXZ9x12fc9Rl3fcZdn3HX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PX59z1OXd9zl2fc9fn3PU5d33OXZ9z1+fc9Tl3fc5dn3PX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lE9Nyqcm5VOT8qlJ+dSkfGpSPjUpn5qUX5qUX5qUX5qUX5qUX5qUX5qUX5qUX5qUX5qUX5qU35qU35qU35qU35qU35qU35qU35qU35qU35qU35qUP5qUP5qUP5qUP5qUP5qUP5qUP5qUP5qUP5qUP5qUL03KlyblS5PypUn50qR8aVK+NClfmpQvTcqXJuVbk/KtSfnWpHxrUr41Kd+alG9NyvffhfLnx7FOra/GKs2xWnGs8zyaY5nmWK45VmiOlZpjLc2xtuZYkpQ/jyTlz6NJedOkvGlS3jQpb5qUN03KmyblTZPypkl506S8aVLeNSnvmpR3Tcq7JuVdk/KuSXnXpLxrUt41Ke+alA9Nyocm5UOT8qFJ+dCkfGhSPjQpH5qUD03KhyblU5PyqUn51KR8alI+NSmfmpRPTcqnJuVTk/KpSfmlSfmlSfmlSfmlSfmlSfmlSfmlSfmlSfmlSfmlSfmtSfmtSfmtSfmtSfmtSfmtSfmtSfmtSfmtSfmtSfmjSfmjSfmjSfmjSfmjSfmjSfmjSfmjSfmjSfmjSfnSpHxpUr40KV+alC9Nypcm5UuT8qVJ+dKkfGlSvjUp35qUb03KtyblW5PyrUn51qS8Zvf1aHZfj2b3tTS7r6XZfS3N7mtpdl/rkaR8aXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X0tze5raXZfS7P7Wprd19LsvpZm97U0u6+l2X1tze5ra3ZfW7P72prd134kKd+a3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua2t2X1uz+9qa3dfW7L62Zve1Nbuvrdl9bc3ua0t2X9cj2X19jaVI+ddYipR/jaVI+ddYipR/jaVI+ddYipR/jaVI+ddYipR/jaVJecnu62ssTcpLdl9fY2lSXrL7+hpLk/KS3dfXWJqUl+y+vsbSpLxk9/U1liblJbuvr7E0KS/ZfX2NpUl5ye7rayxNykt2X19jaVJesvv6GkuT8pLd19dYmpSX7L6+xtKkvGT39TWWJuUlu6+vsTQpL9l9fY2lSXnJ7utrLE3KS3ZfX2NpUl6y+/oaS5Pykt3X11ialJfsvr7G0qS8ZPf1NZYm5SW7r6+xNCkv2X19jaVJecnu62ssTcpLdl9fY2lSXrL7+hpLk/KS3dfXWJqUl+y+vsbSpLxk9/U1liblJbuvr7E0KS/ZfX2NpUl5ye7rayxNykt2X19jaVJesvv6GkuT8pLd19dYmpSX7L6+xtKkvGT39TWWJuUlu6+vsTQpL9l9fY2lSXnJ7utrLE3KS3ZfX2NpUl6y+/oaS5Pykt3X11ialJfsvr7GkqS8aXZfTbP7aprdV9PsvtojSXnT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z+2qa3VfT7L6aZvfVNLuvptl9Nc3uq2l2X02z++qa3VfX7L66ZvfVNbuv/khS3jW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+umb31TW7r67ZfXXN7qtrdl9ds/vqmt1X1+y+hmb3NTS7r6HZfQ3N7ms8kpQPze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+h2X0Nze5raHZfQ7P7Gprd19DsvoZm9zU0u6+p2X1Nze5ranZfU7P7mo8k5VOz+5qa3dfU7L6mZvc1Nbuvqdl9Tc3ua2p2X1Oz+5qa3dfU7L6mZvc1Nbuvqdl9Tc3ua2p2X1Oz+5qa3dfU7L6mZvc1Nbuvqdl9Tc3ua2p2X1Oz+5qa3dfU7L6mZvc1Nbuvqdl9Tc3ua2p2X1Oz+5qa3dfU7L6mZvc1Nbuvqdl9Tc3ua2p2X1Oz+5qa3dfU7L6mZvc1Nbuvqdl9Tc3ua2p2X1Oz+5qa3dfU7L6mZvc1Nbuvqdl9Tc3ua2p2X1Oz+5qa3dfU7L6mZvc1Nbuvqdl9Tc3ua2p2X1Oz+5qa3dfU7L6mZvc1NbuvybuvHxeudy/c71543r2w3r2w37yQ9xg/LrR3L/R3L4x3L3z3zal335x6982pd9+cevfNqXffnH73zel335x+983pd9+cfvfN6XffnH73zel335x+983pN9+c9TzvXmjvXujvXhjvXpjvXrjevXC/e+F598J698J33xx7982xd98ce/fNsXffHHv3zbF33xx7982xd98ce/fNsXffHH/3zfF33xx/983xd98cf/fN8XffHH/3zfF33xx/983xd9+cePfNiXffnHj3zYl335x4982Jd9+cePfNiXffnHj3zYl335x8983Jd9+cfPfNyXffnHz3zcl335x8983Jd9+cfPfNyXffnPXum7PefXPWu2/OevfNWe++OevdN2e9++asd9+c9e6bs959c/a7b85+983Z7745+903Z7/75ux335z97puz331z9rtvzn73zTnvvjnn3TfnvPvmnHffnHcd8nrXIa93HfJ61yGvdx3yetchr3cd8nrXIa93HfJ61yGvdx3yetchr3cd8nrXIa93HfJ61yGvdx3yetchr3cd8nrXIa93HfJ61yGvdx3yetchr3cd8nrXIe93HfJ+1yHvdx3yftch73cd8n7XIe93HfJ+1yHvdx3yftch73cd8n7XIe93HfJ+1yHvdx3yftch73cd8n7XIe+vHfLz7arnby75aeLg9fWVf/vo6x/j89OfeYP9tWr+9e7/tZH+Fe9vl+/vl+8fl++fl++/Lt9/X77/uXz/y+fXL5/fuHx+4/L5jcvnNy6f37h8fuPy+Y3L5zcun9+4fH7j8vnNy+c3L5/fvHx+8/L5zcvnNy+f37x8fvPy+c3L5zcvn991+fyuy+d3XT6/6/L5XZfP77p8ftfl87sun991+fyuy+d3Xz6/+/L53ZfP7758fvfl87vvnt/za/z+hO6zv326u+2vn/JFSaWsP25d/uMfwF6P+ZhpCc60BWc6gjOV4Ew9PtOqz5kqv5ipfo3flvCrz2SCM7ngTCE4UwrOtARn2oIzHcGZSnAmQY7bOMf7+ez4dtiXM5ngTON86s8vfV//GF/OtARn2oIzHcGZSnCm1pvJH8GZTHAmF5wpBGcS5LgLctwFOe6CHHdBjrsgx0OQ4yHI8RDkeAhyPAQ5HoIcD0GOhyDHQ5DjIcjxFOR4CnI8BTmeghxPQY6nIMdTkOMpyPEU5HgKcnwJcnwJcnwJcnwJcnwJcnwJcnwJcnwJcnwJcnwJcnwLcnwLcnwLcnwLcnwLcnwLcnwLcnwLcnwLcnwLcvwIcvwIcvwIcvwIcvwIcvwIcvwIcvwIcvwIcvwIcrwEOV6CHC9Bjpcgx0uQ4yXI8RLkeAlyvAQ5XoIcb0GOtyDHW5DjLcjxFuR4C3K8BTneghxvQY63Hsf70eN4P3oc70eP4/3ocbwfPY73o8fxfvQ43o8ex/vR43g/ghw3QY6bIMdNkOMmyHHBPmcL9jlbsM/Zgn3OFuxztmCfswX7nC3Y52zBPmcL9jlbsM/Zgn3OFuxztmCfswX7nC3Y52zBPmcL9jlbsM/Zgn3OFuxztmCfswX7nC3Y52zBPmcL9jlbsM/Zgn3OFuxztmCfswX7nC3Y52zBPmcL9jlbsM/Zgn3OFuxztmCfswX7nC3Y52zBPmcL9jl7vBPoj3/8TE9/1lc/L7rHO4G/ZKbpd9z9+fjw6x/PlzOl4ExLcKYtONMRnGn8axW3+vzBta9//pFQrxP5OVUrTjXfd/tFU5nkVC45VUhOlZJTLcmptuRUR3IqSbYfSbaXJNtLku3jPTj3/vxaPdb6m69jfvrpeomFj1s/9tVvEOiK3/yfIH/zf4L1m/8T7N/8n+AI/Qk+Zmq9mcabdb9kJhOcSelvho+ZlFj/MZMSvT9mGudx9PmcqevLmbbgTEdwphKcqdVm2s94s+6XzGSCM7ngTCE4UwrOJMfx10xyHH/NJMfx10xyHH/NJMhxE+S4CXLcBDlughw3QY6bIMdNkOMmyHET5LgJctwFOe6CHHdBjrsgx12Q4y7IcRfkuAty3AU57oIcD0GOhyDHQ5DjIcjx8caYP/3x38rcbH850xGcqQRnar2Z8hGcyQRncsGZQnCmFJxp/T1n8ufLmbbgTEdwphKcqfVmWo/gTOMct1yfM+0vv34ab4z9kpmW4ExbcKYjOFMJztR6M8232F5fDXzM5H6+nMkEZ3LBmUJwphScaQnOJNf2e80k1/Z7zVSCM7XeTOcRnMkEZ3LBmeRa26+ZUnAmudb2ayZBjh9Bjh9Bjh9Bjpcgx0uQ4yXI8RLkeAlyvAQ5XoIcL0GOlyDHS5DjLcjxFuR4C3K8BTneghxvQY63IMdbkOMtyPHW47g9esy0R4+Z9ugx0x49Ztqjx0z7usP18V+Rn7+Z5uOSxpd83YD6zy8xfonzS4JfkvySxS/Z/JLDL+HbN75959t3vn3n23e+fefbd7D9L85wfkY68sfjHp833zdvfm7evG7evC/ePJ7vuXnEx38fjPUj7et83t2u3t2v3j2u3j2v3n1dvfu+evdz9e519e598+559azm1bOaV89qXj2refWs5tWzmlfPal49q3n1rObVs7quntV19ayuq2d1XT2r6+pZXVfP6rp6VtfVs7quntV19azuq2d1Xz2r++pZ3VfP6r56VjcXFZuLis1FxeaiYnNRcb7rxcj8+KGFmV/9yz1x9e559e7r6t331bufq3evq3fvm3ev5+rd7erdv+usrufjk+v58u5x9e559e7r6t331bufq3evq3fvm3fv5+rd7erdr57VvnpW++pZ7atnta+e1b56VvvqWe3v+3v1fPzdtOz56d39ea7e3a7e3a/ePa7ePa/efV29+75693P17nX17lfPql09q3b1rNrVs2pXz6pdPat29aza1bNqV8+qXT2rdvWs+tWz6lfPql89q371rPrVs+pXz6pfPat+9az61bPqV89qXD2rcfWsxtWzGlfPalw9q3H1rMbVsxpXz2pcPat506V6+tW7x9W759W7r6t331fvfq7eva7e/eZ/9/D1XL37TZfqy6/ePa7ePa/efV29+75693P17nX17jf/u4fv5+rdr57VffWs7qtndV89q/vqWd1Xz+q+elb31a8j99Xv+c7V7/nO1e/5ztXv+c7V7/m+M/vzc3e/+j3fufo937n6Pd+5elbP1bNaV89qXT2rdfWs1tWzWlfPal09q3X1rNbVs1pXz2pdPat99az21bPaV89qXz2rffWs9tWz2lfPal89q331rF7N/sTV7E9czf7E1exPXM3+xJNX776u3n1fvfvNsxpf52d2fxRN6qzPq+xZn5fZe5d9/eNv/urXXvz4U046P6/a7z3svHdZvXdZv3WZ03//r//tf//hX//4h//+T//459cV//H//F9/+oe//PGf//Ttf/3L//mX////+ff/Cw==" }, { "name": "private_delegate_set_value", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "targetContract", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "targetSelector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "args", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "args": [{ "start": 35, "end": 37 }], "inputs": [{ "start": 0, "end": 33 }], "targetContract": [{ "start": 33, "end": 34 }], "targetSelector": [{ "start": 34, "end": 35 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473] }, "bytecode": "H4sIAAAAAAAA/+19B3xdxZX+s3hIAklgm2ZCiagGXPTULNlgEETuvds0N9k0g8EYQthUUiEJJQGSEJJQk0AKCemNVEiFFNJJ2d1kk02yyW6ym/9uGvnfkc5nfTqeeZZu7nl+4s77/eY3c+edmfOdc8+dOVPu3B+MKRTmJMH9XFSThH2S0EzXRUnjel91Xavo69X1OHV9kLo+RF0fpq6b1fWxcs0/EaHQI3F7aVpHx5auti2t7a0bS23TN3V3ljo6N03rbu1u7ezu7Gvrbm/f0t3R3TV90/Su0vTWjvYtrVs7p7dvLQ38TqC6Sv/gbwzpxP2OScLTIoeLj5P4eIlPeIbHk5Nwotwz1suJOZG/nF4mFgaeP9gz/7SNl/6xX2uGdZUY70mFgTbC/Wo9+PHbx5OuJ7qnM5aVeWksYz04d7sHPRmCsbiZJxnUe3Ihu0bVSu6Ts79HuzXaeWukfY3TKYXdG+1TcqoP1sukwtBGBY4K/7K2++Oyq6tkhfH4gk0H43TeJOl6yu/Jil9Hqb2/4yoO1KXvZT3lZcizVF8Y7Agzqze5D3VJHXVSV4PDruQaS3ljSMaiAZYxhaEdfw9dg9/+hcH7e/nGzZecueOCqy7dctnOK9kIQMx5vgewxvMfl6khxeyr6m6g//HffgVjz0ADy6ruSYXsevLJ2eEqubtfW9j9l3VrdEwh+xbTAuexowTnpFGCs3mU4NzXCGchY5ztVOcUiadK3AIeEqNBa5MYZTsk7pR4msRdEndLPF30jAZ5RhJOTcJpSZgpeacLTY9cnyHpM5NwVhKek4TeJMxKwuwkzEnC3CTMS8L8JCxIwsIkLErC4iQsScLSJCxLwvIkrEjCyiSsSsLqJKxJwtokrEvC2Uk4JwnnJuG8JJyfhPVJ2JCEjUnYlITNSehLwpYkbE3CBUm4MAkXJeHiJFyShG1JuDQJlyVhexIuT8IVSdiRhCuTsDMJVyXh6iQ8NwnXJOF5Sbg2Cf+UhOcn4QVJeKHS14uS8OIkvCQJ16n/XpqElyXh5Ul4hfzXLP+9MgmvSsL1SbghCa9OwmuS8Nok3JiEm5JwcxJuScLrkvD6JNyahNuScHsS3pCENybhTUm4IwlvTsKdSXhLEt6ahLcl4a4k3J2Ee5JwbxLuS8L9SXi7YIENvSMJ70zCA0l4MAnvSsK7k/CeJLw3CQ8l4X1JeH8SHk7CB5LwwSR8KAkfTsJHkvDRJHwsCR9PwieS8MkkfCoJjyTh00n4TBI+m4TPJeHzSfhCEh5NwmNJ+GISvpSELyfhK0n4ahK+loTHk/BEEr6ehG8k4ZtJ+FYSnkzCt5PwnSR8V+n8e0n4fhJ+kIQfqv+eSsKPkvDjJPxE/ffTJPxzEv4lCf8qeT+T+OeFoQ7PvyXhFyrvl0n4d0n/SuJfS/wbif9D4t+qsr9Lwn+qvP9Kwu9V3h+S8N+S/h+J/yjx/5P4fyX+P4n/JPGfJf6LxH+V+G8SPy3x3yVG4ztG4hqJ90ninYcPpG1GBn19PDLQfovTxRh40hI3S/4+cr2Pyi/KdZE88P5pdrnel/LZIQUGlwcPegzlwXZqKA9O7D6UBxmKlIfRAni7a9y7/jJqBNFfBvJRXj1ko7z9IBfl7a/06fIaiDfyGiWvnvKaJG8/yjtA8vanvANJPsRjJa+R8sZJXhPljZe8AwqD/J8j6Z5CVrbV2u7q7c263qRmV+/s7OvtH5XPkbpqpV7w6SVdzZX0mOx4tzJvDOrAB/lFSp9EtKCDPg6UNLA7e5gl6bllyj1HlWsimlke+XsK2co/W+GZrTC7Z+woSTs7PkzseBxhM7Djbhs77ihFOx70kX32OF7Sz0Q7nkw4srfZzu7Y9g77N2KbnUW02vYOlvQz0WZnEA4Dm90cbXbYvxHb7Aqi1bZ3qKSfiTY7l3Bkb7PTSjY22xZ9g8LAnFOh4Le9CZJ+JtrsasKRvc12G9lse7TZwsB8Z6Hgt71nSfqZaLN9hCN7m91kZLPRN3C/FxCttr0jJf1MtNkdhMPAZjuizQ77N2KbfTXRats7WtLPRJt9MeEwsNk4bzD834ht9k1Eq22vWdLPRJu9UdJuzvaTMmd7LOV9SvKOI7wGtr3FyLbbom0PrGcXCn4bPV7Sz0TbfivhyN5mN5eizQ77N2Kb/QjRats7UdLPRJt9t6Rd2/s5aXtPorzPS97JlPcFyTuF8h6VvEmU95jk2a5vbO6Kz8WwfyN+Lr5CtNq+sUfumfhcfJpwGNjs9Gizw/6N2Ga/T7Ta9rCP85los48TDgOb3RRtdti/EdvsL4hW2x72Gj8TbfYpSTt/4XHxF9op7wnJ66C8r0teJ+V9Q/KmUd43Ja+L8r4led2U96TkTae8b0veDMr7juSdSnnflbzTKO97kjeT8r4veadT3g8k7wzK+6Hk9VDeU5J3JuX9SPLOkjz3phP2Ln5P8ty9hd/WU8jq3vZ1Of4TC0N/Y9R1D6VPJjwnZY6n1Or2Qh4kdW3euG3b0h0XXb1x55bZV122eedF2y8bQxAB+3sK9pjCUBHwfy3l1VCaX/QqUnpfSnPZOk+e72dzywYex5OITw9dnxx555b3KdnzbmsoDH1x3f3KNQ+nEJ5JBrpoIB7DwTPJFk+pifAwr8kGspezg8mR917j7WwAzwj6pAb6n5/RKUYYJyuMuJ5CGJF3EuGZmD2e/jaDdeZ+5Z7Ricb6GamLM4XwWNiUkZz9U8p4xTHDU2n6h14tSlcTla6aiGYq6a/FQH9jiC/qxnUL4YEN8jMJupOqBCPyJhPGekmjP3F+aMuYQbwW/Rj703jFV+MoEs20wwdp2wVbI/3PU8zV1A42kjyTKQ9p9l+mGmGcEsAIfvy81QXkKBLN6aJ/93oQ+yMss7b7BirPz0LJSGbdfuhXsPketBAeiyFmOTsxbhdKljrG1FJtQMdFollANsNlgUu3VY2km1bSkZXPNUnh0c9s5F153qPNz+XxmJWfyzpzv73o53bkyc9FG5S1n1tSuvL5ufrYEMs2PeRDgl/EHDGHMDs8aJ98Y6BJVYLRNwbCMQnwP9w441oaAxm0Vx08BoIPtZ/CxmOg/5swiO2FexgDTVF5lRxf6OOP2Nf2jRF4DGTgA/freWoAI/jx81YXkKNINNcHxkAsM9K8ramk8rhv6Slke190+6HbCr4HJcJjMY9ezk6M24WSkY777QpHeNUGdFwkmtvVGAj5wDVV3QueOwBtDdWN/5olv03xflrydR3NBTu7c/W2Z19vv647lK6Bv510DZq7lK6RX1C65mcB+gFtDdWN/8ZIfofiDV3rOsaIrg100r/1pTP7evt1PU3pGvg7SdegeVDpGvkFpet20jX0M4103enRXQ3RdCpd6zqgawOd9B9B1JV9vf267la6Bv4u0jVoPqh0jfyC0nUn6Rr66SZdT/XozuXrPg+6Bt0Upeu9Ne6OvPfOXIdvPqaafE2ff285H8M6c7/hzsdkr5++tpHOx/C6mYVNGdlBvz+Htizr+ZgupauJSldNhd2PYzXqG1p94xZc83FXEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEXPEHDFHzBFzxBwxR8wRc8QcMUfMEfMzC7PDM1nSwNpAdJOrBCPyphDG/YFB4n2TcPS+g3jbM8fb1+bwdkpdtVIvcIBfkWg+PmEQ27GCrZH+P5nkaVV59SRbTyFbnYMX6m5VumwkeVopD+lTCGNL5hgH9FwKYAQ/tp26gBxFopki+j+wMGBT0DPuRegeTM1cvvL3gNsK5LVT3ilKxkZKTyZZOlVePdXXU8hWFvBC3bhm24EM+M/hAbaeQrZ4wAt143py5L1XeXdmz7utgXjgN0Zd91Ca7c/ieeBnbzh4Wm3xlJoKuz+Plu1ayA6mRt57jTf7eegrQn7eFCOMIT9vCmFEXjvhMfCB+tsM1pn7lXtGS7b66WooDPV39oRnCuGxsCkjOUuuXowzns6wXt/Yq6R0xWOviaQ/q3HNFIUH1+XGixFzxBwxR8zlMDs86Lu4Lwdde5VgRN5Uwtggafihbkj+EpqzMejru3isjTmbBqW/ItE8n+ZsXk5zNvifx9gtKs/SxwMv1N2i9MvzAC2UhzSPeyx8GJ+PB97g52jwDNUF5CgSzc00Z8OywMbdPehSeU6+7uzla/W1FXout5GwdxGe7OciB/BMVHgmenRh0AaUjHTcb0PTpa7agI6LRHMn2QeXBa4WdS94Hmo66cjCXly9M4x0dKrSEfDPIB2B5l6lI+RrHbENQzenko4MZGlz9Z5mpKOZSkfAfxrpCDQPKh0hX+toBukIugFtDaXx39Oiu9PoumcPMm4d5s/VcbrUVUe8WT78/36Sr55oewqZ6by9nvhlWG//vTxD6sK9BP7TSVbQfFjdS+QDF+4l6mgknYG2hurGf82Sf4bi/bTk6zqaRdcGOumop7oyrLdf12dKXdA143e/ItF8Ruka+aBvUbpqJP2Atobqxn9jJP9MxRu61nU4eiOddLp6z8q+3n5dP0fqqlV1g1+RaL6idI184OJ1OPdrJP2AtobqZt3VEA3+h651HdC1gU6muXp7s6+3X9ezCkN1Dfy9pGvQfFvpGvkFpeuzSNfQzyzSdYvSXbPkw09rUboG3USi5zmznkK2/qNeYy0p/nubt9XasraFqep+sC38yx5sQa/b8hgAtL5yoO8mGvCvUzSzCBdofqnWszsVbT2lewqVuXfVwJvXOnBvGuj/SozV9b3GNa/HII/XFgzW/9pGurZgvEbYwfsshoOH188sbMpIzhK3X1mvdfQqXfn2joCmhfRn0LeWXdsDv4g5Yg5hdnjQPnF7DbpSlWDUfbHD2ChpzC+5Lnlc7SDenuzxdji88DvhvzQSH/crEs3pNJ99iGBrpP95Pvt0lWc0V9Cvc/BC3bjmcTn48fgRaZ7PNpib6vDNA4E3+Dka+G91ATmKRNMs+j9QycLrOF0qz3LfXmg+m/ftATvPZ1vtS+1WeLo9urDi3aN491QZ7+zn8QfGQnptDHYLfrw21kL2y2WBC20KP8O6bbdcl9R4tCy+MdZMhY/HWNNIXt8+uhoqDzmbJb9V6QJjfK2P5oLtM466dN3G+w6HxZvHarAdHh9Uoh8K7cOeSRhZP8BjMP/VP1brKQz9lRsbnWWqn45SA/EYDp6ZhMfCpozswHSspn1L3Uayb8n+uNXchPZpcO3bp9pcyFYXU4ahiykePFZ7UkO64P0KI8HcMgoxRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwRz1HPYcwV4Oem4gfsDYQXU+VYEQev2sxM3s8/fv0m6Qu1O/e91tVZ8m3rX9PN/SP94c0Dn4XceVhg9jWCTZ+FxG4nDwzVJ7le0PghbpxzeeGQZ4ZhKfHCE/ItnoID9L8/maXytvb7w5qPe7Ne9hUGHr2fTXqrInyjO2sjZ8x/Mao6x5P2kg/HSN998n6fUIjOSv6rlGP0lVTobLvGu3pGyeVfNfIp4tK+jQhXZTzw8phroTvmDXmatCzw6N9C37ndEaVYEQe950W7ZGT/QCpi89lvpF8R4P2tf/dc9QF3/EAJXORaC4+dBDb68h3xP+4b6F7mf1ZYuXvJZ/BrPt5ozMryvoYfHYp0tV8lrXW4968h+w7zqhSnTVRnrGdtY30DK8ZtvrpGKkvy/2QhU0ZyVniPsn6TLEZSldNRDOF9FdNZ11FzBEz8GgfgM8Ua60SjBUai/X7eAdKXajf+VGPkY9n0A6WeF5mX6n3QCVzkWgmHTJI+xXy8fC/73w4vpdW/vqevl3G36bgvsVqHinkC/i+1co+3hSVZ2n/elyI617CqPW4N+8h+3itVaqz0Fja6txY1pn7DXc+Lnv9tJVG6nP2Eh4LmzKyg34fD2dMZu3jzVa6alW6aiIaPst5toH+fH4Frmd7eDcXstXFnGHoYo4Hz5wK6wL8Rop51ijEHPUc9RzCHPUc9RzCHPUc9RzCHPUc9RzCHPUc9RzCHPUc9RzCHPUc9RzCHPUc9RzCHPUc9RzCHPWcDjOvo/K6DeimVgnGCq2P96+TjJW6UL9bT91eP8g3+/WQ1hLvo8J+vrFK5iLRnHnwILYrBRuvW+K+he6l1fclQ/cS/BoLu6/LWe77Cq0J8l45pHmt1/e9S6t1nND3LmcTRq3HvXkPea13apXqrInyjO2sjZ8x/Ia7fy57/bSXRrr2zP2Q1TdCDeygxH1S1mu9c5WupipdNRHNHNLfXAP9+daecQ1+oxEz824uZHv/5g1DF/M8eOZVWBfgN1LMcyLmimCOthExhzBH24iYQ5ijbUTMIczRNiLmEOZoGxFzCHO0jYg5hDnaRsQcwhxtI2IOYY62ETGHMEfbiJhDmKNtRMwhzNE2IuYQ5mgbEXMIc7SNiDmEuRpsg/ch8r4n0PVWCUbkGZ9B0L/PaJzUhfrdfsS1+w3yzX4/UeuQs1prpd5xSuYi0Uw6aBDbuYKN9/3hvoXupdW+19C9BL/Gwu772oz2vZbdU8dnziDNeyXnqDzLPUV6fzWu5xJGrce9eQ95r2RvleostCfdwM7a+BnDr9zexF5b/XSMdO8m90MWNmUkZ4n7pKz3Ss5XuupVumoimnmkv/kG+vPtg8Q1+EXMEXMIM/tP3F6DbnaVYKzQPt5+H2+81IX6nR91M/l4Bu1gB7+HAB9vvJK5SDS/HT+I7Vby8Xz+ylyVZ+mvh+4l+DUW/D4M0p2E0cDeOnzjMN9zvEDSdQE5ikTzNtG/O6uyiWRgmZHG89RA5fkZW5i9zK0sD+rG9ULCCBkXEB6DcVRZO5ldAd4h/7AaeIf8Z/zPz/ACI4whH38BYfSNOaz8Z9aZ+w3XfzbQz4j9Z+tnyUjOErdFWfvPi5SuepWumohmIelvkYH+yrWN4BcxR8whzDyXwO016OZUCUafr2HRbjjZZfpxV/3OR/0m+c8G/UQH91vwnw9S96VINA+R//wd8p91P+vkma/yLPtePX6cr3TJPv58ykOa/WcDX7LDZ2/gDX78HNcF5CgSzT8H/GeWWT9PDVSen7HF2cvc6muXcL2YMELGRYTHah42ZCeVmAPe0/kVe5M3+8881vLNP1u1xyEfv1yfYeQfjvhd/dm2+ukY6Xy49bNkJGeJ26Ks/eclSlezla6aiGYx6W+Jgf7KtY3gFzFHzCHMvMeA22vQ9VYJRp+vYdFuONnlqKNd9Tsfdfz+g3wt+gnut+A/H6zuS5FoPj9uENuhgo3ndnkstFDlWfa94IW6Fypdso/P40erPQahubQ97TFYpPL2tm+r9bi37yHSPN7Jvn3o638ulkpdtQV/+1AkmpPlWXBjGS4LXL0eWaDnpRWXb0DfGqOvX1km6TpFs5R0AJpW0kEN5UPOZslHHfj/aclfrHTUXNi79ra3eS/LnPeAXS+XumDXS9X9KBLNacqulyvcsGufDYPWVw705WxtqaqHbe0swsVzB6CtofJsTzVEg/9hfxq3o6+n655CZWwA/PYm79B6FP7n/mmpEUZtM/q+NVGecZ/exv4MfsNdjzLQz4jH90sJj4VNGclZ4nYw6/H0CqUr3ZY1Ec0y0t8KA/35+mNcg99oxOzw6HFAA9EtrBKMuq+xsmcnu3y+dFf9bix1IY3zDPy9Nt8+I+BgfxY0L6dx3jYa5/nGLEtVno3vUv5egl8jycM+CdLsVxu0g23sx2iM7A/B9uoKYR8MNM8N+DosM9J4nhqoPD9jK7OXudXXLuF6JWHUz53lvqeQnSysAG89F7ekiniH/Dr8z8+wVXsc8j19fcYSwmPl17HO3G+4fp2Bfkbs11k/S0ZylrgtytqvW6V01at01UQ0K0l/qwz0V65tBL/RiJnXE7gdAd2SKsHo6wMt7NnJfqjUhfqd73Q3+XUW7Re3p/DrDlX3pUg0c8ivu5/8Ot3+h8b6Vn1CaKwPfux7Lqc8pNmvM/Bx2nz2Bt7gx89xXUCOItG8j/w6lgXPjrsHq1Wek29N9vL13wPwQt24Br9Gwr6a8FjNT+s2cZVHF1a8Q/tNqoX36sx5D8wN416jLYHdgl+RaD6t5obXKNzar+Ox2RpTWQb0qPFoWRzNWknXKZo1JC9oHiN5LdvC0P1nX29v8l6bOe8B21sndcH2cA/W0r0AzRPK9tYp3LA9brsgA2h95UBfzkbWqHrYRr4dGKuDtp7SPYXK3LvIe+/x5vE2z83gf/atrPp1beO4XkMYkcfjW4Px5IjHtwtN9dPaNdJ1He63LGzKyA5K3G5nPd4+W+lKt71NRLOW9He2gf58/T6uwS9ijphRd8QcMUfMEXPEHDFHzBFzT8QcMUfMEXPEnDlmfueL58JA11slGPX8rtWcjJP9MKkL9bt12SUNg3yzn4Nr7XJ6wJol5toPU/elSDT70ZrxCsHWSP/zmvFqlbe31yshz2rKQ5rXjLNf0xjQ85oARvDj+dm6gBy87nG+6B/rC9Az7kXoHljNf4fuAc9/I4/3oHUqGRsLu7cDDSQXtw1W64XghbpxzbYDGXgPjtU7hKF9cqwLi/2cI52jX2mLp8T9BvOysoOQ3nnPg8Hz1MbP7nD0zv3TOUZ41o0AzzmEx6L/NpKzf23kXKkr67WR85Su1ildNRHNuaS/8wz0N4b4om5cg99oxMx9DLA2EN3qKsGIvLMJ4wRJo11zPtYN5P9l75cM7GXT/h9w8F4L0Hxn7CC2Gz3+32qSZ53Ks/TlQ+va4NdI8nBbadVvrFV41ipdsO9pPNZp8+lntdIP2632PXlvC2jerHxP3z6LvdknW/WBI+mTuQ80aGu6uF0bDp7zCM+52eNpNZKzv08+X+rKuk9er3Tla6tBcz7pb72B/nz9La7BL2KOmCPmiHmkmNkvBtYGoltdJRgrNJbon289XOpC/c6n/Sr52wY+RBfP1cPfPlzdlyLRvIX87a+Tv61969AYx6KfLzfGAb9GkoH9ICufUK9/nK10EfK3DfTT5dPPaqUffh60v812AJofBfztSuh2OP62wTM6Yn+b/VuDNqyb28vh4FlPeM7PHk+rkZz9/vYGqStrf3uj0pWvDwDNBtLfRgP9+fpxXINfxBwxR8wRcx4w8xgBWBuIbnWVYKzQuKp/jPAsqQv1Oz98bOMgXwO/p9vpAX4ixgjPUvelSDRbaIxwsGBzkR4PhMZ7Fr5JufEe+DWSDOy7Wfmx5yo85ypdhMYIBvrp9ulntdIPPw96jMB2AJpj5N7rMQLrdm/uTzC4ryN+h5DtfkP2eKaNdMyygfBYzLsYyVniPiDrMcImpavVSldNRLOR9LfJQH9jiC/qxjX4RcwRc8S8dzFzf8f+Duh6qwQj8nhuaEP2ePp91yOkLtTv/MNF5Lsa+DXTeB8ofFfgAL8i0Uwh33UZ+a6+/Z8+n8JqD0/InwE/9hWNz5suu7e2twK8Q3tZjM+HKFnNKzuZYIuwUX1/i0SznvxqLgtc2PuEOvh8Mh6jWtiqkd/Yxu0ZdKTnL4pEs1XpCPlaR/z8QDegrSE6/Ncs+bA5PieyhujWEr3RXrmy60z8To3Bvucu3/3Q+8/5flyxh/uB9UO2WciwwVaW1gaFp1AY3p5y7j/PM8ZY7l7zvnOLZ4/fdRiOftiXMPBt2ngOcDh4NhEei3lCIzn7+5vNUlfWY9o+pav1SldNRLOZ9NdnoD+ff49r8BuNmB0ePDfA2kB0K6sEox43OYxHShrtsfOHb7GdZ27j+UX0KcDhm1/804GD2G4jX3290i/76qxzqzWDkK8Ofo0kD/vqVv1GaN6bz79HeoOtftp8+lmp9MN2W1fw+7RForlHzTNvKFROt8Ppk636wJH0ydwHGrQ1bdyuDQdPH+HZnD2eViM5+/vkLVJX1n3yVqUrX1sNmi2kv60G+vP1t7gGv9GImftkYG0gupVVgrFCfkz/vNxRUhfqd/3pI9TXW7RfvB8Bff1R6r4Uieaz1Nd/jvp63a+H/CuLNqacfwV+jSQDt8FW/dFGhWej0kWorzfQT5tPPyuVfvh50H092wFovh7o61m3G7KXpWxfv4F4W5zvn3Z+gvuqrPGMxPfgdt9inGMkZ4n7gKz7+guUrlYqXTURzVbS3wUG+htDfFE3rsFvNGLm9oH7B9BtqBKMyGOf2MKenexHS12o3/Wnv6G+3qof0O90Awf48Tvd11Nf/5/U1+v2ltuhDaQ7A3+l7Bks4MfvwXAbvMEIT+gd8w0V4B2aU6gE75CPUwneUef50nlojybzrqY1KSM8JV9fatnWhvTOfr5FXzXSeSwen1v52ptHgCf62kN/Pr91s9LVaPC1qx0zryMBK/vam6oEo/a1HcZnS5rPOTquaRBvpXziZyv9sU+8inziiYKN53J8c5msc4NntuxcJvg1kjw8vrHqNzYrPJuVLhopvcFWP20+/WxS+uE59LqCfw69SDQdcu/1/BfrdkP2sgzbFzK4ryOe/zJua6aN1Ee4gPBYrCkYydnfJ18odWXdJ1+kdLVJ6aqJaC4k/V1koD9ff4tr8IuYI+aIee9i9q33NBDdhirBWCG/vH8+t1nqQv3OP9xAvquBXzON1/XguwIH+PH+nKPId+0j31X7YXxm0AbSndXeuNCZQeDH7wPzuTYbjPAMx7+y4h3ym5m31fnGFvuReDwIG9X3t0g0O8iv9o0lMc5CHY2km0rMuRj4jW3cnkFHei9KkWiep3QUWg/k50ePwWsKu68bNks+bE6/UwG6zURvuacj9BzyXJ/BHOs03/04R+mE78fL9nA/0L6yzUKGCyogy1YlS59HFtDcoGTZ076yxsLu/SzbFv5rlvytijdsS9fRbKeTNh5PZVjvNPbloGvgv5B0DZpbla5DfiDvGYJ+QGskS7ur92IjHV2idAT8F5OOQPNmpSPkax1dSDqCbkBbQ3Xjv2bJv0Txhj3qOppF1wY66XD1bsu+3n5dX1oYqmvg30a6Bs39StfILyhdX0y6hn5AayRLp6v3MiMdbVc6Av7LSEegebfSEfK1jraRjqAb0NYQHf5rlny9vgZ7BN25RF9fsDvHM/ReMZ+/uil73t77cY7SCd+Pj+zhfuB9ce57IcP2CshymZKlzyMLaD6lZEG+loX7XshwWQVkuVzJ4tsfCprPK1mQr2Xhvg0yXF4BWa5QslzokQU0X1ayIF/Lwn0QZLiiArLsULJc7JEFNF9XsiBfy8JtPGQAbQ2l8d/TSsbhzFNvHebP1XGl1FVHvFk+/P9dkq+eaHsK2eoc/HSfscOD6YdK58gHLuic+wzIBloni9X5Z6H9TKsrwHuj4r2xgrxD+5kqwTvq3K9zPj9lssRuPvJKlWf0bLf6nk9c7yCMeGb5+bzSCE/oe6RXEh6k+XuVOzPH09c/V3WV1FWr9AN+RaL5H9X2IR+4VntkgZ6vKiOfry7Q8LvqwFSnaK4irKD5i+o79tb93Nu8rezmaqkLdoN7wHYDmn0OGLwXXBa4YDc+GwGtrxzoy9nIVaoetpH9CBd/oxS09ZTXU8j23nUXhsqC684K8J6peM+sIO8uxburgrxbFO+WCvKeonhPqSDvWYr3rArynqt4z60g7/mK9/wK8p6teM+uIO+livfSCvJepXivqiDvkB9eCd4hP7wSvEN+eCV4h3yQauDN30vn80LxP48/rjLC2Kkw4voqwqi/jV5P2LLGE9IZ6yL78eKAzwhe+0q9V6t7UySaTvLN6ok2O0zl/TD2Aa14h/ywSvAO+WGV4B3ywyrBO+SHVYJ3yA+rBO+QH1YJ3iE/rBK8Q35YJXiH/LBK8A75YZXgHfLDKsE75IdVgnfID6sE79iPxX6sUrxjPxb7sUrxjv1Y7McqxTv2Y7EfqxTv2I/FfqxSvGM/5u/HGil9CuUhfbLEbs54ssqznNeerHDjupMw+uZt99accRPp5ZQq1RmvBfA8+ymZ4+nrKjfXDX48130HzXU3EO1JpEvQTqI8rCG0UR72NnRQ3nMlPY3yrpF0O+U9T9LTKe9aSZ9Kef8k6dMo7/mSPoPyXiDpMynvhZJ+DuW9SNITKe/Fkj6d8l4i6W7Ku07SJcp7qaTPoryXSXom5b1c0j2U9wpJd1HeKyU9g/JeJekWyrte0q2Ud4Okp1DeqyU9lfJeI+lZlPdaSc+jvBslPZfybpL0Asq7WdLzKe8WSc+hvNdJejblvV7SiynvVkkvorzbJL2M8m6X9FLKe4Okl1PeGyW9ivLeJOkllHeHpFdQ3psl3Ut5d0r6fMp7i6TXUt5bJc3fDnmbpPl72HdJeiHl3S3pjZR3j6TPprx7Jb2O8u6T9AbKu1/SWyjv7ZLm857eIekLKO+dkt5KeQ9I+iLKe1DSl1DeuyR9KeW9W9LnUt57JL2d8t4r6cso7yFJX05575P0FZT3fklvoryHJb2D8j4g6Sspr0bSV1PePpJeQ3lFSV9FeftKeifl1Ur6uZRXJ+lrKK9e0s+jvP0kfS3l7S/pf6K8Bkk/n/Lk6NVdbaPLk62Ku9pGlyddwq620eXJK/+72kaXJ59W3NU2urxxkr6O8sZL+qWUd5CkX0Z5B0v65ZR3iKRfQXmHSvqVlHeYpF9FeRMkfT3lHS7pGygP3z5/NeXhm5KvoTx8u+a1lIcz7m+kPJyFexPl4SywmymvWdK3UN4xkn4d5R0r6ddT3nGSvpXyjpf0bZR3gqRvp7wTJf0GykP/90bKgw/wJsqDP3UH5cGveDPlTZL0nZQHH+gtlIe+6a2Uh77pbZSHvu4uykO/ezflof+7h/Lgo9xLefA97qM8+C33Ux58uLdTHnyZd1Ae+ux3Uh58hQcoD/7Ng5SHvv1dlAef592UB5/nPZQHn+K9lAe/5SHKg2/0PsrrkfT7KQ/+0sOUB18GbaNrg0LnfWxVea4NszofUL9Tjmvw4/MKyn3jpFnSvJcXddQpGt85CidK44j9IhdmL2+3w6TfCQcW3zvhpxAmLgtc5yh5+P1743fC+997uljJ0uyRBTQlpV+L98mNZO2300ukLozHtnhkBU0nna3TJWl+rjZRXbM9/+M3Rl33UBr6czJfmr3MJd/7qpd6eG8nrBnxbmXeYwpD3+Xl97CRnnXgIG3oHWxgd88I3q1j7LrcVlWuiWi2eeTvKWQrv37fXr837mxnBtkZ7Mhhsjpna1tAR82kI9DwWSZW55zqs1WAg8/xxP3XfQDK8plYi6mN4nPNeIyk+0sn3yVG8oEX6sY1+PH5vjxma1Yy8vljo/l8WgM83exL6DN/+dw00Jyv+mTth6BPfjbJos9vMvKn+vfIXhiQhe0dNH32Pk+bpe8Im0efvNkjK2guorbyEk+fy+dMX5uyT4b+jNqEErfBuL+XeHhfSlgz4j2k/UefDD58fgzSz6M+Wfdl0DWwu2cEPgVj1+W2qnJNBb9PYuAPDfEBUfclCrOzncvIzq6lPtmqLb04oKNnk45AY/19T1/brs9PdzS4/3WKhs8ABM11qk9G/8R9su7PLH2g0PeG+KxRfZZeg0dGPs/e9/0/7pM3kFzV1Cf7ymHebBPRoI46ReM78/F1qk8yOGOxi33H4ZyxeLvq87XfuU7J4ztj0UgWb59/tEcW0NxZoT7f6jutoT6fZQXN3dQW30t9uj7z0P3/sOd//GKfP7w+//0GfX6fKleNff7byc4epj7fyu+9OKCjo0lHoOFzcK2+b6vPKQYO8CvXB/B3VUDz8cA4nL8P4/tepFWfH/qGDff5ur1v8MjI33XkbxDzdzD1ebv1BbuztkPnS3M/tknJ4CuH9bOFRKO/H3yUqoe/H/wV1ScZ+DhdvnG+/n4Tj/Of2MM4f52SJzTOt/qGjfZfjvLIAppvK/1azD1Y+qbo59Dnb/LICpofUFv8FPXpuE8bqa5fe/7Hr1yfzz6dwTpGifsdfY4f8+a+OSPeQ/o89Pngg3xe6/gV9fl6fhi65vMD0WYydl1usyrH88oXeeTvKdj2r/qcXGc7PyE7+zX1+dZ+r9bRUaQj0PA4f6MRnk0KD3CAX7k+AGW5D/iD6vP1N+l9frvlel9oPAx+TYXd2/sGj4zOPh6hPn+9ksGVWeiRy+q+gRfqxjX4OYzYx7ZwL+A5UuHxreEcqfDxGs4+sqEJfZ3BPFcX20et0qPPv6kjTD7bWqfkYb/LeP2jzecXQb8+v6hJ6ddiTqMSa4bwJc7zyAqa8WMHaQ+WNLdD66mu4zz/41fOl2Bf0WD8UvLt07jIw5v7/Ix4D+lL4UuAD5/vj/SxYwdp9bgbugZ294ygLWbsulyfKtdU8M+fWK3h6n5bf0vA2c5hZGewI8s5+gsDOjqSdASaTZSnvyXD6+Hcd51nhFv7HLg+jzDq8Srv+UT76vR8C/XJqyW/l8qsV3lOrg1GcoEX6sY1+DmM2JeO/3zljlD6GEN11CkalC0SzTTVtmff57d28X2sVfJuJEygmaH6Tm0Da5Q8/A0o0Br5L9N4LqRW6Zdl2fUc2/sm0yx9NV67cvWe75EVNLOoTZtDfSPu02qqa7Xnf/zK9Z387ScDP6Tkm2fZ6uF9IWHNiPcQXwV9J/jw/gakV1Hfqdt36Jr3ier9i75y61U57he2eOTvKWQrf2hvMM8HzSc7W0195yYjTFsCOjqCdOSbmz7fCM8GhQc4wM/R4P7rPgBli0RzPrVRThb0f/y+k+4vLeeoQ9+eAb8myttEGLWMzj4WUZ+P95T4XMfzVV49yd1TyFYu8ELdun/ncTjfS10O772cQzSoo07RoGyRaC5TfdKGzOUd6PPRR9QqeTcQJtDsUH0+8oFrjZKH51VAa+Svdfv8l2d5ZAHNNUq/Bu1St6VvymtXrt7zPLKC5gXUFr+I+nTcp3Oprhs9/+NXrs9nn85gjqDkmw/Z4uHNfXNGvIf0eejz9bcQeS7mtdTn6z0p0DXv30Gbydh1ufNVOf52cp9H/p6Cbf+q11Wd7VxHdnYj9fnWfq/W0bNIR3pOyHIcrMd9wMHjPtx/3QfwuA80t6s+f5cvIHFDYff+0nJ+Yk/fem2ivI2EUcvo7GMs9flnKxlCclndt5Bc4Ocwoh/Hf75yeP91HdGgjjpFg7JFonm76pOy900H+nzch1olr88PeVD1+drG1yh52D/iZ87Az+5iP7tW6ZdlAc37zH2qUpflmILXyF2953hkBc2HqC3+CPXpuE9nU12Pef7Hr1yfv0Fiozan5FvP8X1rnd8ryoj3kP4FfT748P5YpB+lPl/3ldA170mBz8LYdTlf++rzeazWZEL7kMDP2c7Hyc4eoz7fany2KaCjw0lHev7Z4TnbCM85Cg9wgF+5PgBluQ94ItDn8/kdvu/QWflYoTPGwK+psHt73+CR0dnHVxsG0ryvnvt837f9rO5b6Awx8HMYcb7MOlM8A30y9IR2boLCUySan6g+Wdsg+uQJJAtkOIdkMfgucRvbjJbF5/P8XPXJBj5em5GsQ+aL0Cev9cgKml9RW/kb6nNxT3jf+589/+NXrk/mNm9D9jKXfHNGGzy8NxHWjHgP8YHQJ4MPr3Ug/Sfqk3W/od/r4bkqxq7LnaPKcX+z3iN/T8F2XnmDwuxs53dkZ3+mPtmqLV0f0NEE0hFouC212ve+VuEBDt73Dhx1igZli0RTIwcv6T4Zcob6LqtxQKjvAr+mwu79WYNHRmcfN3j6ZF5v960prDGSK7SmAH4OI/YKrKY8pCcT7rUqr5500lOwtTftN/C5nmspD2n+Xuq6QF2HEQ3uaV2AX5FoJpDt2rQBA9+A0v6Ltj/2X44kTD7/ZbWSh3XF/svqzGXx+2LQ/WqPLMcq/Z5jgMlG1gHb5XkAV+9Cj6ygmThukPZkSXPbx/5Lt+d//Mr5L3x/DXzBEvtsuL/neXjzfp6MeA/xF+G/gA/P4SDdNW6QVvex0DXPUcLnLLcXaZ0qx33zuR75ewqVGU/y3PBksjPYkWW/c25AR4eRjkCzlnRk5b/ovdfAwf4LcNQpGt57DZoe5b+gL+dzTEHL/byVvxjqL8GvifL4DFAto7OPJeS/IH8JlVmu8pxcK4zkAi/UjWvwayT9Lqc8pNl/WanyHO5VRrhDZyesIoyQYSXlIc3+y6pAXYcSjd73ovnxvpfVqn/Nvh8c+g1L9AnAwv0gaM5W/os+R325kod1xWeUL89clpJXFuh+uUeWDUq/Bm1sm5GsQ8YM8F96PbKCZgv1KxeQf4L7xO3K1Z7/8Svnv/D9NRhvlNhn07428+Z9RxnxHuIvwn8BH/bzkb6K/Bft40PX5Xx8X7lVqlwT0az1yN9TqMzYm+e5LyY7u5r8F6t+Z21AR4eSjkDD7wP0GuHR/QlwgB/7OHWKBmWLRPNC5b+gL+cz5nXfbzlmCr2rB35NlMfn22sZnX3cLQeMs2/AZ9MvVXlOrmVGcoW+owN+jaTfpZSHNPsv2qfZ234XZPD5Xey/rAjUdQjR6HOyND8+J+tW1b9mP2YY8F/wLKBP0P5akWjeqPwX7bMtVfKwrkBbT3Q9mclS8soC3S/1yPJWpV8DH7nNSNYhbSX8lyUeWUFzL/Ur95N/gvvUS3V90PM/fuX8F76/Br5gifsr3N81Ht68hyoj3kP6Svgv4MPz/kh/gPwX3e9D1zw3rectfeVWqHI8V7/aI39PIVv5Q998Aj9nO+8kO/sg+S9W/c7qgI4OIR2BZjnpaIkRHt2fAAf4ORrc/zpFw+MO0HxS+S8+30D3/ZbzS+CFunENfjxHxN8A0jI6+7iQ/Jc5ks/rRwtVnpNrkZFcIb8M/BzG2ZLmd/qRZv9lscqztLfFCjeulxBGyLCY8Cw2wrNI4Ym8B378rTn20avJVpoobxHhWZg9nraGwlCduV8532KhrX7auL0ZDh4eK1rYlJGcJfZHn86wXqerZUpXelzdRDRLSX9WvsEShQfX4DcaMTs8eG64HQHdoirBiDxuey3s2cl+jNSF+p1v8XvyPQ2ezzb2GTAWOUbJzPNQV4wfxPZHwRbyH5aoPMsxZOhe8hyNz6dAupMwGthbm29uyfccw6+sK4THwrt8c7kX8Kl9/bLvHlitQ4TuAfj5nieX16lk5Pk0/ian9mUtfYyQH822Axm4T7fy60M+j7F/U7LyU9jWawM6ZlsfT7buG5/qOWIeL4C2htL47+nCUDsaji+xdZg/VwfGt3WF3dfhi/T/4SSf1TNqNP/cxnN4uJfl5oOPVvdSr5XgXvI8NXTG+z/wDNRIuYPlGu2p0fxBidtyzFmuVLyLRHPS+EHMvL7fQzJwH7BC1Y0yB1PZFapuw7nfDsZUq3Cv8mCarDAZ2FyH5V4QvZ4+2yMraFrJH2qXNO9dmUN1neX5H79yYzToz8m8tpC5zCWeo8X9XevhzeveGfEesp6M+Wjw4b28SJ9JzxLooA/omvcX79qvUgiXW6nKNRHNGo/8PQWb+XjUrfeCOduZRnYGO7L0p9cEdMR+G2gWkW5nq3KgX040uE91igZli0QzT7UlBv5VBz/zsP/ZSjZ+5hcpTAZr7B2WvqTuX5Z6ZAXNcrK7ldR+4Z7x2t1mz//4lWvfeM2n0u2b7z3Lvdm+bSrTvul2arjt22JVrhrbtzVkZ5upfZtjhGlNQEezSUeg4Tk0rOGAnsfYvL4z2wh3aIzNuJEH3XGbi3LwJbldhkx1igZli0SzndrABg+tu4/jaV1Mj91Dc33VOj/E81rLVJ7lnIqe1/Xt4fHtUUKa9/UsD9R1DNHweNXHj/uGF5v7+X0jHlu+bA9jSz0nxbrifYFWcx5aFj3ny7LcoPRrMJZts5xD037GYo+soLmJ2v9byI/AfeJ9yXd5/sevnJ/B99fAZyv59p2v9vDm/TcZ8R7Sp8HP0O+P8J73t5Gfoftn3/ulGPsydl1uuSrHe25XeeTvKdiM21H3aoXZ2c6tZGd3VWActSqgo2NIR6DheSur9X3dn+i1Ht++5GMUPl4Peqdag9BzrqF5e6t9sKF5e/DjvUdLCaOWkdfeeM/MHCozX+U5uRYYyQVeqBvX4Md7p+dTHtLsv+i1ur29Hwky+PYjsf+yKFDXQUSjfVjNj33YR1T/mv0zN+C/oL9Dn6D31BSJ5nPKf9F+63wlj++dP8t5Ei3LQR79guZLSr8GfobpPAnuj36vymdLj1O/8nXyT2Dbs6mun3j+x2+4e3UM1qhLvjW5ZR7eKwhrRryH7DmF/7JrDkpiXg/8Mfkv+n0F6JrHQ3o/v6/cAlWuiWiWeuTvKVRmrMd+9LfIzn5C/st8I0xLAzo6iHTkez/Hav5D79sFDvDz+S+gQVn2X36h/Bf05ZCT+0vu5638s1B/yfPuyJtPGLWMzj6+ud9Amn2D2VRmrspzcs0zkgu8UDeuwY/3Ts+lPKTZf9E+zd72uyCDz+9i/2VBoK7xRKNtV/Nj2/2r6l+z3/8x4L+gv0OfoP21ItHAEOG/aJ9trpKHdcXjg7mZyzLgv2hZoPu5HllqDxqqXwufykjWIW0J/Jc5Hll37RU7aJC2SdLsn3C7cqTnf/zK+S/G+7aG7MvA/S23nzRr/2Up1cv9Oe/dQ/qIgwZpdb8PXfv2mpXb87tAleM9v4s98vcUKjPHzmPqsWRnsCPLfmdxQEfjSUegmU86snovXK/DAAe/Fw4cdYqG12FAczy1UU4W9OXsv4CW+3mDvYJl+0vwa6K8eYRRy+js42byX6YWhuqpgeThdTer9UK9r0HPBzmMsyQ9m/KQZv9F+zTV5ndZ9kna/iPvgR/v3/b56NVgK02Ux2Mhg7Fe/3tMrDP3K+dbGI9h2rm9GQ6eeYTHwqaM5CzxXELW71Xp8c9spasmouG+2GpsN0/hwTX4RcyVwczzLtz2ga4S6yvDwYg87i8snkEn+7FSF+p3/tB55C8btCnt7Odg/HSskrlINPscPIhto2AL+TzzVJ7lnGXoXvL8jM8PQprfBTOwt3afn+x7jvVckJaDx+/b1DjA50v47oHVOCB0D3gcoJ8nfhfMN5fGa6/a/7b0i0K+P9uOby7VaiwS8tOMfbKSlW/Ftl4b0PGQs9DUHKOeM9fjXR7j8BqFhb0YzRO281wGdAT8vvXIlysdLQ7oiG1YrzUYyWK156zdN/8H/LznDDSvUTpaGtARr7VDN6CtITr81yz5eC7Zn64hurlEz891jfCX7Se7+gSjfUol7o/0OwG87gCaN3nmLvE+m57f53lB1I0y46jsElU35tyzn6tsL/n2MQD3Mg+mtyhM2dtue8lG1qHr6tD/LI+soLmH5mfvo3l+2MNUqusDnv/xG+4+Bqv3M/X5eSs9vFcT1ox4D9nzh3UA8OH3B5F+mJ4lvX8RuubzprEXgLHrcktVOT47bIVH/p5CtvKHztLm9yrfQXb2ARrXWI0JVgR0xL4naMq9N6HHDY4Gz1Ndwe+PFYnm46otmZq5vO3efTzAMpUwgeYRhSn7dxkG2rfsZR267oT2bb5HVtB8nuzuUWq/cM/4ve5ve/7Hr1z7xufzVbp9Y97V0L49WaZ90+3UcNu3uapcNbZvXyI7+za1b7OMMK0I6GgO6Qg0C0m3eh5i13u3RIP7VKdoeB4CNE+ptiT7+QW//6bXGfmZ/2mF/DeruZSQ/8aygubnZHe/oPZLrzf1n9/k+R+/6L8Nr337nzLtm26nhtu+zVHlqrF9+xXZ2R+pfbN6j2ZFQEfzSUeg4b2S2BvAc4d4fnjfgNW67yyFG9fsdyKP9w/puQiMlbld1ucojFP18DkKY2SuHu/ralp3H9fuN5AOve/iW4+p1jl8XntYoPIs22q99uZ7t8W3hxRp3i+6MFDXsUSDuam6AD/ezziebMBmbm9gv6iepyz3Ds6hhMk3T6nXDVhXPE9pNS+tZYHu53lkOVLp12CPeLvlOgfuD/yMuR5ZQXMMrf0dJ2neK8/vu7R5/sevnJ/B99dq3hNzYLi/Sz28+b2UjHgPed8Dfgb48Lwc0q0HD9Lq9/ihaz7LQL/n7iun34NsKvi/FWd1tkHoWyvs755IdgY7sux3lgR0dCzpCDQ8L2/lP+j+BDjAj9cn6xQNz92DZga1UbzvYtc+8IJ/bdXqHbvQ2ir48Z5Wft9Fy8j7I5z9t0r+VCrTq/Isx+P6PSVcg5/DOEXSvZSHNPsvej9Fte1zNVpvLus/55037/Hw7YmuBlvhZ3cW4THYW9/G4zr8yvkWxnvG27i9GQ4e470brUZylrjvy3q/qB4D6rF8Bffkld3DzWPy0YaZ5x+4HQHdrCrBqPeHWtmzk/04qYvfRdlOvqfFfnf2GTAWOU7JzN9T+i35xVdKOuQ/zFF5lv7qnt5z8M0t8f4s3ntpYG9tvv1zvudYv4Ple3cSNC9UPrWvX/bdA6sxTOge8Fypfp547yXfK6RnkSzal7X0MUJ+NNuO7z0wK78+5PMY+zclKz+Fbb02oGO29ZvVfJ1eP5yr7gWPF/hdAwt7Mdqv7f1Gij4ngvenvkHpaGFAR2zDev2yprD7/sFmyYfNsd9VU9h932tzYej8QI3wHyvX/I6SwXx4idtazCkuVLyLRHMfzXHxXHFPYff9wDw3grpRZiyVXaDqtpv7bhvyjlO5c6RB806FKXvbbStZzt3o85GmeGQFzXvIX3nIMx/cSnU9knK+uBL7ZEPzxcy7GuaLP1Vmvhi6fibOFz9MdvYI+exW/m5ovth3HvMs0u0UVU77xI4G96lO0aBskWgeVW1J9v7PQPum18OmKNn4mf+y+XrYQPtm5evp/mWuR1bQPEF29w1qv/S3Vt3/P/X8j19cDxte+/aTMu2bbqeG277pdbRqbN+eJDv7KbVvrUaYlgR0NIV0BBoeX2KNhd8/1Pty66menoxxh84hYdzIg+64zUU5+JLcLuv1trGqHl5v+43ad6Np++eW6gfSPH/D423fXFy1zt/wvNNofOfXZzugOY5o0O6XezcXNH819/P7vGPUcmfH4UPmoTGqnjNiXfE7lAb30yvLcR797qI5ZKh+DcaybZa2q/2M2R5Zd53ndMggbZOk+f2EIee0ef7Hr5yfwffXYA+Td/+271uavB8yI95D+jT4GeDD74gifcQhg7S6f9bfgnHPCMa+5fZyzlXl+AzVSnwLJfQtUd4LOpbsDHZkOc+7KKCj40hHoOF5K6tz2vQ8L3DwOW3AUVcIr9eA5nhqo3jNDXJyf8n9fDWcd8J7gLWMvDbm7H+G5LdSmakqz9LvAy/UjWvwcxhbJD2V8pBm/0WvpVXbfiFL+9fzE5H3wI/X93x7y6rBVvi9hymEx+D9y/59Lqwz9yvnWxjvvevg9mY4eIzX7VqN5CzxPoSs993oMeBUpasK7scouxeu3HvaEXPEDDxon7i9Bt2UKsHoeyfNot1wsh8vdaF+58NtJB/foB3sYN8MY77jlcxFopl86CC2LYIt5KfNUnncNvYUKnMv+awpn++GNO9vMrC3Dt/YxfccY9xRF5CD1+UvV2MXn//juwfV8E4l+22dSkaey5xCsugxg6UvFxqvsO343luwGj+FfEtjP9JqHa+Dbb02oGO29evUvOhcpY/Z6l7wuIz381rYi9GeyA7fHjDg5306oLle6Wh+QEdsw3ovk9X+TqM5kw7fnLSeM+E56Zv3ML/uO0NS7wEzkqXdaE9Qh29/APD79gS9QelocUBH/J60PqOQ26waKXegXBt/r6nEfS3m7hcr3rwWeDfNJfNcc09h9z2XPCeKulHmQCq7SNVt+a09xqT3ii7xYLpfYbL6fo7V94uXKv23eGQFzYM0X/5uWneBPcyguj7h+R+/cnMVvDZgsAeh355xhgbu73IP75WENSPeQ874wLoM+PB3vpH+OD1L+rwS6LrcN7595Rarck1Es8wjf08hW/n1fpTlCnP/3kmys0/QmM1qvLMsoCP2q0EzhXTbosrpMZGjwX2qUzQoWySaz6m2xMD/7eBnHvbfomTjZ/4xhclgva7D0tfX/YtvfyFovkp29zi1X3oN1P3/I8//+JVr3/gbm5Vu35h3NbRvT5Vp33Q7Ndz2rVeVq8b27RtkZz+i9m2GEabQt9daSEegmUu61XMsoOf2TX+LGjQ8xwKan6m2xGDuxOu/6XdJ+Jn/ZYX8N6t5Iu2/zfDICpr/ILv7HbVfuGe8r+Zvnv/xi/7b8Nq3v5Zp33Q7Ndz2rUWVq8b27fdkZ3+j9s3qe8LLAjri9xNAM590O0OV03M6PO7W7yegLL+vXJT5fLQlBnvpvP7bDCUbP/P1CpOV/2a1b1D7b4s9su46R4fWUw6UNL9/0EJ1He35H7/ovw2vfTvq0EHaPbVTw23fZqty1di+jSc7gx1Z7tdZFtDRDNIRaBZSHvai8fsJeH54n1qLEe7QHkz2O/VY27c+g7lAbpf1+wkHqnp4TvIUagMbPLTuPj5WN5Dm9VdeL/OtpVfr+utoPxfDtyYFmuOJRu9N9Z1fAZpTVT+Y/bpMn/ecAf0+Bq8xnUGYuCxw6TVf1hWvMVmtKWpZ9J4KlmVWBXwfyzVq/gahq7fXI+uu91+o/V9IfgTuE38/5hzP//iV8zP4/lqdW6DHyQs9vHkNKiPeQ/w6+Bngw2toSJ9NfobuU6Drcmfn+srNVeW4L1rgkb+nkK38eq1Ur/k521lCdnYO+RlW/c6CgI6OJx2Bhtcdrfwe3Z/ovVS8t6RO0fDaJGg2UxvFe+b4/QTfvhirM8FC+2L4TDDfO6ZaRt7b1kgYZ1CZVpVn6ffp90txDX4OY5ekWykPafZf9F64anuvwmivUKtvfSnyHvjx/jzfOzjVYCv87LYQHoN32NtGOkdr/I5SG7c3w8FjvO+u1UjOEvd9Wb+foMeArUpXFdxPXfadIR6TjzbMDg+eG25HQNdSJRj13n4re3aynyB1oX7nW7yRfE+L96vYZ8BY5AQlM58DdOhhg9juFGwh/2GKyrP0V/f0Xp1vbon31vK+eQN7a/PNrfmeYz23puXgubV3KJ/a1y/77oHVGCZ0D3gtSD9PvG+e75VeJ+d+jdsGKx8j5Eez7fjeO7by60M+j7F/U7LyU9jWawM6Zlv/mJqv0/sjetW94PECvydmYS9G79q0+d4tAH4eY4PmM0pHcwM6YhvW+zNqiI7P+XT5sDn2u2oKu7+z0FwYOj9QI/wPkGvjc4ZK3NZiTnGu4s1rx4/THBfPFfcUdn+Xg+dGUDfKHEBl56i67ea+B+aLwU+/gzLPg+mbCpPFe2KWczf6W/JdHllB812ax/u+Zz64h+r6Zcr5Yp6Pq/R8se8dhL05X/yLMvPFwPRMnC9+iuzslxVYlw7NF7NfBZoW0m2XKqd9YradOkWDskWi+Z1qSwz8H+96WJeSjZ/5P1RoPczK19P9i2/fOmj+l+zuT9R+4Z7NpbrqD9v9f/zietjw2re6wwZp99RODbd90+to1di+/ZXsDHZUTziyxrQgoKMu0hFoeHyJNRZ+d1zv2amnenoyxh36fgPj5vG3+7E9Ix++JLfLer3tAFUPr7cdLPcI+240rbuPN9K+Gz22Ds3FVev8zWg/r8FnO6A5gWj0N5l95yqA5gSyARs/v887RtX7jHiMejJh8o1R9ZwR64rff7f6RpKW5QSPfkHTovRrMJZts7Rd7WdM9cgKmg6a951GfoSed3H/z/L8j185P4Pvr4HP5v1+xnwP74WENSPeQ/o0+Bngw+/3I91Lfobun6Hrcmfn+sr1qnJNhd2/l2Lk4w0Zt6NufR6Bs53pZGezyM+wmucNfU/vBNKR79xMq/PQ9TwvcPAZ4sBRp2h4vQY0i6iN4jU3yMn9Jffz1XBWFe8B1jLy2piz/7OoTpSZofIs/T79Pguuwc9hnCnpGZSHNPsvei2t2vYLWdq/np+IvAd+vL7n21tWDbbC7z10ER6Dd2v797mwztyvnG9hvPeujdub4eAxXrdrNZKzxPsQst53o8eAM5SuKrgfo+xeOB6TjzbMDg+eG25HQNdVJRj13iAre3aynyh18TuK15HvabFvkH0GjEVOVDLz+SSFCYPYXiHYQv5Di8rjZ7anUJl7yefX+XwKpHnfjdU+g6kBjPwc63eNtRy8XnyL8ql9/bLvHljNnYXuAZ+ho58n3nfD90rPs3K/xm2DlY8R8qPZdnz76a38+pDPY+zflKz8FLb12oCO2dbvVfN1eg/bVHUveLzA+0wt7MVyr57em6TPX+G9SQ8qHc0O6IhtWO+xqSnsvr+mWfJhc+x31RR2n3trLgz9xliN8G+Sa+P3Z0vc1pY78wk0H6E5Lp4r7insvheM5w5QN88ZoOwsVbfd3HfHkL3ieg/bHA+mTyhM2dtuh9V3vFt5bhz6n+mRdddeNJrH+xzNB8MezqK6vun5H79yYyiej6v0fDHzrob54m+UmS+Grkc6X6y/E1aN88WPkp19k3x2K393XkBH7FeBpot0O1OV0z6xo8F9qlM0KFskmu+rtiR7/6ej5FsPm6lk42f+R+brYQPtm5Wvp/sX374n0PwL2d3PqP3S5364///g+R+/uB42vPbt92XaN91ODbd90+to1di+/YLs7A/Uvp1lhGleQEczSUeg4fElMPjeCe0hXVqtZYfej+C9QciD7rjNRTn4ktwu6++kN6l6+P2op9W+G03r7uMq2nejx9ahubhqnb/heafR+L6Xb0wLmhOJRq+5+t7LAs2BMldn5+f3eceovnNTQHMQYfKNUfWcEeuK35+xmpPQsug5WZblcKVfi71AlnNc2s9o9cgKmqNp3rdZ0ryvhs99b/H8j185P4Pvb/Y+24CfgT5Dn83EvPl8yIx4D+nT4GeAD78vgvTUCYO0un/W57v6zoTyletV5ZqIZo5H/p5CtvLPVXjmKszOdo4jO4MdWfY7cwI6OpF0BBqet7Jaf9f9iV6L4bnpOkXDc1u7+nNqo3jNjffd+ObVrd51D82r87vuvr3TWkZeG+N9NyUqc7rKc3LNNJILvFA3rsGPz+Q5nfKQZv9Fr6U53N1GuEP3o5swltsvxP5Ld6CuRqKBjdUF+BWJZpHqX7Mfb/d5zx0AFh5vg2aZ8l/0uszpSh7WFa8hn565LAPvJ2lZoPvTPbKsUfo1aNM6jGQdsldpX1U3ywqac6lfOZ/8E9wnHhdd6vkfv3L+C99fg/5qyN4U/X4t8+az0TLiPaRvgv+i3+MuUnob+S96XANd89hO+/2+ct2qXFNh93fSLMd6obE9v+O9kezsUvJfrPqdloCOGklHoOF16h4jPLo/aaS0+/nmlxsVPp5fvkr5L+jLIWdDYfe+33JuFrxQN675vSrkzSSMWkZnH+NqB9I8t9FOZVpU3t6ef4F+08y/TDTCHZp/mUgYhzv/MjFQVwPRaP9F8+M+59UV8l/wLKBPABb2X0Bzk/JftM/WouRhXYHW6H52+WRp8OgXNLcp/Rr4yF2Wtqv9l5JHVtDcQf3KneSf6P7f/f8uz//4lfNf+P5a7CVyvE+VuvSeH+Z9GmHNiHcr84b/Aj7IL1L6QfJfQAd96H1f7hmZLmnGrsvpPUpNRDPdI39PoTJjPfBztvM2srN3kf9iNQc5PaCjBtIRaCox/1JSeICD51+Ao07RoCz7wR9Q/gv6cpYTtNzPW/kvof6S/Rf9vnVDYXcZnX28ZN+BtLN/9KN7en+oZCRXaH8k+DWSfn3nDZ9MuFtUXjX7XadIXG5/8f5Eo23Xt78YNF9W/Wv2+6L7utjv0mNaHleC5nHlv2ifTe9RZF2B1qb9GPDFtCzQfatHlieVfrP3M/raKjFXDf+l3SMraL5P/coPPf5JJ9X1q5T+C99fA1+wxP2Vnitk3jMIa0a8h/SV8F/AB/lFSv87+S+634euea5Av4vjKzdVleO5euN96K2+sUq3wuxs58dkZ78i/8Wq3wmdY7U/6UifEeXwdBrhaVd4gIPHucBRp2hQtkg0v1f+C/py9l9875hUwztbvBakZXT2cTT5L3h+J1GZKSrP0g8I+WXcj01WsvLYfE/+i5X9h+4H+12+9w58/kspUNd+RKP3QGl+vL5Rd/hAbLe+MeC/tEld6BOAhftB0DQQJi4LXFOUPKwr0Bo9Xx0+WaD7KR5Zxin9thlgsmxLeM7E1TvZI+uu88YPH6SdIOmGwu5zNu7/iZ7/8Svnv/D97che5n7/Bf0A7m+Hh/c0wpoR71bmDf8FfJBfpPSJhw/Sgg76gK6Bncd2jF2XK6lyTUTT7pG/p5Ct/B0KT4fC7GznCLIz2JFlv9Me0NF+pCPQsP8y2QiP7k+AA/x4jFWnaHjfGmhaqI1ysqAvZ99A9/2WYyY9XsU1v7eBPPaxtIzOPq6VxoT9l5OozGSVZ9mWghfq9vkq0O9kykOa/ZepKs9y/nFP59mzj+V7P5n9l5ZAXfVEA7urC/ArEs0s1b9m78MN+C96z0g5n2qe8l/0vNtkJQ/rivcoWLUfWhbofrJHliXm/uHAu8FWsvJcrKt3kkdW0KykfmU1+Sd6bsz9v8XzP37D3f/Snr3MJe5DcX/bPbzZz8iI95D+G/4L+CC/SOk+8l9AB31A18DunhH4X4xdl9P7AfjshDaP/D0FW1+hXWF2trOO7GwL+S9W/U5bQEf1pCPQcHs8yQiP7k+AA/x8/ku9wsf+y6XKf0Ffzmszuu+3HO+H/BfwY/+F909oGfv3d48Z1MmQX0+GgGuEabMwqhHljaHrkrpuVdedqnyX+r9b/X+6uu5R12ep6151PVtdz1XX89X1QnW9WF0vVdfL1fVKdb1aXa9V12er63PV9fnqeoO63qSu+9T1VnV9obq+WF1vU9eXqevL1fUOdb1TXV+trq9R19eq6+er6xeq6xer6+vU9avU9Q3q+jXq+kZ1fbO6fp26vlVd366u36iu71DXd6rrt6rru9T1Per6PnX9dnX9gLp+t7p+SF0/rK4/pK4/qq4/oa4fUdefVddfUNdfVNdfUdePq+tvqOsn1fV31fXP1PXP1fV/qOs/quv/Vdd/Utd/kWv+1UjcI3F7aVpHx5auti2t7a0bS23TN3V3ljo6N03rbu1u7ezu7Gvrbm/f0t3R3TV90/Su0vTWjvYtrVs7p7dvlca2uZBdu92dXV2l0SLzzyokc+kf+7X+PEP9Fcdk39e7OpsL5W299I/9Wo/JUAdTCqPD1o/NUH9TR4mtT8pQf9ONZB6TsczTMpS5YGiP+2Yoc1dhdDyDYzKUuX2UyJylbbcVKvMM/sO2nXG/6Abf35P6XN/lDu47VuIWiUsSt0pckHiMxB0Sd0rsMPbHct0s8SSJZ0h8qsSnSTxT4tMlPqMweICzi8+U+CyJnyNxr8SzJJ4t8RyJ50o8T+L5Ei+QeKHEiyReLPESiZdKvEzi5RKvkHilxKskXi3xGonXSrxO4rMlPkficyU+T+LzJV4v8QaJN0q8SeLNEvdJvEXirRJfIPGFEl8k8cUSXyLxNokvlfgyibdLfLnEV0i8Q+IrJd4p8VUSXy3xcyW+RuLnSXytxP8k8fMlfoHEL5T4RRK/WOKXSHydxC+V+GUSv1ziV0j8SolfJfH1Et8g8aslfo3Er5X4RolvkvhmiW+R+HUSv17iWyW+TeLbJX6DxG+U+E0S3yHxmyW+U+K3SPxWid8m8V0S3y3xPRLfK/F9Et8v8dslfofE75T4AYkflPhdEr9b4vdI/F6JH5L4fRK/X+KHJf6AxB+U+EMSf1jij0j8UYk/JvHHJf6ExJ+U+FMSPyLxpyX+jMSflfhzEn9e4i9I/KjEj0n8RYm/JPGXJf6KxF+V+GsSPy7xExJ/XeJvSPxNib8l8ZMSf1vi70j8XYm/J/H3Jf6BxD+U+CmJfyTxjyX+icQ/lfifJf4Xif9V4maJfy7xv0n8C4l/KfG/S/wriX8t8W8k/g+Jfyvx7yT+T4n/S+LfS/wHif9b4v+R+I8S/z+J/1fi/5P4TxL/WeK/SPxXif8mMcLfJS5IfzJG4hqJ95F4fBJqpaPN2udtLgwsNmfdj9eNGR3jnCxlrh8lMo/JUOb9RonMNRnKvP8okXmfDGVuGCUyFzOUuXGUyLxvhjI3jRKZazOU+YBRIvPEDGU+cJTIfEKGMo/Noczjcijz+BzKfNAokZnHBf+ozAfn8D4fkkOZD82hzIflUOYJOZT58BzK/KwcynxEDmU+MocyH5VDmY/OoczPzqHMzTmU+ZgcynxsDmU+LocyH59DmU/Iocwn5lDmiTmU+aQcynxyDmU+JYcyT8qhzJNzKPOUHMo8NYcyt+RQ5lIOZW7NocxtOZS5PYcyd+RQ5s4cyjwthzJ35VDm7hzKPD2HMs/Iocyn5lDm03Io88wcynx6DmU+I4cy9+RQ5jNzKPNZOZT5OTmUuTeHMs/KocyzcyjznBzKPDeHMs/LoczzcyjzghzKvDCHMi/KocyLcyjzkhzKvDSHMi/LoczLcyjzihzKvDKHMq/KocyrcyjzmhzKvDaHMq/Locxn51Dmc3Io87k5lPm8HMp8fg5lXp9DmTfkUOaNOZR5Uw5l3pxDmftyKPOWHMq8NYcyX5BDmS/MocwX5VDmi3Mo8yU5lHlbDmW+NIcyX5ZDmbfnUObLcyjzFTmUeUcOZb4yhzLvzKHMV+VQ5qtzKPNzcyjzNTmU+Xk5lPnaHMr8TzmU+fk5lPkFOZT5hTmU+UU5lPnFOZT5JTmU+bocyvzSHMr8shzK/PIcyvyKHMr8yhzK/Kocynx9DmW+IYcyvzqHMr8mhzK/Nocy35hDmW/Kocw351DmW3Io8+tyKPPrcyjzrTmU+bYcynx7DmV+Qw5lfmMOZX5TDmW+I4cyvzmHMt+ZQ5nfkkOZ35pDmd+WQ5nvyqHMd+dQ5ntyKPO9OZT5vhzKfH8OZX57DmV+Rw5lfmcOZX4ghzI/mEOZ35VDmd89SmSuHZOdzO/J4X1+bw5lfiiHMr8vhzK/P4cyP5xDmT+QQ5k/mEOZP5RDmT+cQ5k/kkOZPzpKZG7OUOaPjRKZixmOMT6eQ9v+RA5l/mQOZf5UDmV+JIcyfzqHMn9mlMhcl6HMnx0lMtdnKPPnRonM+2Uo8+dHicz7ZyjzF0aJzA0ZyvzoKJG5MUOZHxslMjdlKPMXR4nMB2Qo85dGicwHZijzl0eJzGMzlPkro0TmcRnK/NVRIvP4DGX+2iiR+aAMZX58lMh8cIYyPzFKZD4kQ5m/PkpkPjRDmb8xSmQ+LEOZvzlKZJ6QoczfGiUyH56hzE+OEpmflaHM3x4lMh+RoczfGSUyH5mhzN8dJTIflaHM3xslMh+doczfHyUyPztDmX+QocxJVYV9pK4TSP4xogP3XzEJ+yahNglunt7NW7t5XDev6eb53LyXmwdy8yJunsCNm9040o2r3DjD+d3OD3V+mfNTXL/t+jHXrrt2zj337jlwduH01JyEY5JwbBKOS8LxhOtbEtcnAPdLwv5JaEhCYxKaknBAEg5MwtgkjEvC+CQclISDk3BIEg5NwmFJmJCEw5PwrCQckYQjk3BUEo5OwrOT0JyEY5JwbBKOS8LxSTghCScmYWISTkrCyUk4JQmTkjA5CVOSMDUJLUlwim1NQlsS2pPQkYTOJExLQlcSupMwPQkzknBqEk5LwswknJ6EM9z9TcKZSTgrCc9JQm8SZiVhdhLmJGFuEuYlYX4SFiRhYRIWJWFxEpYkYWkSliVheRJWJGFlElYlYXUS3Hfi3XfT3XfE3Xe13Xem3XeX3XeI3Xd53Xdq3Xdb3XdM3Xc93Xcu3Xcf3XcQ3XcB3Xfy3Hfj3HfU3HfF3He23Hen3HeY3HeJ3Hd63Hdr3Hdc3HdN3Hc+3Hcv3Hcg3HcR3HcC3Ln57hx5d666O2fcnbvtzqF25zK7c4rdub3uHFt3rqs759Sd++nOwXTnQrpzEt25ge4cPXeunDtnzZ075s7hcudSuXOa3LlF7hwfd66NO+fFnXvizgFx52K4cyLcuQnuHAH3Xr17z9y9d+3eQ3bv5br3VN17m+49Rvden3vPzb335d6Dcu8Fufdk3Hsj7j0K916B22fv9p27fdhuX7Lbp+v2rbp9nG5fo9vn5/a9uX1gbl+U2yfk9s24fSRuX4XbZ+DW3d06tFuXdeuUbt3OrWO5dR23zuHm/d08uJsXdvOkbt7QzaO5eSU3z+LmHdw43I1L3TjNjVucH+/8WufnOb/H+QGuX3T9hGs3XTvyY3q2Lpb4SIk37ty55dLLdzbv3N68sa+v+bkX7bywefvVW3Zs3bbd3cL+Z9r9nN2mKTdfyh0u12fu2LHxec0XXda35Zrm7VftbN6+tXnT9qsu67uSC70qJbPb0jB7W5pCD6Qp9IE0hSbvm04XN6Us9+Z9U4C8J02hB9IUep8UOkKuN2/ctq1fpiuv3LJj5/pLN16zftNFO9dfedG1W7jYh9Lw+nSaQl9OU+jJNIX+OU2hX6Q0i2fXpis3tTYFyM6UzN66X7pyP01Z7qT9UwhX2j8ds1PTMDszJbOrU5Z7KGW5R9II92hKZo+nYfZkSmbnNaQrd0fKck+lLNfcmK7c+Y0plLklTaHL0xS6O6VYT6Qs196UrtwVTSmEuyZNoZemKXR9mkKvT1PojjSF7ktT6F1pCn04TaFPpin0uTSFvpSm0BNpCn1HCo3QEftBGl7/nabQn1M+iTUHpGBWf0A6Zh2q3PItG/u27Gjuu6iv+bLtO5t3JJfNTrF9G3du5HJvSlnuhAPT4Tz5wBRKaUlTaFFKhOelYbY5TaGXpER4S8pyt6UB+eY0hT6WEuGXU5Z7PA3IJ9MU+n1KhDVj05WrHZsCZGOaQp0pEU5Pw+yMNIXOS4nw0pTlrkgD8rlpCt2WEuH9Kcs9kAbkQ2kKPZ4S4Y/TMPtZmkJjxqVDeFjKckeMSwHymDSFzkiJcFXKcuvSgFyfptALUiJ8fcpyb0gD8i1pCn0iJcK/pyw3bnwKkBOk0Ahd9qPS8JoohY7ZXbBLr9q286LLtz0vLN2kNBznjk+nyoVpmF2WktmLUpZ7aRqQ16cp9I6UCD+Vstxn04D8YppC/5YS4V9Slvt7GpD7HpSi0HEHpUN4ScpyL0gD8mVpCr06TaE3SqFUbc+daTh+LKUiP5WG2Q9TMvtJGmb9GztSMBuXstwhB6cAeUSaQtNTInxBynI3pQF5e5pC90qhVPb/jjQcv5BSJ19Kw+zXKZn9JWW5v6cBue8hKQodd0g6hNtTlntJGpCvSlPopjSFbk9T6C5JpDL++9Jw/GxK7T+ahtm/pmT2izTM9jk0HbO6Q1MwOzklsxkpy52eBmRvmkKbUiJ8e8pyH00D8tNpCn1NCqV62L6RhuNvU+rk92mYHXRYOmbHpyx30mEpQE5NU2hhSoQ3pyx3TxqQD6Qp9GEplMokP56G4/dS6uSpNMz+lpLZARPSlRs/IQXICWkKTUuJcGHKckvTgFydptDOlAhvSFnuxjQgb01T6OGUCL+UstzX0oD8VppC/5USYe3h6crtf3gKkGPTFJqaEmFvynJz04BcnKbQthEgLPx/Wu3Jp6xKBQA=", "debug_symbols": "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z51O2XOnU/bc6ZQ9dzplz51O2XOnU/bc6ZQ9dzplz51O2XOnU/bc6ZQ9dzplz51O2XOnU/Hc6VQ8dzoVz51OxXOnU9kcb9jiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47nYrnTqfiudOpeO50Kp47narnTqfqudOpeu50qp47nermeMNWz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6VQ9dzpVz51O1XOnU/Xc6XR67nQ6PXc6nZ47nU7PnU7n5njDnp47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQ6PXc6nZ47nU7PnU6n506n03On0+m50+n03Ol0eu50Oj13Op2eO51Oz51Op+dOp9Nzp9PpudPp9NzpdHrudDo9dzqdnjudTs+dTqfnTqfTc6fT6bnT6fTc6XR67nQKm+dSp9f0jnfsa3rHS/Y1veMt+5re8Zp9Te94z76md7xoX9M73rSv6R2v2tf0rnet53qn1/Sud63ngqfX9K53reeKp9f0rnet55Kn1/Sud63nmqfX9K53reeip9dsrnet56qn12yud63nsqfXbK53ree6p9dsrnet58Kn12yud63nyqfX9K53refSp9f0rnet59qn1/Sud63n4qfX9K53refqp9f0rnet5/Kn1/Sud63n+qfX9K53recCqNf0rnet5wqo1/Sud63nEqjX9K53recaqNf0rnet5yKo1/Sud63nKqjX9K53recyqNf0rnet5zqo1/Sud63nQqjX9K53redKqNf0rnet51Ko1/Sud63nWqjX9K53rediqNf0rnet52qo1/Sud63ncqjX9K53red6qNf0rnet54Ko1/Sud63niqjX9K53reeSqNf0rnet55qo1/Sud63noqjX9K53reeqqNf0rnet57Ko1/Sud63nuqjX9K53refCqNf0rnet58qo1/Sud63n0qjX9K53refaqNf0nndtcN0bFVz3RgXXvVHBdW9U2Dzv2uC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6Nyq47o0KrnujguveqOC6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nfmT8/kte4A781ve63fmt7yr78xvef/emd/y/r0xv+kO1jvzO9+/prtSU6zX/Dn87R977T2Et9o97J9fvX+oNb2t4WpN73a4WtNOAK7WtG+AqzXtMuBqTXsSuFrTDgat1nR3Kl6taXcEV0vlpUw3qOLVJiq1VF7KdI8qXi2VlzLdpYpXy+Slouk+VbxaJi8VTXeq4tUyeam4JSq1TF4qmu5Wxatl8lLRdL8qXi2VlzLdsYpXS+WlTPes4tVSeSnTXat4tVReynTfKl4tlZcy3bmKV0vlpUz3ruLVUnkp092reLVUXsp0/ypeLZWXMt3BildL5aVM97Di1VJ5KdNdrHi1VF7KdB8rXi2VlzLdyYpXS+WlTPey4tVSeSnT3ax4tVReynQ/K14tlZcy3dGKV0vlpUz3tOLVUnkp012teLVUXsp0XyteLZWXMt3ZildL5aVM97bi1VJ5KdPdrXi1VF7qoPJSB5WXOqi8lOkmYrha013EeLVUXipTeSnTTdN4tYlKLZWXMt03jVdL5aVMd07j1VJ5Kdt91nC1VF7Kdlc2XC2Vl7Ldww1XS+WlbHd8w9VSeSnb/eFwtVReynY3OVwtlZei6j2PVL3nkar3PFL1nkeq3vNI1XseqXrPI1XveaTqPY9UveeRqvc8UvWeR6re80jVex6pes8jVe95pOo9j1S95ztV7/lO1Xu+U/We71S95/uWqNQyeamdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z3eq3vOdqvd8p+o936l6z/d12qJrDD9eXOPPf/OldZn9c0PrMu9QNaW31s9TfNa6zPvTDa3LvDvd0LpMzutqTeu0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c2h7Mrxrb0xveNfemN7wrr0xveFd25/+MLxrb0xvedd2nykclndtf3rLu7Y/veVd25/e9K7tTm9613anN71ru9Ob3rXd6U3v2t702fSu7U7vetdm17s2u9610zvLsdO73rXZ9a7Nrndtdr1rs+tdW1zv2uJ61xbXu7a43rXTe7ux07vetcX1ri2ud21xvWuL611bXe/a6nrXVte7trretdM7g7HTu9611fWura53bXW9a6vrXYvo+QzxPX04CnD6/u9GIdo4H5w+uZ7+cD19dj19cT19dT396Xj6hOhFfHD64Hp6z7s2bYZ3bfe3SdNmeNfemN7wrr0xveFde2N6w7u2+xuNaTO8a29Mb3jX9qcPhnftjekN79ob0xvetTemt7xre88UEqIr7MHpLe/a/vSWd21/etO7tju96V3bnd70ru1NH03v2u70pndtd3rTu7Y7vetdi+gpenB617s2ut610fWuja53bXS9a3fXu3Z3vWt317t2d71rEd1FD07vetfurnft7nrX7q537e561ybXuza53rXJ9a5Nrnctorvoweld79rketcm17s2ud61yfWuPVzv2sP1rgX052zXQHGrO3D6/u9GAfpznpw+u56+uJ6+up7+9Dw9oD/nyemD6+mj6+l319O73rXZ8K7t/zZpNrxrb0xveNfemN7wrr0xveFd2/+NxmJ4196Y3vCuvTG94V17Y3rDu/bG9IZ37Y3pLe/a7jOFYnnX9qe3vGv701vetf3pTe/a3vTV9K7tTm9613anN71ru9Ob3rXd6U3v2u70rndtdb1rq+tdW13v2up6156ud+3peteernft6XrXArqLnpze9a49Xe/a0/WuPV3v2tPzrj02z7v22Dzv2mPzvGuPzfOuPTbPu/bYPO/aY/O8a4/N8649Ns+79thc79rgetcG17s2uN61weeuff1v/9+f/+e//Pn/+td//vfXn/jP/+P/+5f//td/+be//Phf//r//4//+r/87X8B" }, { "name": "view_private_value", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "amount", "type": { "kind": "field" }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "amount": [{ "start": 0, "end": 1 }], "owner": [{ "start": 1, "end": 2 }] }, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [2] }, "bytecode": "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", "debug_symbols": "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6LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruRd+96LsXffei71703Yu+e9F3L/ruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w767qDvDvruoO8O+u6g7w76bnwg8P42GDqYOrh0sHSwdXDr4NHBq4NaTmg5oeWElhNaTmg5oeWElhNaTmg5oeWklpNaTmo5qeWklpNaTmo5qeWklpNaztJylpaztJyl5SwtZ2k5S8tZWs7ScpaWU1pOaTml5ZSWU1pOaTml5ZSWU1pOaTmt5bSW01pOazmt5bSW01pOazmt5bSWs7WcreVsLWdrOVvL2VrO1nK2lrO1nK3lHC3naDlHyzlaztFyjpZztJyj5Rwt52g5V8u5Ws7Vcq6Wc7Wcq+VcLedqOVfLuVrOaDmj5YyWM1rOaDmj5YyWM1rOaDlqyKGGHGrIoYYcasi//e8HHWwd3Dp4dPDqoJajhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGjI+YGG/Ntg6GDq4NLB0sHWwa2DRwevDmo5oeWElhNaTmg5oeWElhNaTmg5oeWElpNaTmo5qeWklpNaTmo5qeWklpNaTmo5S8tZWs7ScpaWs7ScpeUsLWdpOUvLWVpOaTml5ZSWU1pOaTml5ZSWU1pOaTml5bSW01pOazmt5bSW01pOazmt5bSW01rO1nK2lrO1nK3lbC1nazlby9laztZytpZztJyj5Rwt52g5R8s5Ws7Rco6Wc7Sco+VcLedqOVfLuVrO1XKulnO1nKvlXC3najmj5YyWM1rOaDmj5YyWM1rOaDmj5aghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrx+Ysi77++D5yM+HVw6WDrYOrh18Ojg1cHBwZ8Y8i8Mhg5qOa3ltJbTWk5rOa3ltJbTWs7WcraWs7WcreVsLWdrOVvL2VrO1nK2lnO0nKPlHC3naDlHyzlaztFyjpZztJyj5Vwt52o5V8u5Ws7Vcq6Wc7Wcq+VcLedqOaPljJYzWs5oOaPljJYzWs5oOaPlDJZTHx86GDqYOrh0sHSwdXDr4NHBq4NaTmg5oeWElhNaTmg5oeWElhNaTmg5oeWklpNaTmo5qeWklpNaTmo5qeWklpNaztJylpaztJyl5SwtZ2k5S8tZWs7ScpaWU1pOaTlqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashbDXmrIW815K2GvNWQtxryVkPeashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGjI6wMN+bfB0MHUwaWDpYOtg1sHjw5eHdRyQssJLSe0nNByQssJLSe0nNByQssJLSe1nNRyUstJLSe1nNRyUstJLSe1nNRylpaztJyl5SwtZ2k5S8tZWs7ScpaWs7Sc0nJKyyktp7Sc0nJKyyktp7Sc0nJKy2ktp7Wc1nJay2ktp7Wc1nJay2ktp7WcreVsLWdrOVvL2VrO1nK2lrO1nK3lbC3naDlHyzlaztFyjpZztJyj5Rwt52g5R8u5Ws7Vcq6Wc7Wcq+VcLedqOVfLuVrO1XJGyxktZ7Sc0XJGyxktZ7Sc0XJGy1FDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkVkNuNeRWQ2415FZDbjXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghn58Y8m/v7Y/BmE8Htw4eHbw6ODj4E0P+hcHQwb/+y7Hup4NbB48OXh389JfjX/6skj8P/ssC8Y/Bnb/Pfe6yvzAXOJc4t3CucK5xbuPcwbmLc9jLxl429rKxl429bOxlYy8be9nYy8ZeNvZysJeDvRzs5WAvB3s52MvBXg72crCXg71c7OViLxd7udjLxV4u9nKxl4u9XOzlYi+DvQz2MtjLYC+DvQz2MtjLYC+DvYz1cj8+cC5wLnFu4VzhXOPcxrmDcxfnsJfAXgJ7CewlsJfAXgJ7CewlsJfAXgJ7SewlsZfEXhJ7SewlsZfEXhJ7SewlsZeFvSzsZWEvC3tZ2MvCXhb2srCXhb0s7KWwl8JeCnsp7KWwl8JeCnsp7KWwF/Tdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570XcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d9B3B3130HcHfXfQdwd9d8x368N897e5wLnEuYVzhXONcxvnDs5dnMNeAnsJ7CWwl8BeAnsJ7CWwl8BeAnsJ7CWxl8ReEntJ7CWxl8ReEntJ7CWxl8ReFvaysJeFvSzsZWEvC3tZ2MvCXhb2srCXwl4KeynspbCXwl4KeynspbCXwl4Ke2nspbGXxl4ae2nspbGXxl4ae2nspbGXjb1s7GVjLxt72djLxl429rKxl429bOzlYC8HeznYy8FeDvZysJeDvRzs5WAvB3u52MvFXi72crGXi71c7OViLxd7udjLxV4GexnsZbCXwV4GexnsZbCXwV4Ge0HfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A3w303UDfDfTdQN8N9N1A30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9N9N1E30303UTfTfTdRN9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1C3y303ULfLfTdQt8t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdRt9t9N1G32303UbfbfTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G393ouxt9d6PvbvTdjb670Xc3+u5G3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996BjHnTMg4550DHP5465M/ef53ae9WMu8vfB+zlk/spg6GDq4NLB0sHWwa2DRwevDmo5oeWElhNaTmg5oeWElhNaTmg5oeWElpNaTmo5qeWklpNaTmo5qeWklpNaTmo5S8tZWs7ScpaWs7ScpeUsLWdpOUvLWVpOaTml5ZSWU1pOaTml5ZSWU1pOaTml5bSW01pOazmt5bSW01pOazmt5bSW01rO1nK2lrO1nK3lbC1nazlby9laztZytpZztJyj5Rwt52g5R8s5Ws7Rco6Wc7Sco+VcLedqOVfLuVrO1XKulnO1nKvlXC3najmj5YyWM1rOaDmj5YyWM1rOaDmj5aghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIc9PDLnqx2DV+XRw6WDpYOvg1sGjg1cHBwd/Ysi/MBg6+JNy+vw++NvHsJ8OLh0sHWwd3Dp4dPDq4ODgTwz5FwZDB7Wc0nJKyyktp7Sc0nJKyyktp7Wc1nJay2ktp7Wc1nJay2ktp7Wc1nK2lrO1nK3lbC1nazlby9laztZytpaztZyj5Rwt52g5R8s5Ws7Rco6Wc7Sco+UcLedqOVfLuVrO1XKulnO1nKvlXC3najlXyxktZ7Sc0XJGyxktZ7Sc0XJGyxktZ6yc/vj40MHQwdTBpYOlg62DWwePDl4d1HJCywktJ7Sc0HJCywktJ7Sc0HJCywktJ7Wc1HJSy0ktJ7Wc1HJSy0ktJ7Wc1HKWlrO0nKXlLC1naTlLy1laztJylpaztJzSckrLKS2ntJzSckrLKS2ntJzSckrLaS2ntZzWclrLaS2ntZzWclrLaS2ntZyt5WwtZ2s5W8vZWs7WcraWs7WcreVsLedoOUfLOVrO0XKOlnO0nKPlHC3naDlHy7laztVyrpZztZyr5Vwt52o5V8u5Ws7VckbLGS1ntJzRckbLGS1ntJzRckbLUUMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDDjXkUEMONeRQQw415FBDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ0415FRDTjXkVENONeRUQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15q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Sw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeSlhrzUkJca8lJDXmrISw15qSEvNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLjXkUkMuNeRSQy415FJDLqXgUgoupeBSCi6l4Jpv+AMva/Z3HHK+45D7HYd8w5/Z2h9/xB/dWfn7If/qrx/614fEdxyS33HI+o5D6g84ZN0fh6xPD+nvOGR/xyHnOw6533HIfMMh8Q1/WG9HfMch+R2HrO84pL7jkP6OQ/Z3HHK+45D7HYd8wx/P3fkdNz6/48bnd9z4/I4bn99x4/M7bnx+x43P77jx+R03Pr/jxq/vuPHrO278+o4bv77jxq/vuPHrO278+o4bv77jxq/vuPHrO258fceNr++48fUdN76+48bXd9z4+o4bX99x4+s7bnx9x43//OPmvz6WNrZsrGzs095ix/7zXOw6/+Yn8PfBrYNHB68ODg5+/jHzrwyGDqYOLh0sHdRytpaztZyt5eyflNM//s6Byc/+GO8+HzoYOpg6uHSw/t2Dv/27//vv/vvf/93//l/+8z/+NvMv/8//6x/+0z/9/X/9hz//23/6f/7b//f/+ef/Fw==" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "35": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "62": { "source": "use dep::protocol_types::{\n    constants::{MAX_NOTES_PER_PAGE, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    abis::side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateSet<T> {}\n\nimpl<Note> PrivateSet<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n    // docs:start:insert\n    pub fn insert<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            broadcast\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N>(self, note: &mut Note) where Note: NoteInterface<N> {\n        create_note_hash_from_public(self.context.public.unwrap(), self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n\n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(\n            false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(\n            false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // docs:start:remove\n    pub fn remove<N>(self, note: Note) where Note: NoteInterface<N> {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_consumption(note);\n        let has_been_read = context.note_hash_read_requests.any(|r: SideEffect| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>\n    ) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(self.context.private.unwrap(), storage_slot, options);\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N>(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr" }, "63": { "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T> Storage<T> for PublicMutable<T> {}\n\nimpl<T> PublicMutable<T> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable reads only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr" }, "77": { "source": "use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_non_existent_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL>,\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_non_existent_read_requests: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_non_existent_read_requests: self.nullifier_non_existent_read_requests.storage,\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address,\n            reverted: false\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_non_existent_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_non_existent_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let side_effect_counter = self.side_effect_counter;\n        // TODO get next value from output of `call_public_function_internal`\n        self.side_effect_counter += 1;\n\n        call_public_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "94": { "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr" }, "98": { "source": "use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nfn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr" }, "99": { "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, \n    address::AztecAddress, \n    constants::ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr" }, "104": { "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr" }, "105": { "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, constants::RETURN_VALUES_LENGTH};\n\n#[oracle(callPublicFunction)]\nfn call_public_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; RETURN_VALUES_LENGTH] {}\n\nunconstrained pub fn call_public_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; RETURN_VALUES_LENGTH] {\n    call_public_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/public_call.nr" }, "107": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "121": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "122": { "source": "use dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note: Note) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index].lt(fields_1[sort.field_index]);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter.nr" }, "130": { "source": "use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{\n    GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, NUM_FIELDS_PER_SHA256, STATE_REFERENCE_LENGTH,\n    CONTENT_COMMITMENT_LENGTH\n},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::{arr_copy_slice}, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header: Header = dep::std::unsafe::zeroed();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/header.nr" }, "132": { "source": "struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr" }, "144": { "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "150": { "source": "use crate::{address::EthAddress, constants::L2_TO_L1_MESSAGE_LENGTH, traits::{Deserialize, Empty, Serialize}};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "155": { "source": "use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Hash, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial: PartialStateReference = dep::std::unsafe::zeroed();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr" }, "163": { "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize}\n};\n\nstruct FunctionData {\n    // First four bytes of the abi encoding \n    // of a function. \n    selector : FunctionSelector,\n    is_internal : bool,\n    is_private : bool,\n    is_constructor : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        self.is_internal == other.is_internal &\n        self.is_private == other.is_private &\n        self.is_constructor == other.is_constructor\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_internal: serialized[1] as bool,\n            is_private: serialized[2] as bool,\n            is_constructor: serialized[3] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty item hash\" test\n    assert_eq(hash, 0x200569267c0f73ac89aaa414239398db9445dd4ad3a8cf37015cd55b8d4c5e8d);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr" }, "167": { "source": "use crate::{\n    abis::side_effect::{OrderedValue, ContractScopedOrderedValue},\n    traits::{Empty, Serialize, Deserialize}, address::AztecAddress\n};\nuse dep::std::cmp::Eq;\n\nglobal READ_REQUEST_SERIALIZED_LEN = 2;\nglobal READ_REQUEST_CONTEXT_SERIALIZED_LEN = 3;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl OrderedValue<Field> for ReadRequest {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_SERIALIZED_LEN> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_SERIALIZED_LEN] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_SERIALIZED_LEN> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> ReadRequestContext {\n        ReadRequestContext { value: self.value, counter: self.counter, contract_address }\n    }\n}\n\nstruct ReadRequestContext {\n    value: Field,\n    counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl OrderedValue<Field> for ReadRequestContext {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl ContractScopedOrderedValue<Field> for ReadRequestContext {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ReadRequestContext {\n    fn eq(self, read_request: ReadRequestContext) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n        & (self.contract_address.eq(read_request.contract_address))\n    }\n}\n\nimpl Empty for ReadRequestContext {\n    fn empty() -> Self {\n        ReadRequestContext {\n            value: 0,\n            counter: 0,\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_CONTEXT_SERIALIZED_LEN> for ReadRequestContext {\n    fn serialize(self) -> [Field; READ_REQUEST_CONTEXT_SERIALIZED_LEN] {\n        [self.value, self.counter as Field, self.contract_address.to_field()]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_CONTEXT_SERIALIZED_LEN> for ReadRequestContext {\n    fn deserialize(values: [Field; READ_REQUEST_CONTEXT_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            contract_address: AztecAddress::from_field(values[2]),\n        }\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr" }, "168": { "source": "use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, abis::side_effect::Ordered\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    portal_contract_address : EthAddress,\n\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        assert(self.msg_sender.to_field() == 0);\n        assert(self.storage_contract_address.to_field() == 0);\n        assert(self.portal_contract_address.to_field() == 0);\n        assert(self.function_selector.to_field() == 0);\n        assert(self.is_delegate_call == false);\n        assert(self.is_static_call == false);\n        assert(self.side_effect_counter == 0);\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, call_context: CallContext) -> bool {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        call_context.msg_sender.eq(self.msg_sender)\n            & call_context.storage_contract_address.eq(self.storage_contract_address)\n            & call_context.portal_contract_address.eq(self.portal_contract_address)\n            & call_context.function_selector.eq(self.function_selector)\n            & (call_context.is_delegate_call == self.is_delegate_call)\n            & (call_context.is_static_call == self.is_static_call)\n            & (call_context.side_effect_counter == self.side_effect_counter)\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender.to_field(),\n            self.storage_contract_address.to_field(),\n            self.portal_contract_address.to_field(),\n            self.function_selector.to_field(),\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.side_effect_counter as Field,\n        ]\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        CallContext {\n            msg_sender: AztecAddress::from_field(serialized[0]),\n            storage_contract_address: AztecAddress::from_field(serialized[1]),\n            portal_contract_address: EthAddress::from_field(serialized[2]),\n            function_selector: FunctionSelector::from_field(serialized[3]),\n            is_delegate_call: serialized[4] as bool,\n            is_static_call: serialized[5] as bool,\n            side_effect_counter: serialized[6] as u32,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let _hashed = context.hash();\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr" }, "182": { "source": "use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item: PrivateCallStackItem = dep::std::unsafe::zeroed();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item: PrivateCallStackItem = dep::std::unsafe::zeroed();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x19196a5f02621a64ce289fb09fada7fd650a6874cb63e7d10c0d9a9bf5a366f5;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr" }, "183": { "source": "use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem, side_effect::SideEffect\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_internal: false, is_private: false, is_constructor: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0xedd2f10c0cdf776ee2fff3c799bae6df5771f5013a2d5d7154601dffdcf869;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_internal: false, is_private: false, is_constructor: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x1cec0b51f9394405a626c3b77081c96f1bdcb8bacf96960ae4749068f9b4da0d;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr" }, "185": { "source": "use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_field(value: Field) -> Self {\n        Self { inner: value as u32 }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr" }, "188": { "source": "use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : Field,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n}\n// docs:end:global-variables\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        [\n            self.chain_id,\n            self.version,\n            self.block_number,\n            self.timestamp,\n            self.coinbase.to_field(),\n            self.fee_recipient.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        GlobalVariables {\n            chain_id: serialized[0],\n            version: serialized[1],\n            block_number: serialized[2],\n            timestamp: serialized[3],\n            coinbase: EthAddress::from_field(serialized[4]),\n            fee_recipient: AztecAddress::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient)\n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars: GlobalVariables = dep::std::unsafe::zeroed();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr" }, "191": { "source": "use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    constants::{NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH, NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, grumpkin_point::GrumpkinPoint,\n    grumpkin_private_key::GrumpkinPrivateKey\n};\n\nstruct NullifierKeyValidationRequest {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\nimpl Eq for NullifierKeyValidationRequest {\n    fn eq(self, request: NullifierKeyValidationRequest) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequest {\n    fn empty() -> Self {\n        NullifierKeyValidationRequest {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH> for NullifierKeyValidationRequest {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH> for NullifierKeyValidationRequest {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n        }\n    }\n}\n\nimpl NullifierKeyValidationRequest {\n    pub fn to_context(self, contract_address: AztecAddress) -> NullifierKeyValidationRequestContext {\n        NullifierKeyValidationRequestContext { public_key: self.public_key, secret_key: self.secret_key, contract_address }\n    }\n}\n\nstruct NullifierKeyValidationRequestContext {\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n    contract_address: AztecAddress,\n}\n\nimpl Eq for NullifierKeyValidationRequestContext {\n    fn eq(self, request: NullifierKeyValidationRequestContext) -> bool {\n        (request.public_key.eq(self.public_key))\n            & (request.secret_key.eq(self.secret_key))\n            & (request.contract_address.eq(self.contract_address))\n    }\n}\n\nimpl Empty for NullifierKeyValidationRequestContext {\n    fn empty() -> Self {\n        NullifierKeyValidationRequestContext {\n            public_key: GrumpkinPoint::zero(),\n            secret_key: GrumpkinPrivateKey::zero(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH> for NullifierKeyValidationRequestContext {\n    fn serialize(self) -> [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH] {\n        [\n            self.public_key.x,\n            self.public_key.y,\n            self.secret_key.high,\n            self.secret_key.low,\n            self.contract_address.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH> for NullifierKeyValidationRequestContext {\n    fn deserialize(fields: [Field; NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH]) -> Self {\n        Self {\n            public_key: GrumpkinPoint::new(fields[0], fields[1]),\n            secret_key: GrumpkinPrivateKey::new(fields[2], fields[3]),\n            contract_address: AztecAddress::from_field(fields[4]),\n        }\n    }\n}\n\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_key_validation_request.nr" }, "192": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, nullifier_key_validation_request::NullifierKeyValidationRequest,\n    read_request::ReadRequest, side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize}, utils::reader::Reader\n};\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    min_revertible_side_effect_counter: u32,\n\n    note_hash_read_requests: [SideEffect; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_key_validation_requests: [NullifierKeyValidationRequest; MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack_hashes: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The following 2 values are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    chain_id: Field,\n    version: Field,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.return_values == other.return_values) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.nullifier_key_validation_requests == other.nullifier_key_validation_requests) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_stack_hashes == other.private_call_stack_hashes) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.encrypted_logs_hash == other.encrypted_logs_hash) &\n        (self.unencrypted_logs_hash == other.unencrypted_logs_hash) &\n        (self.encrypted_log_preimages_length == other.encrypted_log_preimages_length) &\n        (self.unencrypted_log_preimages_length == other.unencrypted_log_preimages_length) &\n        self.historical_header.eq(other.historical_header) &\n        self.chain_id.eq(other.chain_id) &\n        self.version.eq(other.version)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL{\n            fields.extend_from_array(self.nullifier_key_validation_requests[i].serialize());\n        }\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL{\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL{\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        fields.extend_from_array(self.private_call_stack_hashes);\n        fields.extend_from_array(self.public_call_stack_hashes);\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        fields.extend_from_array(self.encrypted_logs_hash);\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            note_hash_read_requests: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_key_validation_requests: reader.read_struct_array(NullifierKeyValidationRequest::deserialize, [NullifierKeyValidationRequest::empty(); MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_stack_hashes: reader.read_array([0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            encrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            encrypted_log_preimages_length: reader.read(),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            chain_id: reader.read(),\n            version: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PrivateCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PrivateCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x2b5ba01a6b73b68b4f44196e2dea49afd4076333e2dee8eddc9186e080f18201;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr" }, "193": { "source": "use crate::{\n    address::AztecAddress, constants::{GENERATOR_INDEX__SIDE_EFFECT},\n    traits::{Empty, Hash, Serialize, Deserialize}\n};\nuse dep::std::cmp::Eq;\n\nglobal SIDE_EFFECT_SERIALIZED_LEN = 2;\n\ntrait Ordered {\n    fn counter(self) -> u32;\n}\n\ntrait OrderedValue<T> where T: Eq {\n    fn value(self) -> T;\n    fn counter(self) -> u32;\n}\n\ntrait ContractScopedOrderedValue<T> where T: Eq {\n    fn value(self) -> T;\n    fn counter(self) -> u32;\n    fn contract_address(self) -> AztecAddress;\n}\n\nstruct SideEffect {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffect {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for SideEffect {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffect {\n    fn eq(self, side_effect: SideEffect) -> bool {\n        (self.value == side_effect.value)\n        & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffect {\n    fn empty() -> Self {\n        SideEffect {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffect {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize() , GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<SIDE_EFFECT_SERIALIZED_LEN> for SideEffect {\n    fn serialize(self) -> [Field; SIDE_EFFECT_SERIALIZED_LEN] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<SIDE_EFFECT_SERIALIZED_LEN> for SideEffect {\n    fn deserialize(values: [Field; SIDE_EFFECT_SERIALIZED_LEN]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nstruct SideEffectLinkedToNoteHash{\n    value: Field,\n    note_hash: Field,\n    counter: u32,\n}\n\nimpl Ordered for SideEffectLinkedToNoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for SideEffectLinkedToNoteHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for SideEffectLinkedToNoteHash {\n    fn eq(self, side_effect: SideEffectLinkedToNoteHash) -> bool {\n        (self.value == side_effect.value)\n            & (self.note_hash == side_effect.note_hash) \n            & (self.counter == side_effect.counter)\n    }\n}\n\nimpl Empty for SideEffectLinkedToNoteHash {\n    fn empty() -> Self {\n        SideEffectLinkedToNoteHash {\n            value: 0,\n            note_hash: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Hash for SideEffectLinkedToNoteHash {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_hash_with_separator(\n            self.serialize(),\n        GENERATOR_INDEX__SIDE_EFFECT)\n    }\n}\n\nimpl Serialize<3> for SideEffectLinkedToNoteHash {\n    fn serialize(self) -> [Field; 3] {\n        [self.value, self.note_hash, self.counter as Field]\n    }\n}\n\nimpl Deserialize<3> for SideEffectLinkedToNoteHash {\n    fn deserialize(values: [Field; 3]) -> Self {\n        Self {\n            value: values[0],\n            note_hash: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/side_effect.nr" }, "196": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::AztecAddress,\n    constants::{\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs{\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    prover_address: AztecAddress,\n\n    reverted: bool,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.reverted as Field);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            reverted: reader.read() as bool,\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x083ac560a513d670a7f50f0a3052d42cb9816b7b643e62025b8278652ad637ab;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr" }, "197": { "source": "use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u64 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr" }, "198": { "source": "use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<1> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<1> for U128 {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr" }, "199": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "200": { "source": "use crate::{\n    constants::{NUM_FIELDS_PER_SHA256, CONTENT_COMMITMENT_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::{arr_copy_slice}\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: [Field; NUM_FIELDS_PER_SHA256],\n  in_hash: [Field; NUM_FIELDS_PER_SHA256],\n  out_hash: [Field; NUM_FIELDS_PER_SHA256],\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array([self.tx_tree_height]);\n    fields.extend_from_array(self.txs_effects_hash);\n    fields.extend_from_array(self.in_hash);\n    fields.extend_from_array(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n    let mut offset = 1;\n\n    let txs_effects_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n    offset = offset + NUM_FIELDS_PER_SHA256;\n\n    let in_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n    offset = offset + NUM_FIELDS_PER_SHA256;\n\n    let out_hash = arr_copy_slice(serialized, [0; NUM_FIELDS_PER_SHA256], offset);\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: [0; NUM_FIELDS_PER_SHA256],\n      in_hash: [0; NUM_FIELDS_PER_SHA256],\n      out_hash: [0; NUM_FIELDS_PER_SHA256],\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr" }, "202": { "source": "global ARGS_LENGTH: u64 = 16;\nglobal RETURN_VALUES_LENGTH: u64 = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_NOTE_HASHES_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX ≥ MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_NOTE_HASHES_PER_TX ≥ MAX_NEW_NOTE_HASHES_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX ≥ MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_CALL: u64 = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: u64 = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: u64 = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: u64 = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: u64 = 16;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_CALL: u64 = 32;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_CALL: u64 = 2; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL: u64 = 2;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: u64 = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 56;\n\nglobal MAX_NEW_NULLIFIERS_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 56;\n\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: u64 = 8;\n\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 8;\nglobal MAX_NON_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 3;\nglobal MAX_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 5;\n\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\n\nglobal MAX_PUBLIC_DATA_READS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\n\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: u64 = 2;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_TX: u64 = 128;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_TX: u64 = 8; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX: u64 = 8;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: u64 = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: u64 = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: u64 = 3;\nglobal FUNCTION_TREE_HEIGHT: u64 = 5;\nglobal NOTE_HASH_TREE_HEIGHT: u64 = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: u64 = 40;\nglobal NULLIFIER_TREE_HEIGHT: u64 = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: u64 = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: u64 = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\nglobal NULLIFIER_TREE_ID = 0;\nglobal NOTE_HASH_TREE_ID = 1;\nglobal PUBLIC_DATA_TREE_ID = 2;\nglobal L1_TO_L2_MESSAGE_TREE_ID = 3;\nglobal ARCHIVE_TREE_ID = 4;\n\n// SUB-TREES RELATED CONSTANTS\nglobal NOTE_HASH_SUBTREE_HEIGHT: u64 = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: u64 = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: u64 = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: u64 = 5;\nglobal ARCHIVE_HEIGHT: u64 = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: u64 = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: u64 = 35;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: u64 = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: u64 = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: u64 = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u64 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u64 = 32;\n// The following is used in immutable state variables to compute an initialization slot whose value is used to\n// determine whether a given variable has been initialized (by asserting that the value in the slot is 0).\n// The initialization slot is computed by adding the constant bellow to the variable's storage slot. This constant has\n// to be large enough so that it's ensured that it doesn't collide with storage slots of other variables.\nglobal INITIALIZATION_SLOT_SEPARATOR: Field = 1000_000_000;\nglobal INITIAL_L2_BLOCK_NUM: Field = 1;\n// 126976 = 31 * 4096;\nglobal BLOB_SIZE_IN_BYTES: Field = 126976;\n\n// CONTRACT CLASS CONSTANTS\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: u64 = 15000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: u64 = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: u64 = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\nglobal DEPLOYER_CONTRACT_ADDRESS = 0x0bffa876f07f9fe1802579dfef599810202f9c25b9a2f58921064a267d1ad1d3;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\nglobal MAX_NOTE_FIELDS_LENGTH: u64 = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: u64 = 23;\nglobal MAX_NOTES_PER_PAGE: u64 = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: u64 = 212;\n\n// LENGTH OF STRUCTS SERIALIZED TO FIELDS\nglobal AZTEC_ADDRESS_LENGTH = 1;\nglobal CALL_CONTEXT_LENGTH: u64 = 7;\nglobal CONTENT_COMMITMENT_LENGTH: u64 = 7;\nglobal CONTRACT_INSTANCE_LENGTH: u64 = 6;\nglobal CONTRACT_STORAGE_READ_LENGTH: u64 = 2;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: u64 = 2;\nglobal ETH_ADDRESS_LENGTH = 1;\nglobal FUNCTION_DATA_LENGTH: u64 = 4;\nglobal FUNCTION_LEAF_PREIMAGE_LENGTH: u64 = 5;\nglobal GLOBAL_VARIABLES_LENGTH: u64 = 6;\nglobal HEADER_LENGTH: u64 = 23; // 2 for last_archive, 7 for content commitment, 8 for state reference, 6 for global vars\nglobal L1_TO_L2_MESSAGE_LENGTH: u64 = 8;\nglobal L2_TO_L1_MESSAGE_LENGTH: u64 = 2;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH = 5;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: u64 = 6;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: u64 = 215;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 210;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 202;\nglobal STATE_REFERENCE_LENGTH: u64 = 8; // 2 for snap + 8 for partial\nglobal TX_CONTEXT_DATA_LENGTH: u64 = 4;\nglobal TX_REQUEST_LENGTH: u64 = 10;\n\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH: Field = 13; // 2 + FUNCTION_DATA_LENGTH + CALL_CONTEXT_LENGTH\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: u64 = 674;\nglobal NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal NUM_MSGS_PER_BASE_PARITY: u64 = 4;\n// NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP / NUM_MSGS_PER_BASE_PARITY\nglobal NUM_BASE_PARITY_PER_ROOT_PARITY: u64 = 4;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n ≤ 8                         | 0 < hash_index ≤ 32  |\n * | MID       | 8 < n ≤ 16                    | 32 < hash_index ≤ 40 |\n * | HIGH      | 16 < n ≤ 48                   | 40 < hash_index ≤ 48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size ≤ 8\nglobal GENERATOR_INDEX__NOTE_HASH = 1;\nglobal GENERATOR_INDEX__NOTE_HASH_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size ≤ 16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size ≤ 44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\nglobal GENERATOR_INDEX__AUTHWIT_INNER = 45;\nglobal GENERATOR_INDEX__AUTHWIT_OUTER = 46;\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/constants.nr" }, "208": { "source": "use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::{arr_copy_slice}\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state: StateReference = dep::std::unsafe::zeroed();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr" }, "209": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "239": { "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.owner.to_field(), self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr" }, "261": { "source": "// A contract used along with `Parent` contract to test nested calls.\ncontract Delegator {\n    use dep::aztec::prelude::{\n        AztecAddress, FunctionSelector, NoteHeader, NoteViewerOptions, emit_unencrypted_log,\n        PublicMutable, PrivateSet\n    };\n\n    use dep::value_note::value_note::{ValueNote, VALUE_NOTE_LEN};\n\n    struct Storage {\n        current_value: PublicMutable<Field>,\n        a_private_value: PrivateSet<ValueNote>,\n    }\n\n    #[aztec(private)]\n    fn private_delegate_set_value(\n        targetContract: AztecAddress,\n        targetSelector: FunctionSelector,\n        args: [Field; 2]\n    ) {\n        // Call the target private function\n        let return_values = context.delegate_call_private_function(targetContract, targetSelector, args);\n        // Copy the return value from the call to this function's return values\n        return_values[0]\n    }\n\n    #[aztec(private)]\n    fn enqueued_delegate_set_value(\n        targetContract: AztecAddress,\n        targetSelector: FunctionSelector,\n        args: [Field; 1]\n    ) {\n        context.delegate_call_public_function(targetContract, targetSelector, args);\n    }\n\n    #[aztec(public)]\n    fn public_delegate_set_value(\n        targetContract: AztecAddress,\n        targetSelector: FunctionSelector,\n        args: [Field; 1]\n    ) {\n        let _ = context.delegate_call_public_function(targetContract, targetSelector, args);\n    }\n\n    unconstrained fn view_private_value(amount: Field, owner: AztecAddress) -> pub Field {\n        let options = NoteViewerOptions::new().select(0, amount, Option::none()).select(1, owner.to_field(), Option::none()).set_limit(1);\n        let notes = storage.a_private_value.view_notes(options);\n        notes[0].unwrap_unchecked().value\n    }\n\n    unconstrained fn view_public_value() -> pub Field {\n        storage.current_value.read()\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/delegator_contract/src/main.nr" } } }
