{ "noir_version": "0.25.0+589a6cb62caf38445c768429150eee469ae35d77", "name": "Counter", "functions": [{ "name": "initialize", "is_unconstrained": false, "custom_attributes": ["aztec(private)", "aztec(initializer)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "headstart", "type": { "kind": "integer", "sign": "unsigned", "width": 64 }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "headstart": [{ "start": 33, "end": 34 }], "inputs": [{ "start": 0, "end": 33 }], "owner": [{ "start": 34, "end": 35 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277] }, "bytecode": "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", "debug_symbols": "5ZrbThsxEIbfZa9R5Dl5PHmViouUUgkJBQRppQrl3esN+JDE4CZb0aS5QoEZ8/lfe/x7Ni/D/cPNYnX3sHwe5i8DwDD/8jI8Py6W48fn1eJpNczd1XC7/BZ/rq+G73f3t8Mcxa+v9uJA7C0SAuTYoI1QRAtvsUgiORjMGtHBJDGYA96Kvr4aAM+Smj6LmgkTNRtOpOYp1AI+CSjoQuHG1hSdS9zgsEwShBrRcWZ5ZC2xHDbUcpbU/iypddK6ZoMEIjXIuBT350gpWLSMDI42IOETQVwBgS2QxsjKnEbWavMiSiPaKG1081Zp3aJQSU9crexcdBs17BPVCGmC3klHDQTUXFPBOmqoJeKg1cjcYvaSBg6+ImY5vOqh+x/E80W80BMPIlxiJsBOdE8+OFH5nBT5sCcfWK6RMRG36t7hkuA/kQR0t0riRBvCSUHw1QJsg0DIyxWs1qQZ3VOQJ4H7bIrAq26hjIM3DYNCrq/kO//AQHLdLoevd0dM1J8Qi05lAceUhI+u42OaP32aZTtI5XRQdMMczpDZzo+Z3BkyQ4dZQmf4oCnWwG8N3zhvTNNGjDfJyvnRZnMRToUBBz7b+OqC2sYB8OWMr+Vu3RBCNq0hVGcfhOa5asm0RodSoGE8qhoKUq440omNv80HH1Zn8KjgwcWM6CL1Nl+YqyX7zsPpSMgnLCG4fAOGTbOjEnFklzNhR8A9dn/K7NE/Z/bKcLQXLwunLc1SXXHjqh8nqpcy0XDSE82NTyCmXjlidLnhyL5TpDmk8i9UoG3TtCC7UFE03761irWWD7JyA4v+qbqV6uHlnN2F6u1zR1M9f6z3X20DMFzqAtfcnHO6s+v5lH3woaJIAkGv0BGFNNk4qVxc7NWNokzq04hQqwXU7LtwCAkj3p1055xiPg0O0Fm7pU0+rSyuy+HbOwGdtXu53Sw4KguPyqKDswhmTTeb7wVQeUiTV+s+g6YUGPIrBwye9m6pMQ+OzGvKIVA6tlU5dfxqi957zJy2IVnYtQ3hvafcSYJjkvCYJDo0iXHWbkoKJflEcbdoxCR/TFLTdXvK7w9c/ZLLr6/jp5+Lp7vF1/vb8YsE4x9/LG/S9wrix9Wvx9e/rH8D" }, { "name": "increment", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "owner": [{ "start": 33, "end": 34 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406] }, "bytecode": "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", "debug_symbols": "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" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "H4sIAAAAAAAA/+2dXW/bNhSGKVmJv+3EcRznm1mzdXezYxdouxt32MWKAVtvdjEUw5Auzpa1i7vMXZtfu3+xmwHDQkUnfn0iC5HH01KACRiWKIp8zit+ihK1rZTy1LXLXf2W1G1HxwfRf+f/ua7FuDqSnF5GOP2McOYschq2ppLNp4GArrYZlzLAuJwBxnwGGAsZYCxmgLGUAcZyBhgrGWCsZoCxlgHGegYYVzLAuJoBxkYGGNcywNjMAON6BhhbGWDcsMjoAWMQbbevfptXv62r3/bV7wf/2r+gJm5gi6Hf/cn02Snxtpp2pm/i004w8csRN/gRvw9+dI8hF0xsWLZuQ6dv4s3bjjcaK5AmBbDRHnv3YQF0ssgupUmYZykv0niP0lkCrYrRtsV7K11M24t+RUhTRdeItjcgLIUjPShfE3tFTfJmMeG8gJ1XhTDLMfYPlF3784wnz5iXIluMM/2kdjDRhdhq0fa/c7K9eHj0ojvsPnpw0jk+On3w6KTXf0BaEAPlBUorgOOPIdxODJfN+3Em3rr9eMNrgfZ6wF+PsfkAjhmm1Wh/YI+pX4b0FNiMbgDbq6D9in2erpCd4TVtRHHNm4fjnNFqjWlVZVpVIUwD9FsT0M+DdClu2qf0FswL5lnM5eingNXsY/tgnKm//vYmvFUh3lltV1W5kXbNftpHaevkGvAI1Mm9MqRxF54V4Knb5+kK2dnBtsd2G9FgWtWYVlUIg21sQ0A/D9KluGmf0lswvx/mqpqUdWItM14XGMmvDjwSZbCsJmMxbGueQ7oCdUoP++I0Ri0wmwMI8483Yfsx8qvAcWw7466lQB838VquAmOd6SvZhtYZTz1GC+m63GK8PaxjlmdoHECYl9G/sfsu9VMFtMH+oER+Eepn9vD5C9KI9zMDCHPBNGrO0AjzMGnTBI0EbDky8a4LadRiGhH/OmhEYS6ZRuTPNVoDjUibFmgk0F8N56OxnCt19/5qS4gnTX8V9RG41iFPKwXPOvBsCPGsp+DZAJ62EM9GCh68v74pxNNOwbMJPFtCPJspeIjBtCO8vTX/VDawf0f5swl+lEd88KPrlAM/0grvF7eBc6Cs6NCpgg6YByTq57SaS5dZITs7cW3JJrMJ8wf22yTqbk9N100D2G/BdUjD3Mggc9MBZsxz2l7aHaF+SM/EWQRda0xftGvbfvpHaftB28Aj0W4I2RnWGTvMpjqzqQphsF3YEbDTg3QpbtrfgeuQhrnlALNQ2kdUTuosvXWmh0l/TyD9tP3hPeDZtc/TFbIzLCf7zKYWs6kKYXywc1/ATg/Spbhpfx+uQxrmbQeY8fppe2mHz8No+zbdlL8WMKsZdt0TSN+UvwM17ZLK3z3g+cg+T1fIzrD8HTKbDphNVQiTAzsPBez0IF2Km/YP4TqkYd53gBmvn7aXds/E+7F9m27KH+n6MdMX7bofbducDzRxfBLFZeYPKN9RWgEcP4R5hr+A68C+LuGYF6+1cUn1wgHwSNULAnaG9YJmNt1jNlUhDI55tYCdnpqujwewr+E66BTMjQwyNx1gLjA/S2l3hPqYN2Ne0nWP6avBLoG+c9iXmPWuLepMbhd4JOYcheyMHfM2mU3ve8y7y3hoP2nMm8SsHWCWHvM2WXoHTA+hOYWwnGg17T7knIKQnWE5aTObNLMJ5wxwzCsxt+Sp6fv4A3V7DiEt864DzHj9tL20+0LzFzflT0fxbTB9hedzwvKHdY9xd53Pkbj/Ljmfw5853mU24TPHOOaVeuZ41jxD0nPSScxtB5iF5kZ6Qs/63JQ/0nWV6YvPfxeZnxl7fg/Pei/GnvO7xdhzMfacxbwYe6Zyi7GnWow9bTIvxp7XbjH2tGPnYuyZyn3wsSf2fckP+77meCnyx3fnn0fH8Z094TncblL5xXlCcr5jPCXHeJYd48k7xnPoGE/OMZ6yYzwVx3gajvEEjvFsO8ZTdIyn4BjPkmM8ngM8ZXV7XIH39Rrg57NzTXv3mT85Tv1cH86hcVMO/Gh8EoAf9euWwI/6c8sxXLvgR/cSd8CPxmlb4Kej7U3wo/sf7Zh08fpIvLPkqdvv3LQZYwU4pN+huivPkmM8Bcd4io7xbDvGEzjG03CMp+IYT9kxnpxjPIeO8eQd41l2jKfkGI/vGM9+DI/APeVw/hjX1iAudAPY3hLWR8jO2LmgBrMJ51XwPpvUvMoW46H9pLmgJOa9DDJrB5gxz2l7aXeE5jVv5o9J112mL9olMC/QxzEbuaQ6A9fB0PZ5ukJ2xr7jv8dswnfP8V6U1LvnG4yH9pPel09i3s8g82EGmXccYMY1SvfAj8Y6OvrHNUpxTc0y/NMaARXw88Fu8qNxAoUvqmyv92afp9s3PHxttALjwbXRgkjoWWuj4Zwc2cLXJhR6BjR2DTPiiFvDrAS2FMDfJpOQrVPPu9I34+oxtlKYuj8Juwr3bOma1CAuHXOcXFJbi8/jSbWJeE94AOlg2pvAaintW2MnfOYC11Ki7X1/EpY/m0FaE7spI1RPIjs/r8HOw7WVWjH2D9T7qePx3n0T8hnlI8m6tDVDowJoRGGk1ziOq9uJA79NQNc/z8LQubhm6adQR+G6szgvw9szofcUushOcfP1enCtslVg5Dby9WElvo2CfQBySfUXzg9a/wZM9J1Cqpt/Ho6/efPq1dnp2fDi6+Hls+OzCw8QCTtg2J6aNoEfN86P8ROSOMwSgZqWM4iR0/rngDrXQ1yBT9+EXSLKrtTMEH8edKcwn7MuEfkTVw7iMq7CtKF/iU8bmXgFPlETalRiGvFP1AQQ5gumEflzjfAzPaQN3g4TsCVcLrYspFGFaUT8ZdCIwjxlGpE/16gIGpVgmzQSsKUn9Ph9H5sU0oh/ygKbw2dMo9oMjcqgC2mDS7XTtg9++Jkf8sOl08mPmrAS+OHQjfz8mHRxCU7yo/qyDn7EsAJ+VH9QWiYf8ObMasXO59lUlKAfHQsiUAOWV5MCWlKTsT31B+qRMQbe9F1MO2j67KbfYPpn2Lec9Y28MjCQ09E/9f+/O395Pnp7rs9H46EeX74e6qdfYvhfo3/qsz65uDi+1GfnJ8N3evRmrEen+sXozfnJH3jS7/Oc9G6ek3L+HCcV5znpfnQS3Rw6Ho+Hv70e6/FIH5+c6Ldn41/06M/hxemr0Vs87/E8iT2Z56Sv5jnp27uepP4D9ROuzyqBAAA=", "debug_symbols": "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" }, { "name": "get_counter", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "owner": [{ "start": 0, "end": 1 }] }, "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" }, "return_witnesses": [1] }, "bytecode": "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", "debug_symbols": "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2MvGXjb2srGXjb1s7GWwl8FeBnsZ7GWwl8FeBnsZ7GWwl8FeDvZysJeDvRzs5WAvB3s52MvBXg72crCXi71c7OViLxd7udjLxV4u9nKxl4u9XOtlvr5wF7hL3C3cFe4adxt3g7uDO+wlsJfAXgJ7CewlsJfAXgJ7CewlsBf03UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdQd8d9N1B3x303UHfHfTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B3z3ouwd996DvHvTdg7570HcP+u5B373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTdi7570Xcv+u5F373ouxd996LvXvTd+ELg/W0YOkwdLh2WDluHW4ejw6NDLSe0nNByQssJLSe0nNByQssJLSe0nNByUstJLSe1nNRyUstJLSe1nNRyUstJLWdpOUvLWVrO0nKWlrO0nKXlLC1naTlLyyktp7Sc0nJKyyktp7Sc0nJKyyktp7Sc1nJay2ktp7Wc1nJay2ktp7Wc1nJay9laztZytpaztZyt5WwtZ2s5W8vZWs7WckbLGS1ntJzRckbLGS1ntJzRckbLGS3naDlHyzlaztFyjpZztJyj5Rwt52g5R8u5Ws7Vcq6Wc7Wcq+VcLedqOVfLuVqOGnKoIYcacqghhxryb79+0GHrcOtwdHh0qOWoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKoIYcacqghhxpyqCGHGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxpyqiGnGnKqIacacqohpxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSGXGnKpIZcacqkhlxpyqSG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshtxpyqyG3GnKrIbcacqshbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryqCGPGvKoIY8a8qghjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIR815KOGfNSQjxryUUM+ashHDfmoIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQrxryVUO+ashXDfmqIV815KuGfNWQLxpyfqEh/zYMHaYOlw5Lh63DrcPR4dGhlhNaTmg5oeWElhNaTmg5oeWElhNaTmg5qeWklpNaTmo5qeWklpNaTmo5qeWklrO0nKXlLC1naTlLy1laztJylpaztJyl5ZSWU1pOaTml5ZSWU1pOaTml5ZSWU1pOazmt5bSW01pOazmt5bSW01pOazmt5WwtZ2s5W8vZWs7WcraWs7WcreVsLWdrOaPljJYzWs5oOaPljJYzWs5oOaPljJZztJyj5Rwt52g5R8s5Ws7Rco6Wc7Sco+VcLedqOVfLuVrO1XKulnO1nKvlXC1HDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051JBDDTnUkEMNOdSQQw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNOdWQUw051ZBTDTnVkFMNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvJSQ15qyEsNeakhLzXkpYa81JCXGvL6lSHX/fvwfjtMHS4dlg5bh1uHo8Ojw4vDXxnynw+1nNFyRssZLWe0nNFyRssZLWe0nKPlHC3naDlHyzlaztFyjpZztJyj5Rwt52o5V8u5Ws7Vcq6Wc7Wcq+VcLedqORfLqa8vHYYOU4dLh6XD1uHW4ejw6FDLCS0ntJzQckLLCS0ntJzQckLLCS0ntJzUclLLSS0ntZzUclLLSS0ntZzUclLLWVrO0nKWlrO0nKXlLC1naTlLy1laztJySsspLae0nNJySsspLae0nNJySsspLae1nNZyWstpLae1nNZyWstpLae1nNZytpajhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWG3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIWw15qyFvNeSthrzVkLca8lZD3mrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyKOGPGrIo4Y8asijhjxqyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81JCPGvJRQz5qyEcN+aghHzXko4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75qyFcN+aohXzXkq4Z81ZCvGvJVQ75oyOsLDfm3Yegwdbh0WDpsHW4djg6PDrWc0HJCywktJ7Sc0HJCywktJ7Sc0HJCy0ktJ7Wc1HJSy0ktJ7Wc1HJSy0ktJ7WcpeUsLWdpOUvLWVrO0nKWlrO0nKXlLC2ntJzSckrLKS2ntJzSckrLKS2ntJzSclrLaS2ntZzWclrLaS2ntZzWclrLaS1nazlby9laztZytpaztZyt5WwtZ2s5W8sZLWe0nNFyRssZLWe0nNFyRssZLWe0nKPlHC3naDlHyzlaztFyjpZztJyj5Rwt52o5V8u5Ws7Vcq6Wc7Wcq+VcLedqOWrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKGGHGrIoYYcasihhhxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacasiphpxqyKmGnGrIqYacashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGvNSQlxryUkNeashLDXmpIS815KWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhlxqyKWGXGrIpYZcasilhtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYbcasithtxqyK2G3GrIrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvJWQ95qyFsNeashbzXkrYa81ZC3GvL+HmZz/77L+fr7bPXvs+9Z9s9nYbO02bJZ2axttm02Njs2s0rKKimrpKySskrKKimrpKySskrKKimrpK2StkraKmmrpK2StkraKmmrpK2Stkq2VbKtkm2VbKtkWyXbKtlWybZKtlWyrZKxSsYqGatkrJKxSsYqGatkrJKxSsYqOVbJsUqOVXKskmOVHKvkWCXHKjlWybFKrlVyrZJrlVyr5Fol1yq5Vsm1Sq5VcqmS+fqyWdgsbbZsVjZrm22bjc2OzaySsErCKgmrJKySsErCKgmrJKySsErCKkmrJK2StErSKkmrJK2StErSKkmrxOx1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfsdcxex+x1zF7H7HXMXsfs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr5fstb7IXn+bfV9Jff0xi29nabNls7JZ22zbbGx2bHZp9gt7/dOZVRJWSVglYZWEVRJWSVglYZWEVZJWSVolaZWkVZJWSVolaZWkVZJWSVolyypZVsmySpZVsqySZZUsq2RZJcsqWVZJWSVllZRVUlZJWSVllZRVUlZJWSVllbRV0lZJWyVtlbRV0lZJWyVtlbRV0lbJtkq2VbKtkm2VbKtkWyXbKtlWybZKtlUyVslYJWOVjFUyVslYJWOVjFUyVslYJccqOVbJsUqOVXKskmOVHKvkWCXHKjlWybVKrlVyrZJrlVyr5Fol1yq5Vsm1Si5VEl9fNgubpc2WzcpmbbNts7HZsZlVYvYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X22mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73WavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71kr/1F9vrbLGyWNls2K5u1zbbNxmbHZlZJWCVhlYRVElZJWCVhlYRVElZJWCVhlaRVklZJWiVplaRVklZJWiVplaRVklbJskqWVbKskmWVLKtkWSXLKllWybJKllVSVklZJWWVlFVSVklZJWWVlFVSVklZJW2VtFXSVklbJW2VtFXSVklbJW2VtFWyrZJtlWyrZFsl2yrZVsm2SrZVsq2SbZWMVTJWyVglY5WMVTJWyVglY5WMVTJWybFKjlVyrJJjlRyr5Fglxyo5VsmxSo5Vcq2Sa5Vcq+RaJdcquVbJtUquVXKtErPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHvN71lz3frbbN3+dhY2S5stm5XNvv0JqPp9Vvt8O9s2G5sdm12Zre9Z889nYbO02bJZ2axttm02Njs2s0rCKgmrJKySsErCKgmrJP6skjP/3exf/Z8d/PX3g3/98YD56Qecn37A/eEH5NdPPyB++gH50w9YP/2A+ukH9E8/4Kff5PzpNzl/+k3On36T10+/yeun3+T102/y+uk3ef30m7x++k1eP/0mr59+k9dPv8nrp9/k+uk3uX76Ta6ffpPrp9/k+uk3uX76Ta6ffpPrp9/k+uk3uX76Te6ffpP7p9/k/uk3uX/6Te6ffpP7p9/k/uk3uX/6Te6ffpP7p9/k/dNv8v7pN3n/9Ju8f/pN3j/9Ju+ffpP3T7/J+6ff5P3Tb/L+6Td5fvpNnp9+k+en3+T56Td5fvpNnp9+k+en3+T56Td5fvpNnp9+k89Pv8nnp9/k89Nv8vnpN/n89Jt8fvpNPj/9Jp+ffpPPT7/J56ff5PvTb/L96Tf5/vSbfH/6Tb4//Sbfn36T70+/yfen3+T702/y/eE3ub6+fvoB8dMPyJ9+wPrpB9RPP6B/+gH7px8wP/2A89MP+Ok3OX76TY6ffpPjp9/k+Ok3OX76TY6ffpN/+jNe9dOf8aqf/oxX/fRnvOqnP+NVP/0Zr/rpz3jVT3/Gq376M17105/xqp/+jFf99Ge86qc/41U//Rmv+pd+xuv3WdgsbbZsVjZrm22bjc2OzS7Nyiopq6SskrJKyiopq6SskrJKyiopq6StkrZK2ippq6StkrZK2ippq6StkrZKtlWyrZJtlWyrZFsl2yrZVsm2SrZVsq2SsUrGKhmrZKySsUrGKhmrZKySsUrGKjlWybFKjlVyrJJjlRyr5Fglxyo5VsmxSq5Vcq2Sa5Vcq+RaJdcquVbJtUquVXKpkv76slnYLG22bFY2a5ttm43Njs2skrBKwioJqySskrBKwioJqySskrBKwipJqyStkrRK0ipJqyStkrRK0ipJqyStErPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z12P2esxez/f22l/3b7Ne+e1s2axs1jbbNhubHZtdmn1vr38+C5tZJWGVhFUSVklYJWGVhFUSVklaJWmVpFWSVklaJWmVpFWSVklaJWmVLKtkWSXLKllWybJKllWyrJJllSyrZFklZZWUVVJWSVklZZWUVVJWSVklZZWUVdJWSVslbZW0VdJWSVslbZW0VdJWSVsl2yrZVsm2SrZVsq2SbZVsq2RbJdsq2VbJWCVjlYxVMlbJWCVjlYxVMlbJWCVjlRyr5Fglxyo5VsmxSo5VcqySY5Ucq+RYJdcquVbJtUquVXKtkmuVXKvkWiXXKrlUyf36slnYLG22bFY2a5ttm43Njs2sErPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXS/a6v8hef5uFzdJmy2Zls7bZttnY7NjMKgmrJKySsErCKgmrJKySsErCKgmrJKyStErSKkmrJK2StErSKkmrJK2StErSKllWybJKllWyrJJllSyrZFklyypZVsmySsoqKaukrJKySsoqKaukrJKySsoqKaukrZK2StoqaaukrZK2StoqaaukrZK2SrZVsq2SbZVsq2RbJdsq2VbJtkq2VbKtkrFKxioZq2SskrFKxioZq2SskrFKxio5VsmxSo5VcqySY5Ucq+RYJccqOVbJsUquVXKtkmuVXKvkWiXXKrlWybVKrlVi9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfYaZq9h9hpmr2H2GmavYfaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2mmavafaaZq9p9ppmr2n2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavZfZaZq9l9lpmr2X2WmavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr2322mavbfbaZq9t9tpmr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfY6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2OmavY/Y6Zq9j9jpmr2P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/H7PWYvR6z12P2esxej9nrMXs9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z12v2es1er9nrNXu9Zq/X7PWavV6z10v2Ol9kr7/NwmZps2WzslnbbNtsbHZsZpWEVRJWSVglYZWEVRJWSVglYZWEVRJWSVolaZWkVZJWSVolaZWkVZJWSVolaZUsq2RZJcsqWVbJskqWVbKskmWVLKtkWSVllZRVUlZJWSVllZRVUlZJWSVllZRV0lZJWyVtlbRV0lZJWyVtlbRV0lZJWyXbKtlWybZKtlWyrZJtlWyrZFsl2yrZVslYJWOVjFUyVslYJWOVjFUyVslYJWOVHKvkWCXHKjlWybFKjlVyrJJjlRyr5Fgl1yq5Vsm1Sq5Vcq2Sa5Vcq+RaJdcqMXsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9f8njX31/nbbEd8O2ubffuXZNb+22y6vp1dmn0PjX8+C5ulzZbNymbzJ7P9/ezY7NLse/o78fvs1Hw7C5ulzZbNymZts22zsdmx2aVZWyVtlbRV0lZJWyVtlbRV0lZJWyVtlWyrZFsl2yrZVsm2SrZVsq2SbZVsq2RbJWOVjFUyVslYJWOVjFUyVslYJWOVjFVyrJJjlRyr5Fglxyo5VsmxSo5VcqySY5Vcq+RaJdcquVbJtUquVXKtkmuVXKvkUiXr68tmYbO02bJZ2axttm02Njs2s0rCKgmrJKySsErCKgmrJKySsErCKgmrJK2StErSKkmrJK2StErSKkmrJK2StEqWVbKskmWVLKtkWSXLKllWybJKllWyrBKz12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9nrMntdZq/L7HWZvS6z12X2usxel9lrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5m9ltlrmb2W2WuZvZbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222WubvbbZa5u9ttlrm7222es2e91mr9vsdZu9brPXbfa6zV632es2e91mr9vsdZu9brPXbfa6zV632es2e93f2+uc+WN2vp0dm12afW+vfz4Lm6XNls3KZm2zbTOrJK2StEqWVbKskmWVLKtkWSXLKllWybJKllWyrJKySsoqKaukrJKySsoqKaukrJKySsoqaaukrZK2StoqaaukrZK2StoqaaukrZJtlWyrZFsl2yrZVsm2SrZVsq2SbZVsq2SskrFKxioZq2SskrFKxioZq2SskrFKjlVyrJJjlRyr5Fglxyo5VsmxSo5VcqySa5Vcq+RaJdcquVbJtUquVXKtkmuVXKpkvr5sFjZLmy2blc3aZttmY7NjM6skrJKwSsIqCaskrJKwSsIqMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dj9nrMXo/Z6zF7PWavx+z1mL0es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6zV7vWav1+z1mr1es9dr9nrNXq/Z6yV7PV9kr7/NwmZps2WzslnbbNtsbHZsZpWEVRJWSVglYZWEVRJWSVglYZWEVRJWSVolaZWkVZJWSVolaZWkVZJWSVolaZUsq2RZJcsqWVbJskqWVbKskmWVLKtkWSVllZRVUlZJWSVllZRVUlZJWSVllZRV0lZJWyVtlbRV0lZJWyVtlbRV0lZJWyXbKtlWybZKtlWyrZJtlWyrZFsl2yrZVslYJWOVjFUyVslYJWOVjFUyVslYJWOVHKvkWCXHKjlWybFKjlVyrJJjlRyr5Fgl1yq5Vsm1Sq5Vcq2Sa5Vcq+RaJdcqMXsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7DbPXMHsNs9cwew2z1zB7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e02z1zR7TbPXNHtNs9c0e11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zJ7LbPXMnsts9cyey2z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9c2e22z1zZ7bbPXNntts9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ73Wav2+x1m71us9dt9rrNXrfZ6zZ7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxex2z1zF7HbPXMXsds9cxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV6v2es1e71mr9fs9Zq9XrPXa/Z6zV7vL+x19p/MxmaXZt/75M7+22yv+XZWNmubbZuNzY7NLs2+98k/n4XN0mZWSVklZZWUVVJWSf/Zz1t9P/v+523W77PT387SZstmZbO22bbZ2OzY7NLsezH885lVsq2SbZVsq2RbJdsq2VbJtkq2VTJWyfdiuHf+bTbx9e0sbVY2a5ttm43NDs1+gXF/9s9cv8C4P50tm5XNvv15W7XO33arZv8x3PnHbuNucHdwd233vcj9hV3gLnG3cFe4w14u9nKxl4u9XOrlN5r7wl3gLnG3cFe4a9xt3A3uDu6wl8BeAnsJ7CWwl8BeAnsJ7CWwl8BeAntJ7CWxl8ReEntJ7CWxl8ReEntJ7CWxl4W9LOxlYS8Le1nYy8JeFvaysJeFvSzspbCXwl4KeynspbCXwl4KeynspbCXwl4ae2nspbGXxl4ae2nspbGXxl4ae2nsZWMvG3vZ2MvGXjb2srGXjb1s7GVjLxt7GexlsJfBXgZ7GexlsJfBXgZ7GexlsJeDvRzs5WAvB3s52MvBXg72crCXg70c7OViLxd7udjLxV4u9nKxl4u9XOzlYi/ou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuBvhvou4G+G+i7gb4b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7ib6b6LuJvpvou4m+m+i7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2FvrvQdxf67kLfXei7C313oe8u9N2Fvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb5b6LuFvlvou4W+W+i7hb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+2+i7jb7b6LuNvtvou42+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LsbfXej72703Y2+u9F3N/ruRt/d6LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7g7476LuDvjvou4O+O+i7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvQdw/67kHfPei7B333oO8e9N2DvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvei7F333ou9e9N2LvnvRdy/67kXfvea78fVlwPtfh6HD1OHSYemwdbh1ODo8OtRyQssJLSe0nNByQssJLSe0nNByQssJLSe1nNRyUstJLSe1nNRylv7FWfoXZ+lfnKV/cb5nzp25/zbcOeuPYeQ/W25eDi8PL68uvwfPv7QMXiYvFy+Ll9xQcUPFDRU3VNxQc0PNDTU31NxQc0PNDTU31NxQc0PNDW1uaHNDmxva3NDmhjY3tLmhzQ1tbmhzQ8MNDTc03NBwQ8MNDTc03NBwQ8MNDTd0uKHDDR1u6HBDhxs63NDhhg43dLihww1dbuhyQ5cbutzQ5YYuN3S5ocsNXW7oakPx9cXL4GXycvGyeNm83LwcXh5eckPBDQU3FNxQcEPBDQU3FNxQcEPBDQU3lNxQckPJDSU3lNxQckPJDSU3lNxQckOLG1rc0OKGFje0uCF26mCnDnbqYKcOdupgpw526mCnDnbqYKcOdupgpw526mCnDnbqYKcOdupgpw526mCnDnbqYKcOdur4hVNX/bGsmu+XV5e/cOq/sgxeJi8XL4uXzcvNy+HlLxrq+X15vr6+X15d/sKp/8oyeJm8XLwsXjYvNy+Hl9zQcEOHGzrc0OGGDjd0uKHDDR1u6HBDhxs63NDlhi43dLmhyw1dbuhyQ5cbutzQ5YauNpRfX7wMXiYvFy+Ll83Lzcvh5eElNxTcUHBDwQ0FNxTcUHBDwQ0FNxTcUHBDyQ0lN5TcUHJDyQ0lN5TcUHJDyQ0lN7S4ocUNLW5ocUOLG1rc0OKGFje0uKHFDRU3VNxQcUPFDRU3VNxQcUPFDRU3VNxQc0PNDTU31NxQc0PNDTU31NxQc0PNDW1uaHNDmxva3NDmhjY3tLmhzQ2xUyc7dbJTJzt1slMnO3WyUyc7dbJTJzt1slMnO3WyUyc7dbJTJzt1slMnO3WyUyc7dbJTJzt1slMnO3WyUyc7dbJTJzt1slMnO3WyUyc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMvdurFTr3YqRc79WKnXuzUi516sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTFzt1sVMXO3WxUxc7dbFTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzUzc7dbNTNzt1s1M3O3WzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1Zqfe7NSbnXqzU2926s1OvdmpNzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879bBTDzv1sFMPO/WwUw879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFMfdurDTn3YqQ879WGnPuzUh536sFNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3ZqS879WWnvuzUl536slNfdurLTn3Zqa86dXypU/+2DF4mLxcvi5fNy83L4eXhJTcU3FBwQ8ENBTcU3FBwQ8ENBTcU3FBwQ8kNJTeU3FByQ8kNJTeU3FByQ8kNJTe0uKHFDS1uaHFDixta3NDihhY3tLihxQ0VN1TcUHFDxQ0VN1TcUHFDxQ0VN1TcUHNDzQ01N9TcUHNDzQ01N9TcUHNDzQ1tbmhzQ5sb2tzQ5oY2N7S5oc0NbW5oc0PDDQ03NNzQcEPDDQ03NNzQcEPDDQ03dLihww0dbuhwQ4cbOtzQ4YYON3S4ocMNXW7ockOXG7rc0OWGLjd0uaHLDV1uiJ062KmDnTrYqYOd+rdfdvCyebl5Obw8vOSG2KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062KmDnTrYqYOdOtipg5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOdOtmpk5062amTnTrZqZOderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KkXO/Vip17s1IuderFTL3bqxU692KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipi5262KmLnbrYqYudutipm5262ambnbrZqZudutmpm5262ambnbrZqft7hZ2v2H9b/vZv5/vl5uXw8vDy6vJ7hZ2vqj+W1d8vg5fJy8XL4mXzcvNyeHl4eXW5uKHFDS1uaHFDixta3NDihhY3tLihxQ0VN1TcUHFDxQ0VN1S/aOh8/bE88f1y83J4eXh5ddlfvAxeJi8XL4uX3FBzQ80NNTfU3NDmhjY3tLmhzQ1tbmhzQ5sb2tzQ5oY2NzTc0PcKO5Hx+/K//uhvl8nLxcviZfNy83J4eXh5dfm9wv6lJTd0uKHDDR1u6HBDhxs63NDhhg43dLmhyw1dbuhyQ5cbutzQ/cXPSvUfy97fLff3xji//Vr49+Vvv7j9frl4WbxsXm5eDi8PL68uv/8s7F9aBi+5oeCGghsKbii4oeCGghsKbii5oeSGkhtKbii5oeSGkhtKbugXCvvbr7r+WO7+fnl1+QuF/SvL4GXycvGyeNm83LwcXnJDixsqbqi4oeKGihsqbqi4oeKGihsqbqi4oeaGmhtqbugXrvnbr/T+WN7v/zn+F8Y4f/8VwNT3y18Y419ZBi+Tl4uXxcvm5ebl8PLwkhsabmi4oeGGhhsabmi4oeGGhhsabmi4ocMNHW7ocEOHGzra0PzKE/707w7zK0/48+UvPOG3X5f+vvztH/X/u+W/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" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "30": { "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\n// TODO: add implementations for the remainder of primitive types.\nimpl Hash for Field{\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        let input: [Field] = [self];\n        H::write(state, input);\n    }\n}\n", "path": "std/hash.nr" }, "33": { "source": "// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n", "path": "std/merkle.nr" }, "35": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "60": { "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr" }, "62": { "source": "use dep::protocol_types::{\n    constants::{MAX_NOTES_PER_PAGE, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL},\n    abis::side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n};\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_header::NoteHeader, note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateSet<Note> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateSet<T> {}\n\nimpl<Note> PrivateSet<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n    // docs:start:insert\n    pub fn insert<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        create_note(\n            self.context.private.unwrap(),\n            self.storage_slot,\n            note,\n            broadcast\n        );\n    }\n    // docs:end:insert\n\n    // docs:start:insert_from_public\n    pub fn insert_from_public<N>(self, note: &mut Note) where Note: NoteInterface<N> {\n        create_note_hash_from_public(self.context.public.unwrap(), self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n\n    // DEPRECATED\n    fn assert_contains_and_remove(_self: Self, _note: &mut Note, _nonce: Field) {\n        assert(\n            false, \"`assert_contains_and_remove` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // DEPRECATED\n    fn assert_contains_and_remove_publicly_created(_self: Self, _note: &mut Note) {\n        assert(\n            false, \"`assert_contains_and_remove_publicly_created` has been deprecated. Please call PXE.addNote() to add a note to the database. Then use PrivateSet.get_notes() and PrivateSet.remove() in your contract to verify and remove a note.\"\n        );\n    }\n\n    // docs:start:remove\n    pub fn remove<N>(self, note: Note) where Note: NoteInterface<N> {\n        let context = self.context.private.unwrap();\n        let note_hash = compute_note_hash_for_consumption(note);\n        let has_been_read = context.note_hash_read_requests.any(|r: SideEffect| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note(context, note);\n    }\n    // docs:end:remove\n\n    // docs:start:get_notes\n    pub fn get_notes<N, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, FILTER_ARGS>\n    ) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n        let storage_slot = self.storage_slot;\n        let opt_notes = get_notes(self.context.private.unwrap(), storage_slot, options);\n        opt_notes\n    }\n    // docs:end:get_notes\n\n    // docs:start:view_notes\n    unconstrained pub fn view_notes<N>(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr" }, "71": { "source": "use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::{PrivateContext, ContextInterface},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\nfn _nullifier_inclusion(nullifier: Field, header: Header) {\n    // 1) Get the membership witness of the nullifier\n    let witness = get_nullifier_membership_witness(header.global_variables.block_number as u32, nullifier);\n\n    // 2) Check that the witness we obtained matches the nullifier\n    assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n    // 3) Compute the nullifier tree leaf\n    let nullifier_leaf = witness.leaf_preimage.hash();\n\n    // 4) Prove that the nullifier is in the nullifier tree\n    assert(\n        header.state.partial.nullifier_tree.root\n        == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n    );\n    // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n    //     was included in the nullifier tree.\n}\n\npub fn prove_nullifier_inclusion<TContext>(\n    nullifier: Field,\n    context: TContext\n) where TContext: ContextInterface {\n    _nullifier_inclusion(nullifier, context.get_header());\n}\n\npub fn prove_nullifier_inclusion_at(\n    nullifier: Field,\n    block_number: u32, // The block at which we'll prove that the nullifier exists in the nullifier tree\n    context: PrivateContext\n) {\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n\npub fn prove_note_is_nullified<Note, N>(\n    note: Note,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n\n    _nullifier_inclusion(nullifier, context.historical_header);\n}\n\npub fn prove_note_is_nullified_at<Note, N>(\n    note: Note,\n    block_number: u32,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "85": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/log.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "90": { "source": "use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "95": { "source": "#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/rand.nr" }, "100": { "source": "use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nfn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nfn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr" }, "103": { "source": "use dep::protocol_types::{address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr" }, "104": { "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr" }, "106": { "source": "use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "114": { "source": "use dep::protocol_types::{\n    hash::{silo_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, ContextInterface},\n    oracle::get_contract_instance::get_contract_instance,\n    history::nullifier_inclusion::prove_nullifier_inclusion,\n};\n\npub fn mark_as_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(*context);\n    ContextInterface::push_new_nullifier(context, init_nullifier, 0);\n}\n\npub fn assert_is_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_contract_initialization_nullifier(*context);\n    prove_nullifier_inclusion(init_nullifier, *context);\n}\n\npub fn compute_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    let address = context.this_address();\n    silo_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(context)\n    )\n}\n\npub fn compute_unsiloed_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    context.this_address().to_field()\n}\n\npub fn assert_initialization_args_match_address_preimage<TContext>(context: TContext) where TContext: ContextInterface {\n    let address = context.this_address(); \n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash([init_selector.to_field(), init_args_hash], GENERATOR_INDEX__CONSTRUCTOR)\n}", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr" }, "118": { "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr" }, "121": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "122": { "source": "use dep::protocol_types::{\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(context: PrivateContext, storage_slot: Field, note: Note) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index].lt(fields_1[sort.field_index]);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_note_hash_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter.nr" }, "144": { "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr" }, "145": { "source": "use crate::{\n    address::eth_address::EthAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash,\n    traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, portal_contract_address: EthAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            portal_contract_address.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr" }, "146": { "source": "use crate::{\n    address::{eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::ToField\n};\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr" }, "147": { "source": "use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl Eq for PublicKeysHash {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    assert(actual.to_field() == 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/public_keys_hash.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "194": { "source": "global NULLIFIER_LEAF_PREIMAGE_LENGTH: u64 = 3;\n\nuse crate::{merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u64,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u64 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr" }, "199": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "209": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "225": { "source": "use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    portal_contract_address : EthAddress,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt) &\n        self.portal_contract_address.eq(other.portal_contract_address)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.portal_contract_address.to_field(),\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            portal_contract_address: EthAddress::from_field(serialized[4]),\n            public_keys_hash: PublicKeysHash::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.portal_contract_address\n            )\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr" }, "235": { "source": "use dep::aztec::note::{note_getter::view_notes, note_viewer_options::NoteViewerOptions};\nuse dep::aztec::state_vars::PrivateSet;\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: PrivateSet<ValueNote>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(set: PrivateSet<ValueNote>, offset: u32) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let options = NoteViewerOptions::new().set_offset(offset);\n    let opt_notes = set.view_notes(options);\n    // docs:end:view_notes\n    let len = opt_notes.len();\n    for i in 0..len {\n        if opt_notes[i].is_some() {\n            balance += opt_notes[i].unwrap_unchecked().value;\n        }\n    }\n    if (opt_notes[len - 1].is_some()) {\n        balance += get_balance_with_offset(set, offset + opt_notes.len() as u32);\n    }\n\n    balance\n}\n", "path": "/usr/src/noir-projects/aztec-nr/value-note/src/balance_utils.nr" }, "239": { "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.owner.to_field(), self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr" }, "256": { "source": "contract Counter {\n    // docs:start:imports\n    use dep::aztec::prelude::{AztecAddress, Map};\n    use dep::aztec::context::Context;\n    use dep::value_note::{balance_utils, value_note::{ValueNote, VALUE_NOTE_LEN}};\n    use dep::easy_private_state::EasyPrivateUint;\n    // docs:end:imports\n\n    // docs:start:storage_struct\n    struct Storage {\n        counters: Map<AztecAddress, EasyPrivateUint>,\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(private)]\n    #[aztec(initializer)]\n    // We can name our initializer anything we want as long as it's marked as aztec(initializer)\n    fn initialize(headstart: u64, owner: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(headstart, owner);\n    }\n    // docs:end:constructor\n\n    // docs:start:increment\n    #[aztec(private)]\n    fn increment(owner: AztecAddress) {\n        let counters = storage.counters;\n        counters.at(owner).add(1, owner);\n    }\n    // docs:end:increment\n\n    // docs:start:get_counter\n    unconstrained fn get_counter(owner: AztecAddress) -> pub Field {\n        let counters = storage.counters;\n        balance_utils::get_balance(counters.at(owner).set)\n    }\n    // docs:end:get_counter\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/counter_contract/src/main.nr" }, "257": { "source": "use dep::aztec::{\n    protocol_types::address::AztecAddress, context::Context,\n    note::note_getter_options::NoteGetterOptions, state_vars::PrivateSet\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\nstruct EasyPrivateUint {\n    context: Context,\n    set: PrivateSet<ValueNote>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl EasyPrivateUint {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet { context, storage_slot };\n        EasyPrivateUint { context, set, storage_slot }\n    }\n\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress) {\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner);\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note, true);\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress) {\n        // docs:start:get_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let maybe_notes = self.set.get_notes(options);\n        // docs:end:get_notes\n\n        let mut minuend: u64 = 0;\n        for i in 0..maybe_notes.len() {\n            if maybe_notes[i].is_some() {\n                let note = maybe_notes[i].unwrap_unchecked();\n\n                // Ensure the notes are actually owned by the owner (to prevent user from generating a valid proof while\n                // spending someone else's notes).\n                assert(note.owner.eq(owner));\n\n                // Removes the note from the owner's set of notes.\n                // docs:start:remove\n                self.set.remove(note);\n                // docs:end:remove\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner);\n        self.set.insert(&mut result_note, result_value != 0);\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr" } } }
