{ "noir_version": "0.25.0+589a6cb62caf38445c768429150eee469ae35d77", "name": "Claim", "functions": [{ "name": "claim", "is_unconstrained": false, "custom_attributes": ["aztec(private)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "private_global_variables", "type": { "kind": "struct", "path": "aztec::context::globals::private_global_variables::PrivateGlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "proof_note", "type": { "kind": "struct", "path": "value_note::value_note::ValueNote", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "owner", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "randomness", "type": { "kind": "field" } }, { "name": "header", "type": { "kind": "struct", "path": "aztec::note::note_header::NoteHeader", "fields": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "nonce", "type": { "kind": "field" } }, { "name": "storage_slot", "type": { "kind": "field" } }, { "name": "is_transient", "type": { "kind": "boolean" } }] } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 33 }], "proof_note": [{ "start": 33, "end": 40 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "min_revertible_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "note_hash_read_requests", "type": { "kind": "array", "length": 32, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_key_validation_requests", "type": { "kind": "array", "length": 1, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest", "fields": [{ "name": "public_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_point::GrumpkinPoint", "fields": [{ "name": "x", "type": { "kind": "field" } }, { "name": "y", "type": { "kind": "field" } }] } }, { "name": "secret_key", "type": { "kind": "struct", "path": "aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey", "fields": [{ "name": "high", "type": { "kind": "field" } }, { "name": "low", "type": { "kind": "field" } }] } }] } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "private_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "encrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "encrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }] }, "visibility": "public" }, "return_witnesses": [1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459] }, "bytecode": "H4sIAAAAAAAA/+1dB5gURfavmdkEuwtLNrOIgpmpJa2YRjFHFDMKLsuCCIKSjZhRzGA49U448+mdeuZ05nTqmU899czKnTnH+8O/3k7Xzpva3tAz7y1VTNX31TfdPVXV7/fqheqq19Wjy4VYWCYaU0zluMoJlavReVFwrM+LjfMSo3yZcd7NOO9hnPcyzvsY59XG+cDgGCd9ngp+ByeHDRnSMLymQQ6WdcmazcfXDk0OGTp+WK2slUNrh06oqR08uKF2SO3wzcdvPjy5uRwyuEFOHLr54InJdNoAtZXMM8UQTyD1U3m5yusGv/2D3/WC3/WD3wHB78Dgd4NV5HcTlTcM+gzzZcNVDGcufNlIpPXPlG8hmst4Mr8kCdtKYno3FmkbAakkhH6dEiHHZajccmKs+F4mLVUhdDbrgxQhMRyduTFDu5sIOqPKhXsT+j5qMtpxJAzL0W+pypsGwhQXzRM1zjUIsYWQm2/bUh9gXmwW/A4SGUOADUI8hGf6Ggw6Vhj/6d8Yqr9CZPeRWSbWQjvlIXRUhVxjMwIaLDDpHQQemFVt3DNBfG8sTDkqdU2g1HIzQWcgBgkeIY8T848SczKkrfHJ+glD5fhhE4bLhrqhtfX1mw+WsqZuWN2w8TW1ExvGD5W1Q2tVm/V1NbXqdjV19bIhWTesoaNGDknBM3IAa+5HDm0Qw9GZkqHdGmH3yAEaraHvo1BaKQxjDUO7dxTzGFwqh6XppJSlwYJOhij5pwcAQF8/0XEjSy6nS03npoR0FiM6hwS/Q4PfYcHv8ABDz+C8VuXNVR6h8hYqb6nyVipvrfI2AW3bqrydyiNV3l7lHVTeUeWdVN5Z5V1U3lXl3VQeHTCoDNGSosI4RNY1OtCidFumHMXRf/q3WqRHxU1lg+twTetzLLgGTz+ri8z/ceM+jXWCawl0ragoq+nGa8XBie6TMpHhSUpQ8SM5DNrsRN1uUg4pE5mnCbp20/agImirJGhX36cT4lWl7hu6e0t8b/00pe+jrxeh49VQWV1O80MP5MpR/c7BcWUr9cqMepWoTOcQ/ClBi7/coAfTAakYHcMgUOvAaog2cjlOytpykT041vwTBr0C0aF/S8npSUroi7WDtiY1zNpz9tSpkydObpixR8OR4xtmzDx88lEHTJ41rWHmTDw61gBWMwDgR3f8PzZg+DgRck2DpWd+WjBK0X1S6LzM35vBwCZrykW2k4TUmsBj48hgmAeXo3u0h55yRE9nenoklwOCdrWBJ3yiToYZ+04Gr7Cxr0D8W1nG3tPcMTRXioyuY1qxDtlAo76GByIcOtg4aEZ8gAQDj23RfRlsyuAY4r8efBYZmItQmb6xDG07BNcqRLYt1hjC+rKCHkOrfVmBfjsj2jQ9XD60s0EPlh/9y23L6dqVtdjGlLTA4yJUZu/gt6to/8OC5k0l4hGX7rfUP/jeDLLaqG9d2sFHXeYgg49dDLo7hfBRY+jCi6VxPNKViUdVBo8qEB80j3SZwwweVbXAI2wLNG+qEI8YsNRAu92YeNTd4JGmvxvikS4zyeCRvm7yqCvikeaNLhtH5apQXbiu9Uf/vzy4rsth38U1Pm7t2QXbX65nF2xTILX32YVePuSQqM8u3RA93cnpSdsKBj1o9Hc9graon116GrzqZPCqEpXpgfjXk4F/MXRf3bY+1/fzNHuaPc2eZk+zp9nT7Gn2NHuaPc2eZk9z/jQDPeYcRzkq19kSGvW17ojGYnQsgvPnEb0M88VDgF49l6TnpzQdeJ5Tl/kE0fYyKtfV4C9eV2Ce02l1XQHPKVYg2jQ9XPNbFQY9FSH8MdcaMM8q0TWNoQu6puWnCl3TstQVXeuB8Otr8RBacFCY/tXrS1iPtGx0Q9f0GgGWZT2f1wO14bKcMNAzJIyeYoMebE9KjTK6bhEq83Xw21VwzRGm15h0v5prI90RTbrM94gmXFfTFbbGpPFgn8KAZQj2cab9w1h0mV9FNn/pfUg6gJFjbhew9graKhbZdglj1WVWoLKxWKaPyhEP9P9VIf/rFDPOU+hY8w8w96HH3Dg/rGPWdP/2Cbn36ohWontLfG8dR6fvo68XoeOusUxZXU7zQ/Na0w791js4xrSb9cqNepWoTO8Q/ClBi7+PQU8fg2aQnSIUq1CFgrB7MNHUuwUeFSMe6TJ4vYUrJsIcL5rjLzxGM30AXkPUZVYLeNhVZI+HsW83/TDg68WET99Lt63P9f0q0bUeiEYTIx4PuxzL0lH0FBn04PiOUqMMHkvoMhsiOQK6u5DTnR5LmM8fmpYuiCZdZlNEU5hshY0lNB5dFrBUkWNJr/V3M7Bo/lYhLLrMYIO/HPEHTFgljk3QY4nOIVh1mVpk40egsYLuk06orV1C/teptbEEttUMz/ZJPH7S/dsz5N69Ea1E984au+mxhL6Pvo7HbjujsYTp7zSvNe2gI9ruYtrNel2NethP9gjBnxK0+M25qJ4GzSA7WyE52wWNJehtV5qmHi3wqAjxqAc61r/aP+FndRzTpn+55ifMOD/zRR4ch4znHVqLfTV1k5RgmLQYLrIVXojmWwnk+zbqpoR0D6VrK9lRWwkQ4s/aSmB34bcSaJMYjs7cnaHdPQSdwnHh3oO+jzpMCYcJHiXcU3glbJMYjs7ck6HdvYTdSgi496Lvow5TwuGCRwlHCa+EbRLD0ZmjGNrdW9ithIB7b/o+YqEVPPZegn5TnX0ErSKDEmqFhJEGKOKw4Hd48AtpdPBLjQf6cx+Gdvcl7Ev9WCZa4EEyvySH0LWV1PMI+6m8v8oHqHygSL/TdbDKY1Q+ROVDVR6r8jiRfpepTuXxKterPEHlBpUnivQ7PIeL9KOpfnTdT2TmbeLBffD5Acb5gcb5Qcb5wcb5GOP8EOP8UON8rHE+zjg/zDivM87HG+f1xvkE47zBOJ9onE8yzg8XLTvEVPCbzC9lyVC+urMfYVt3ddAmYLnS2TAxnfana2vCAYT8u9sN/m1+IF1b8iBC/t3jBP8a5MFkbdXLMYT8u9cJ/tXKQ8jaSspDCfl3nwv8a0jKsVRt1SflOEL+3e8C/2qT8jCqtpQvryPk3wMO8K9BYR5P1Fa9aquekH9/c4B/tQrzBKK2FJmygZB/D9rPvwbAPJGmrXpoaxIh/x6yn3+1gPlwQfcsg58Z8uXfw5ZvQhwkSTjOl/cQ8u8RR/hHOE6V9xHy71FH+Ec4zpIPEPLvMUf4RzhOkA8S8u9xR/hH6Ofkw4T8e8IR/hHaafkoIf+edIR/hHZGPk7Iv6cc4R+hnkhCmZFc/Isb/LNpzn0yYb9CG9TrXbCWuK+gX/M7QtD2NTVu+MjDfgy43yy2GzfI4xEMuN+y/NlY0zmFkJeEfS3fslxuQF8mM8jNO5bj3o9JX951RF+mEvKSsK8lJf907I0eR4CNgFibqSITc3OkyE7UY479CduaJuwec8DHlfYX9Dr1geW2BGRoGgPuDx2xJdMJeUnY1/JDy+Vmcya5+cRy3GAjjmTAvcwRfTmKkJeEfS2XMfpesBHgc48SGd97tMhO1L6XMkZshrDb98JHDQ8Q9Dr1qeW2BGRoBgPuzxyxJTMJeUnY1/Izy+VmBJPcfGk5brARRzPg/soRfZlFyEvCvpZfMfpesBHgc2eJjO+dLbITte89kLCtOcJu3wsfEz5Q0OvUt5bbEpChOQy4v3PElswl5CVhX8vvLJebLZjk5kfLcYONmM2A+ydH9GUeIS8J+1r+xOh7wUaAz50nMr73GJGdqH0v5bs9xwq7fe+WIvOuIyUPf7XcloAMHcuA+zdHbMlxhLwk7Gv5m+VysyWT3Cy3HDfYiGMYcK9wRF+OJ+QlYV/LFYy+F2wE+NzjRcb3niCyE7XvPZiwrROF3b53K5HZV4CSh/ESu20JyNCJDLgTJW7YkvmEvCTsa5mwXG62YpKbEstxg404gQF3qSP6chIhLwn7WlLyz/S9YCPA554kMr73ZJGdqH0v5Z4Mpwi7fe/WIrOHDyUPO1tuS0CGTmHAXe6ILTmVkJeEfS3LLZebrZnkpovluMFGnMyAu6sj+nIaIS8J+1p2ZfS9YCPA554mMr73dJGdqH3vIYRtnSHs9r3biMx+eZQ87G65LQEZOoMBdw9HbMkCQl4S9rXsYbncbMMkN70txw024nQG3H0c0ZczCXlJ2NeyD6PvBRsBPvdMkfG9Z4nsRO17KffSWyjs9r3QzqGCXqfWsNyWgAwtZMC9piO25GxCXhL2tVzTcrlJMcnNOpbjBhtxFgPuvo7oyzmEvCTsa9mX0feCjQCfe47I+N5zRXai9r1jCds6T9jte7cVmX3gKXm4ruW2BGToPAbc/R2xJecT8pKwr2V/y+VmWya5GWA5brAR5zLgHuiIvlxAyEvCvpYDGX0v2AjwuReIjO+9UGQnat9LuQf6ImG3791OZL65QsnDjSy3JSBDixhwb+yILVlMyEvCvpYbWy432zHJzWaW4wYbcSED7kGO6MtFhLwk7Gs5iNH3go0An3uRyPjei0V2ova9hxG2dYmw2/eOFJnvm1HysMZyWwIydAkD7sGO2JJLCXlJ2NdysOVyM5JJboZZjvswkba71LiHO6IvvyPkJWFfy+GMvhdsBPjc34mM771MZCdq31tH2Nblwm7fu73IfEuUkocjLLclIEOXM+DewhFbcgUhLwn7Wm5hudxszyQ3W1uOG2zEZQy4t3FEX35PyEvCvpbbMPpesBHgc38vMr73DyI7Ufve8YRtXSns9r07iMx3uyl5uJ3ltgRk6EoG3CMdsSVLCHlJ2NdypOVyswOT3OxoOW6wEX9gwL2TI/qylJCXhH0td2L0vWAjwOcuFRnf+0eRnah9bz1hW1cJu33vjqqNegad2tVyWwIydBUD7t0csSVXE/KSsK/lbpbLzY5McrOn5bjBRvyRAfdejujLNYS8JOxruRej7wUbAT73GpHxvdeK7ETteycQtnWdsNv37qTamMCgU/tYbktAhq5jwD3aEVtyPSEvCftajrZcbnZikpv9LccNNuJaBtwHOKIvNxDykrCv5QGMvhdsBPjcG0TG9/5JZCdq39tA2NaNwm7fu7Nqo4FBpw623JaADN3IgHuMI7bkJkJeEva1HGO53OzMJDdjLccNNuJPDLjHOaIvfybkJWFfy3GMvhdsBPjcP4uM7/2LyE7UvnciYVs3C7t97y6qjYkMOjXeclsCMnQzA+56R2zJLYS8JOxrWW+53OzCJDcTLccNNuIvDLgnOaIvt1LyklBfJjH6XrAR4HNvFRnf+1eRnah97yTCtm4TdvveXVUbkxh06gjLbQnI0G0MuKc4YktuJ+QlYV/LKZbLza5McjPNctxgI/7KgHu6I/pyh6DjJWFfy+mMvhdsBPjcO0TG994pshO17z2csK27hN2+dzfVxuGCXqdmWG5LQIbuYsA90xFbcjchLwn7Ws60XG52Y5KbOZbjBhtxJwPuuY7oyz2EvCTsazmX0feCjQCfe4/I+N57RXYyfW8yvyR7EvbZvXR0JRNI9sMSFX59jxi6330qrxMclxn3JLnvkMbtOIQoytwbp3LUz7pMqco9EE1F9DRJaLeYut1kut1S+nab9AdSSdCuvk8x4lUnkeEzFSZ8by07ndA9ddfp4+6orC6n+aH7WtNeEeARBu1mvSKjXiUqUxKCPyVo8Zca9JQaNBeja1WAwZB3oE37jeWCVt5KGDCXI54LkY0F80GE9AGHXnUWaVsBaeas6TPqJjXs01A3AZu0IoPMMHOHr8fRNXycCLkmgttrmEXomqmG2KSVoGu6XSw6zcx+KvhN5pekCAGs287X990v6G1LHNEK+nF/8NtH5QcC5pkdEoYtmV+Sg+jaSnLS+QAhnSWIzr8Fvw8Gvw8Fvw8Hv48EWDYIzh9V+TGVH1f5CZWfVPkplZ9W+e8qP6Pysyo/p/I/VH5e5RdUflHll1R+WeVXVH5V5X+q/JrKr6v8hsr/UvlNld9S+W2V/63yOyq/q/J7Kr+v8gcqf6jyRyp/rPInKi9T+T8q/1fl3QPG84xtaibisY0pn3H0n/6tFuFjHmwgYmgctIbI/B837tNYJ7iWQNeKirKabrxWHJxgI1USXGP1n0OSw6HdztTtJmtqod0K8nbTY61KkeFNCt2nM+JVl+CYeqxVidqNofvo60XoeHVUVpfT/MBjLP2rfWiXVup1MupVojLlIfhTghZ/hUFPhUFzMTqGsZbWi00RbfRj8JoJ5SKjPwLxTxj06lSK6OEYo4Esrha0Nalh1qjZ46dOrt++blbdvjMaGg6YPGtaw8yZeBCkad/UoN0cIOn/ow6QmJ59GmUC+6gUOsc8LqO/d5LnmaKmceCqbYm2MZp+fb8iVGZA8NtVpPtKX9d04WdASBWIN9hmcTwfQbvlTDyqMHik6S9HPNJlNjV4VNECj7B964yONY/osSRroN1KJh51MXik6cf+QpcZYvCoSws8Kkd8Me0vD5bk4LKALg4eVRk8qkR80DzSZbYweKSvmzyqRDzC/ghSHLWN/WQcldH/Lw+um21AeR6eJIdAu93I203zWs//aF5r+vX9ilCZHRAvcF1NVzH6H1IF4o8uW4aOU4LOrrXmd/C96fmYrCkX2bwQovWxRjdET09yempqy9E92kNPT0RPD3J60j6HHmfa3/cK2iKcp2t8puht8KqbwatKVKYX4l9vBv7F0H112/pc38/T7Gn2NHuaPc2eZk+zp9nT7Gn2NHuaPc2eZk+zp9nT7Gn2NHuaPc2eZk+zpznlafY0e5pzohno0eu9mtZyVK67JTTqaz0QjUWINkiwZv8LusYQ01EbQ3zScQaaDhzTocv0iGVo+7/gWgX6vzvCU2lcY4oJyor11G1XIjo0jRpPJaKHK96hq0FP1xD+6OPSEJ51RtcwBn1Nx15VoWtalnCMqZYzrAtaT7uia/EQ+nR8IuYljoXWv2Y8GH7BA8u3xtkTXdOy3gu14bI8MdAzNIwesx9iIsP/UqMMjl/TZdYO9Lir4Ir5TMcw6f4348Xw+266TD9EE66r6QqLF9N48HuODFhqsV037STGossMNPjbk4EmHqxp+df6WCyy7RfGqstsgnzCZsEx1tduqK2tQv7XKWacp9BxT3T/PvSYG+OKdAy47t8+IffG7wkQ3Vvie+sYcn0ffb0IHW8Zy5TV5TQ/NK817aAjetyBaTfrVRr1KlGZ3iH4U4IWfx+Dnj4GzSA7EsmZliOuuLiwsS+2o5pHugx+j5chjjF0TKHp0PdrzQfgsZwuswOyUXjcjH2dLot9bi8mfOa7yvq8F6LLtPflIRjxuNm0KaQEw6DpEZFtqCBRb2xB+JKifJCQrk/p6Gpx84YYcb9R0ozp/UxkBiglIfSbsoGPy1A5ypfazfuatFSF0MmmMLhxqjY/DRhP3e7ngk5JuHB/Tt9HjUqYEM0TNf2Ub11z0vkgE520/VaTZYi+UHl+cFxm3IvkfkOSQ/Db2qa8gFNsesM6h7e1sUePoze48exCwniDuwpdiyHs2hBXU2GXySSeyWiiU2SexPU99dtInYyyqYA2+je507uN4D7H/BDofjphnlYgLJp/DG8mJ/FIVj9pdTHogXtXIfqJ7p01itZPWuZbZEXouK/IpCr0P56J06kb4l9VyP/4bfQKow6ehRUiIyNCZL+13s1oS6C2wujifBox33jsYmCCwVBHzNSZb/DimVP9i99yhQR9hGUQktbXCqNsSrDpgow6C4L7V/MZDyIZZrOTYbN43Q168AwXtb72QO3iWTh9Hc8gDhOZ1BP9r3mFn6D1U2UclcX/Y/vTzaiDZ8iEyJ4dwE/RvYy2hMh+e9Oki/Pp2nwjtLuBCfR1Q0QHw9uyrdoNzIMqhnuXi+z+hdSarlWF0EMo28lKRA++F8eKVNS3TrEMd2uFxmo6GpN4JUm3D+fbI3rx2+fVqDzeHEiX2Q21sVNwjN8wx6tf5hvmeKyq/9MrU7r9biH8oLZ9JahdrMN4LKLLjEJ45yHayMfAAW1YJ6pFpg8wzXiFs1o03/YNv8G+n8jwO2bwtBrdrxhd72G0XxzCH13mINR+HF3H+ha2yoPvAQlHDlD3N7bFmJbeCI8uM05k86tXC3R3Cqk7voW6mg967KnbqEC0YB/YvYV74lXJKgNT9xBMuszhBl1VLbRfEVJ3Sgt1NabKEEymPmGZAnrxuCZsBpy6/zEduF96hOCdgeicG0J/SQv0Y7+DV017MGDC/qNHCL0dbat02+ZEbZitCrMluswJwS/wsTykrOm3sg5SwW++E4ufEzMJjOIXovnAIM5Id75tfUnIg45agaCcVIwjOr8Kfr8WGWPINAE4OJetqHGYUyxkC8a4MaFYFVKuLNMk6aQetFtM3a6amMWhULp9wNI5mz1Nkw9lRtmU4NtuDE9k6tTaQ4GmDU+o4H5h2MoqiR8YWwohwg+r1A4Zb++IJw/1dbwlmN7+XYjsyUTNKzxRFba9Ff6/At233KgTNrjB23nr3yqjLSGyJ8JMurgevGOi5XA67DDxAxXH5HhrIQaYBwxboTbqGu5fSO2Z6MP0UG6jVCnCt+xj0GGJ7UV7sGMZLg+h0YaJ2C4h9FCu3FcievC9GPQziRfhsD5KdF/6rehlEi+EaNueQPeHhBc1tkT/DQ2OcQgolufWFgHwoleZURePXXBdPMmu28BbOur6MZH9cJFCdfH20FxbHhchHmFasL/SZbYLfvUDc1ELdJeF1N2hhbpCZPsj3UaFaD5ZFzfohbTcKIt1smsr9czjCqMOtnfFITThBTP6ie9sWddtJwwaMR9LjTJ4wkOX2QfVD+s/rFu6fXMyRtfB8qHL7G+0X9VC+2UhdQ9qoa4Q2fKBt9TWtOCxkbkYt9woi+WjtXrmsfnAjn1NUQhNeMxZhWhJBcfJfJJMB4fg54OiEPoqDdrxs1BK0NoRrEvQbsLgDZZnU1bDbPfk4FdPmJhlsb+JUT9wwyTBFyIbEEG7LUZLRb1PG5McrX6DJJlfkl8R8iMfHrRBZlaE0zfCRzhp7D7CyUc4Yf74CKd0SuaXfIQTEf0+wql1/vgIp3RK5pd8hJOPcPIRTsJHOKUIafMRTj7CyUc48emUj3Ci56tuu0MjnFyZsNNRTt+I5u+7UtEOdH8p6KO9viXkAwdumEj8lgH3dwz9D22exNT/XzPx4XsGPnyP+KBTgkEu2tmWbOP/5NeE/PxB2K1PDzLJ0bElvLgp7NwPDO0eR4xbpzhxvxP2j+TCTL2/CaWN+IaQrh8j9Gt7FvGobQToyo8MuvKToPc10OZJIjtRyxGlf6CUo58j8LOte3HJ0c8McvQLgxz9EshRR0XrU25VEkd0/hr8/iZ8tH6k5KP1m1JrE9w+Wt9H6+fKRx+t76P124vdR+v7aH0frR+doTj62kfrZ9fx0fo+Wt9H67ePGmw3dNsdGq0vjIMUETDKBa9VIVL/V0J+5MODNsjMitT/n/CR+hq7j9T3kfqYP/jePlI/Pz76SH0fqe8j9dMpJXykfnvp8JH66eQj9bOTj9TP7jMfqZ/dvo/U95H6PlLfR+rnw1fdthV7kSbzS6STdTrS53+CL0of6P1V0Ec8/R8DH6DNkxj58BsDHyhXvzUfliM+6EQdrR5hkrXNSNTfCPm5gpCfHHIEUXIc0eonOhCtvoKh3fmORKsT9o+c70i0OqWN+B8hXSCE7eXfyopWh0apdSUWo/c10OZJIjtRyxGlf6CUo3gEfq6saPU4gxwlGOQoEctEq3fEhzW/Ejw21C9mq4cudXJ9cFzIi9mVBk2aH/RRh0mJ+S9E9sRwWNRZwjJ6iiyjJ2YBPeVChL6FgiOq9DU9KZJA18yAByz/+B5mJCeW/1L0K0PuFw+5X0lIuY7gJ75XSjR/Q6UC0VFiCT1FltGTsIyeuEEP/r8Y/Z9AbeFoZjgvNephHcJv/5i60Un4gCSB+IpTCh37gKTWA5L0QqYQPiDJ5GN7ApJGIDp8QFJz+n1AUuv8iRqQNFZkkg9IyuZjewKS9kZ0+ICk5vQQyrYPSDJSSwFJUxG9UQKSZqI2pgfHq3JA0jyEdymizZWAJLzIzxGQdDJqPy7cD0haILL5FSUgaWELdTUfVlZA0gUGXVECkha3UFdjWtUCki5HdC4Jod/mgKQl6HgposGVgKRrg9/WApKw38o6SBEB4whIKoo1HxhwbpdIuVCdb1undNDifBtV21xQL4rRYS6mWxCUmH95L/Qz6Usxw6JqSYxeD0ti/IFgXxPygHKh/zRHgmQo9bCUUA+p+cehh6UMeljGoIdlIXoYJ6b7C8K2OhHKkevbD3YOCC2P+e0HIyW//WBTam2SzG8/6LcfzJWPfvtBv/1ge7H77Qf99oN++8HoDI0Jv/2gQPfDdfz2g+GLE377wUw7fvvBNDXYbui2O3T7QeoHbvh2V6dYNiCCdleJLQg7E04i5cODNsjMemujIua3INTYfcSvj/jF/MH31pMWfgvC3PjotyD0Eb9+C8J0Sgm/BWF76fARv+nkI36zk9+CMLvPYsJvQYjb91sQ+i0I/RaEfgvCfPiq2+7QLQhdmbDTUU4VKBqLi3bqaK9K4ok6jonESgbcXWL0/d8lxrf9YjkTH7oy8KEr4oNO1FG3ESaY24wEL4/R8bPKcn2CKEEOOTrD8u0XAXMVA+4Fjmy/SNg/kgszdWQ5pY2oILQR3SLYiJWx/SLoSjcGXenO4Gu6t8PX5Es3pX+glKMeEfi5MrZfBDnqwSBHPRnkqGcss/1iTDRP1Lx5kK6trGj9XgGhvWM+Wj9S8tH6Tam1CW4fre+j9XPlo4/W99H67cXuo/V9tL6P1o/O0Jjw0foC3Q/X8dH6PlrfR+u3jxpsN3TbHRqtL4yDFBEwygWvVSFSvxfxgkWuPGiDzKxI/T4xH6mvsftIfR+pj/mD760nLHykfm589JH6PlLfR+qnU0r4SP320uEj9dPJR+pnJx+pn91nMeEj9XH7PlLfR+r7SH0fqZ8PX3XbHRqpL4yDFBEwysk6HenTJ8YXpQ/09mKIeFqNgQ+rBRFPXHzozcCH1Rn4sDrig07U0eoRJlnbjETtHaPj5xrEk7/UcgRRchzR6gsdiFZfgwH32Y5EqxP2jzzbkWh1ShvRh9BGrBnBRqysaPU1GXRlLQZfs1Y7fE2+dFP6B0o5WjsCP1dWtPraDHK0DoMcrRPLRKuHLUBT84ZrOze/mK0W4NTJ9cFxIS9mVxo0aX7QRx227+PzmJ6EZfQUWUZPzAJ6yoUIfQsFR1Tpa3pSJIGumQEPWP7xPcxITiz/pehXhtwvHnK/kpByHcHP9nx8PmbQuLLpKbKMnoRl9MQNevD/xej/BGoLRzPDealRD+sQfvvH1I1OwgckCcRXnFLo2AcktR6QpBcyhfABSSYf2xOQNALR4QOSmtPvA5Ja5w++t9bX1gKSxopM8gFJ2XxsT0DS3ogOH5DUnB5C2fYBSUZqKSBpKqI3SkDSTNTG9OB4VQ5ImofwLkW0uRKQhBf5Y4I+IOlk1H5cuB+QtEBk8ytKQNLCFupqPqysgKQLDLqiBCQtbqGuxrSqBSRdjuhcEkK/zQFJS9DxUkSDKwFJ1wa/rQUkYb+VdZAiAsYRkNQ31nxgwLldIuVCdb5tnddBi/NtVG1zQb0vIeZqOhmSmH/50sWlL9UMi6r9GPSwX4w/EIxyKznKhf4LHAmSodTDdQn1kJp/HHq4LoMe9mfQw/4doIcPEPLgYcK21iPkZ0dtZbgesQzotH6s+aBRiJbHSvi4DJWj3JLJvK9JS1UInc36IEVIDEdnrh+jb3dAzO6BCuAeECPvo2RHRWg9LHgcODWdDzDRSdtvNVmGaGDMbzeisfvVfb+6j/mD792e1X2/3UjLfPTbjfjVfb/dSDqlhN9upL10+NX9dPKr+9nJbzeS3WdRV/dHIbx+u5FM+367keZ1x7dQV/PBbzfitxuhwOS3G2lldT/ficUBMVomgVEcGGs+MIgz0p1vWxsQ8qCjViAoJxXjiM4NA0I3ivmPKUVK/mNKTam1hwL/MSX/MaVc+eg/puQ/ptRe7P5jSv5jSv5jStEZGhP+Y0oC3Q/X8R9TCp+M0XX8x5T8x5Q0Ndhu6LY79GNK1A/cMEkwMJYNiKDdVeKDShvSTaAk8+FBG2RmRTht7COcmrD7CCcf4YT5g+/tI5zy46OPcPIRTj7CKZ1Swkc4tZcOH+GUTj7CKTv5CKfsPvMRTtnt+wgnH+HkI5x8hFM+fNVtd2iEkysTdjrKaeNY8/ddqWgHujeI0Ud7bUI8UccxkbgJA+5NY/T9D22exNT/GzHxYTMGPmyG+KAT9d4FESaY29zXZqMYHT8HWa5PECXIIUeLLP+YFGAexIB7sSMfkyLsH8mFmXqfHEobsTGhjUhGsBEr42NSoCtJBl2RDL5GtsPX5Es3pX+glKOaCPxcGR+TAjmqYZCjwQxyNDiW+ZhUTDRP1Lx5mK6trGj9IQGhQ2M+Wj9S8tH6Tam1CW4fre+j9XPlo4/W99H67cXuo/V9tL6P1o/O0Jjw0foC3Q/X8dH6PlrfR+u3jxpsN3TbHRqtL4yDFBEwygWvVSFSfwjxgkWuPGiDzKxI/WExH6mvsftIfR+pj/mD760nLHykfm589JH6PlLfR+qnU0r4SP320uEj9dPJR+pnJx+pn91nMeEj9XH7PlLfR+r7SH0fqZ8PX3XbVuxFmswvkU7W6UifYTG+KH2gdwhDxNNwBj4MDyKeuPgwlIEPtQx8qEV80Ik6Wj3CJGubkahDY3T83Jx48pdajh4WPNHqlzgQrb45A+5LHYlWJ+wfeakj0eqUNmIYoY0YEcFGrKxo9REMurIFg6/Zoh2+Jl+6Kf0DpRxtGYGfKytafUsGOdqKQY62imWi1Tviw5pc27n5xWwhtlYn1wfHhbyYXWnQpPlBH3WYfmDGKYWOw6LOEpbRU2QZPTEL6CkXIvQtFBxRpa/pSZEEumYGPGD5x/cwIzmx/JeiXxlyv3jI/UpCynUEP/G9UqL5GyoViI4SS+gpsoyehGX0xA168P/F6P8EagtHM8N5qVEP6xB++8fUjU7CByQJxFecUujYByS1HpCkFzKF8AFJJh/bE5A0AtHhA5Ka0+8DklrnD7631tfWApLGikzyAUnZfGxPQNLeiA4fkNScHkLZ9gFJRmopIGkqojdKQNJM1Mb04HhVDkiah/AuRbS5EpCEF/ljgj4g6WTUfly4H5C0QGTzK0pA0sIW6mo+rKyApAsMuqIEJC1uoa7GtKoFJF2O6FwSQr/NAUlL0PFSRIMrAUnXBr+tBSRhv5V1kCICxhGQtHWs+cCAc7tEyoXqfNu6vIMW59uo2uaC+taEmLehkyGJ+ZcvXVz6sg3DomqKQQ9TMf5AMMqt5CgX+n/vSJAMpR5uS6iH1Pzj0MNtGfRwOwY93C5ED+PEdA8klKORhHLk+vaD2weE7hDz2w9GSn77wabU2iSZ337Qbz+YKx/99oN++8H2YvfbD/rtB/X9/PaD7WdoTPjtBwW6H67jtx8MX5zw2w9m2vHbD6apwXZDt92h2w9SP3DDt7tGxrIBEbS7SmxBuD3hJFI+PGiDzKy3NnaM+S0INXYf8esjfjF/8L31pIXfgjA3PvotCH3Er9+CMJ1Swm9B2F46fMRvOvmI3+zktyDM7rOY8FsQ4vb9FoR+C0K/BaHfgjAfvuq28SKExsy2BaErE3Y6ymlHFI3FRTt1tNdOxBN1HBOJOzHg3jlG3//Q5klM/b8DEx92YeDDLogPOlFH3UaYYG4zEnyHGB0/d7Vcnx4WPHJ0peXbLwLmXRlwL3Fk+0XC/pFcmKkjyyltxI6ENmK3CDZiZWy/CLqyG4Ou7M7ga3Zvh6/Jl25K/0ApR3tE4OfK2H4R5GgPBjnak0GO9oxltl+MieaJmjcP0LWVFa2/V0DoqJiP1o+UfLR+U2ptgttH6/to/Vz56KP1fbR+e7H7aH0fre+j9aMzNCZ8tL5A98N1fLS+j9b30frtowbbDd12h0brC+MgRQSMcsFrVYjU34t4wSJXHrRBZlak/t4xH6mvsftIfR+pj/mD760nLHykfm589JH6PlLfR+qnU0r4SP320uEj9dPJR+pnJx+pn91nMeEj9XH7PlLfR+r7SH0fqZ8PX3XbHRqpL4yDFBEwysk6Hemzd4wvSh/o3Ysh4mkfBj7sE0Q8cfFhFAMfRjPwYTTig07U0eoRJlnbjEQdFaPj577Ek7/UcgRRchzR6lc5EK2+LwPuqx2JVifsH3m1I9HqlDZib0IbsV8EG7GyotX3Y9CV/Rl8zf7t8DX50k3pHyjl6IAI/FxZ0eoHMMjRgQxydGAsE60etgBNzRuu7dz8YraatFEn1wfHhbyYXWnQpPlBH3XYvo/PY3oSltFTZBk9MQvoKRci9C0UHFGlr+lJkQS6ZgY8YPnH9zAjObH8l6JfGXK/eMj9SkLKdQQ/2/Px+ZhB48qmp8gyehKW0RM36MH/F6P/E6gtHM0M56VGPaxD+O0fUzc6CR+QJBBfcUqhYx+Q1HpAkl7IFMIHJJl8bE9A0ghEhw9Iak6/D0hqnT/43lpfWwtIGisyyQckZfOxPQFJeyM6fEBSc3oIZdsHJBmppYCkqYjeKAFJM1Eb04PjVTkgaR7CuxTR5kpAEl7kjwn6gKSTUftx4X5A0gKRza8oAUkLW6ir+bCyApIuMOiKEpC0uIW6GtOqFpB0OaJzSQj9NgckLUHHSxENrgQkXRv8thaQhP1W1kGKCBhHQNJBseYDA87tEikXqvNt67oOWpxvo2qbC+oHEWI+mE6GJOZfvnRx6cvBDIuqYxj0cEyMPxCMcis5yoX+GxwJkqHUw0MI9ZCafxx6eAiDHh7KoIeHxjp2K75HBC0GncbGmg96hGjZ1+PjMlSOcksh874mLVUhdDbrgxQhMRydOTZG3+64mN2OFnCPi5H3UbKjlPBhwaOEh3klbJsYjs48jEEJ6yxXQsBdx6CEHLTCByU4QuvHx+zGDUayjgF3veW4v1RtVDLgnsCMm0IeoW+on+QI5VzWE9q1BsvlEOSlgUEOJ1qO+z7VxkQm36BTnJGn+bY1KcY7ZsmXPnjVbBKDXN5o+czAg0y4b3LkVTPC/pE3ldjtC+9j6uubLZfxh5hw3+KIjBP2j6TE3FGTCw/StZU1uXC4n1xomxiOzjycYXJhsuWTC4B7ssMzfA8JHiU8with28RwdOYRDEo4xXIlBNxTHJnhA2MxhWHUM9XyJ22Y3ZvKgPtI4rVOvHU7GHcwQA8Fv48Evw8Hv5CmBYCoccGM6JEM/JpO+MSvR8Q6UcvM3+jaSm4QtHOUIvJolWeoPFPlWSrPVnmOynNVnqfyMSofq/JxKh+v8gkqn6jyfJVPUvlklU9R+VSVT1P5dJXPUHmBymeqfJbKC1U+W+VzVD5X5fNUPl/lC1S+UOVFKi9W+SKVL1b5EpUvjaWfMoCP8YDWGDo/2jifYZzPNM5nGeezjfM5xvlc43yecX6McX6scX6ccX68cX6CcX6icT7fOD/JOD/ZOD/FOD/VOD/NOD/dOD/DOF9gnJ9pnJ9lnC80zs82zs8xzs81zs8zzs83zi8wzi80zhcZ54uN84uM84uN80uM80tjLQ/QUsFvMr+UpdP52jLQD6q2brM81qphYjodHSNra8IMQv7d7gb/Np9Jxz85i5B/dzjBvwY5m4x/9XIOIf/udIJ/tXIuGf+Sch4h/+5ygX8NSXkMFf/qk/JYQv7d7QL/apPyOCr+KV9+PCH/7nGAfw0K8wlE/KtXbZ1IyL97HeBfrcI8n4h/ikx5EiH/7rOffw2A+WQa/tVDW6cQ8u9++/lXC5hPpeEfkClPI+TfA9bzr6ER8+kk/KtvbOsMQv79zXr+1TZiXkDCv0Yy5ZmE/HvQdv41pDGfRcG/+nRbCwn595Dt/KtNYz6bgn9pMuU5hPx72HL+TQgwn0uAeXzQ1nmE/HvEcv4NDzCfnz/mGr1x9QWE/HvUbv5JjfnCvDHXTtRtLSLk32NW8692vMa8OH/+NW2cfhEh/x63mn/DmzBfnDfmoU1tXULIvyes5p9swnxpjG4t5TbCfQaetGPPh7aSJFxnkHcQ8u8pR/hHOE8u7yLk39OO8I9wnlfeQ8i/vzvCP8J5SnkfIf+ecYR/hPNs8gFC/j3rCP8I54nkg4T8e84R/hHOc8iHCfn3D0f4R/icLh8l5N/zjvCP8DlTPk7Ivxcc4R/hc5J8kpB/LzrCP8JxvnyakH8vOcI/wnGqfIaQfy87wj/CcZZ8jpB/rzjCP8JxgnyekH+vOsI/Qj8nXyTk3z8d4R+hnZYvE/LvNUf4R2hn5KuE/HvdEf4R6okklBnJxb+4wT+b3jn4HeFaALQRI5YVeLdteoz+HbTLYrR9TY37UZF594oS93LLd+QAebyMAfcKR/YxvpxQHwn7Wq6wXG5AX37HIDfxUrtxH8WkL4lSN/TlCkJ9IexrSck/6Ft4J1yPI8BGwLvfV8Qy74D/PiayEvWY42jCMccfLB9zPCYy7zlT8rDEclsCMvQHBtyljtiSKwnlkrCvZanlcgP6wiE3nS3HDTbi9wy4yx3RlyWE+kLY17Kc0fdeGfjcJcj3LmX2vZTvyP/Rct/7uMjsKULJwy6W2xKQoT8y4O7qiC25ilAuCftadrVcbkBfOOSmu+W4wUYsZcDdwxF9uZpQXwj7WvZg9L1XBT73auR7r2H2vTMJfe+1lvveJ0Rm/y5KHva23JaADF3LgLuPI7bkOkK5JOxr2cdyuQF94ZCbNSzHDTbiGgbcazqiL9cT6gthX8s1GX3vdYHPvR753huYfS/l3mZ/stz3Pikye2VS8nAdy20JyNCfGHD3dcSW3Egol4R9LftaLjegLxxys67luMFG3MCAu78j+nITob4Q9rXsz+h7bwx87k3I9/6Z2ffOJvS9f7Hc9z4lMvtSU/JwgOW2BGToLwy4BzpiS24mlEvCvpYDLZcb0BcOudnIctxgI/7MgHtjR/TlFkJ9IexruTGj77058Lm3IN97K7PvpdyT+q+W+96nReYbEJQ83MxyWwIy9FcG3IMcsSW3EcolYV/LQZbLDegLh9zUWI4bbMStDLgHO6IvtxPqC2Ffy8GMvve2wOfejnzvHcy+dy6h773Tct/7d5H53hIlD4dZbktAhu5kwD3cEVtyF6FcEva1HG653IC+cMjNCMtxg424gwH3Fo7oy92E+kLY13ILRt97V+Bz70a+9x5m30v5LaF7Lfe9z4jMtw0pebi15bYEZOheBtzbOGJL7iOUS8K+lttYLjegLxxys53luMFG3MOAe6Qj+nI/ob4Q9rUcyeh77wt87v3I9z7A7HuPIfS9f7Pc9z4rMt8RpuThjpbbEpChvzHg3skRW/IgoVwS9rXcyXK5AX3hkJtdLccNNuIBBty7OaIvDxHqC2Ffy90Yfe+Dgc99CPneh5l9L+U3YB+x3Pc+p9o4lkGn9rTcloAMPcKAey9HbMmjhHJJ2NdyL8vlBvSFQ272sRw32IiHGXCPdkRfHiPUF8K+lqMZfe+jgc99DPnex5l973GEvvcJy33vP1QbxzHo1P6275GgGnyCAfcBjtiSJwnlkrCv5QGWyw3oC4fcHGw5brARjzPgHuOIvjxFqC+EfS3HMPreJwOf+xTyvU8z+97jCX3v3y33vc+rNo5n0Kmxtserqgb/zoB7nCO25BlCuSTsaznOcrkBfeGQm/GW4wYb8TQD7npH9OVZQn0h7GtZz+h7nwl87rPI9z7H7HtPIPS9/7Dc976g2jiBQacm2j53qBr8BwPuSY7YkucJ5ZKwr+Uky+UG9IVDbo6wHDfYiOcYcE9xRF9eINQXwr6WUxh97/OBz30B+d4XmX3viYS+9yXLfe+Lqo0TGXRqmuW2BGToJQbc0x2xJS8TyiVhX8vptsuN4JGbGZbjBhvxIgPumY7oyyuE+kLY13Imo+99OfC5ryDf+yqz751P6Hv/abnvfUm1MZ9Bp+ZYbktAhv7JgHuuI7bkNUK5JOxrOddyuQF94ZCbYy3HDTbiVQbcxzmiL68T6gthX8vjGH3va4HPfR353jeYfe9JhL73X5b73pdVGycx6NSJltsSkKF/MeCe74gteZNQLgn7Ws63XG5AXzjk5hTLcYONeIMB96mO6MtbhPpC2NfyVEbf+2bgc99CvvdtZt97MqHv/bflvvcV1cbJDDp1huW2BGTo3wy4FzhiS94hlEvCvpYLLJcb0BcOuVloOW6wEW8z4D7bEX15l1BfCPtans3oe98JfO67yPe+x+x7TyH0ve9b7ntfVW2cwqBT51luS0CG3mfAfb4jtuQDQrkk7Gt5vu1rFYJHbhZZjhtsxHsMuBc7oi8fEuoLYV/LxYy+94PA536IfO9HzL73VELf+7Hlvvefqo1TGXTqEsttCcjQxwy4L3XElnxCKJeEfS0vtVxuQF845OZyy3GDjfiIAfcVjujLMkJ9IexreQWj7/0k8LnLkO/9D7PvPY3Q9/7Xct/7mmrjNAadutJyWwIy9F8G3EscsSWfEsolYV/LJZbLDegLh9xcZTlusBH/YcB9tSP68hmhvhD2tbya0fd+Gvjcz5Dv/ZzZ955O6Hu/sNz3vq7aOJ1Bp66z3JaADH3BgPt6R2zJl4RySdjX8nrL5Qb0hUNubrQcN9iIzxlw3+SIvnxFqC+EfS1vYvS9XwY+9yvke79m9r1nEPrebyz3vW+oNs5g0KmbLbclIEPfMOC+xRFb8i2hXBL2tbzFcrkBfeGQm9ssxw024msG3Lc7oi/fEeoLYV/L2xl977eBz/0O+d7vmX3vAkLf+4Plvvdfqo0FDDp1l+W2BGToBwbcdztiS34klEvCvpZ3Wy43oC8ccnOf5bjBRnzPgPt+R/TlJ0J9IexreT+j7/0x8Lk/Id/7M7PvPZPQ9/5iue99U7VxJoNOPWi5LQEZ+oUB90OO2JJfCeWSsK/lQ5bLDegLh9w8ajlusBE/M+B+zBF9+Y1QXwj7Wj7G6Ht/DXzub8j3/o/Z955F6Hv/z3Lf+5Zq4ywGnXrSclsCMvR/DLifcsSWLCeUS8K+lk9ZLjegLxxy84zluMFG/I8B97OO6MsKQn0h7Gv5LKPvXR743BXI9zb9aZxS8Xkhoe+Nxe32vW+rNhYy6NTzltsSEBroG2rcLzhiS+KEcknY1/IFy+UG9IVDbl62HDfYCMGA+xVH9CVBqC+EfS1fYfS9YCPA5ybiGd9bxOx7zyb0vcWW+95/qzbOZvC9r1luS0CGihlsyeuO2JISQrkk7Gv5uuVyA/rCITdvWo4bbEQRA+63HNGXUkJ9Iexr+Raj7y0JfG4p8r1lzL73HELf28ly3/uOauMcBt/7juW2BGSoE4MtedcRW9KZUC4J+1q+a7ncgL5wyM0HluMGG1HGgPtDR/SlnFBfCPtafsjoezsHPrcc+d4KZt97LqHvrbTc976r2jiXwfd+YrktARmqZLAlyxyxJV0I5ZKwr+Uyy+UG9IVDbj61HDfYiAoG3J85oi9dCfWFsK/lZ4y+t0vgc7si31vF7HvPI/S93Sz3ve+pNs5j8L1fWm5LQIa6MdiSrxyxJd0J5ZKwr+VXlsvNe4JHbr61HDfYiCoG3N85oi89CPWFsK/ld4y+t3vgc3sg39uT2feeT+h7e1nue99XbZzP4Ht/tNyWgAz1YrAlPzliS3oTyiVhX8ufLJcb0BcOufnVctxgI3oy4P7NEX3pQ6gvhH0tf2P0vb0Dn9sH+d7VmH3vBYS+d3XLfe8Hqo0LGHzvcsttCcjQ6gy2ZIUjtmQNQrkk7Gu5wnK5AX3hkJt4md24wUasxoA7UeaGvqxJqC+EfS0p+Wf63jUCn7sm8r1rMfveCwl979qW+94PVRsXMvjeEsttCcjQ2gy2pNQRW7IOoVwS9rUstVxuQF845Kaz5bjBRqzFgLvcEX3pS6gvhH0tyxl97zqBz+2LfG81s+9dROh7+1nuez9SbSxi8L1dLLclIEP9GGxJV0dsybqEcknY17Kr5XID+sIhN90txw02opoBdw9H9KU/ob4Q9rXsweh71w18bn/ke9dj9r2LCX3v+pb73o9VG4sZfG9vy20JyND6DLakjyO2ZAChXBL2texjudyAvnDIzRqW4wYbsR4D7jUd0ZeBhPpC2NdyTUbfOyDwuQOR792A2fdeROh7N7Tc936i2riIwfeuY7ktARnakMGW9HXElmxEKJeEfS37Wi43oC8ccrOu5bjBRmzAgLu/I/qyMaG+EPa17M/oezcKfO7GyPduwux7Lyb0vZta7nuXqTYuZvC9Ayy3JSBDmzLYkoGO2JLNCOWSsK/lQMvlBvSFQ242shw32IhNGHBv7Ii+DCLUF8K+lhsz+t7NAp87CPneJLPvvYTQ90rLfe9/VBuXMPjezSy3JSBDksGWDHLEltQQyiVhX8tBlssN6AuH3NRYjhtsRJIB92BH9GUwob4Q9rUczOh7awKfOxj53iHMvvdSQt871HLf+1/VxqUMvneY5bYEZGgogy0Z7ogtGUYol4R9LYdbLjegLxxyM8Jy3GAjhjDg3sIRfRlOqC+EfS23YPS9wwKfOxz53to2fG8yvyR7E/ZZbZxHtqjHG+sR8u8+QS8PWpf6ibQcrBv89hcZudg8sA1Z8QLB/5sj+RkRT7cXE80Ttc1aX9DyQqctFIbi4LgkhH6dEiHHZajcckKs5n1NWqpC6GzWB6ngN5lfYhmoQmduEadvd8s4nSJz4d4yTt5HrAZtIGFbWxE63igGbetWDNrWyKBtE1JuvaDcNkG5IuAH80MrpRxvu5J4vl0rPN8O8XxkKzwfiXi+fUi59YNy2wflgK4dgj85bMtWDIPmHYkHNtS4AfO2DLh3shw36PiODLi3tvzhEPRnJwbc2zjycLgzob0k7GtJyT/gmeHCBIcsDRK0fU79gApjmxFxWlu5M8P4DvfVLoFuVgfnu6rz3VTeXeU9VN5T5b1UHqXy3irvo/JolfdVeT+V91f5AJUPVPkglQ9WeYzKh6h8qMpjVR6n8mEq16k8XuV6lSeo3KDyRJUnqXy4ypNVXj8QmjKRjZsE+5CawY0PZUXptkyZjaP/9G+1yuW4bHAdrmlbEQuularcW2T+jxv3AUzF5Jga16iaHjbJ2k3WJMtEph/o2k0/MHcK2ioJ2i1D55pXnTV/6e4t8b1jQdb36YS6WB/3QmV1Oc0P/OAOqUKkZUAYtJv1io16lahMaQj+lKAfc2N6ygyai9ExTA5oOe6HaNNqQjlRUYnoYtWZgA/C4INA+CFhehKW0ROzgJ5y0XyiqBz9H0fXtF4XoWta1hPoWjzkHvr/EnRNt1OKfrdB/5eF0NAp5H6dW6GrLIT+TiE4O4e0h/tH10kJ2v4x7aNpxyoQHZ0toSdhGT1xgx4sJ6XomumfyoMMCctq3LgHll8sT1jedHkef1sjsfwKxBOcUui4DP2WktOTlMDrnkFbkxpm7dFw5PiGGTMPn3zUAZNnTWuYORNPQmu6+xl0x0Q2Bv0/nljH4zt8vSjkGsbOMOZplMdSdJ+UaG5nmHQhyTOWqGnEpOVXj+M0/diu6jK7Bb9dRbrv9HVNl2ljK0S2zmgeldPzqNX+wfdmGJPVYFuiU2v6iW1nJTk9NUnsx9pDTyWip4KcnqTkwZnWiy5BW4Tj2Mbnm64GrzobvKpEZbog/nVl4F9MZI8dU+hc38/T7Gn2NHuaPc2eZk+zp9nT7Gn2NHuaPc2eZk+zp9nT7Gn2NHuaPc320wznej0Br2tWomMbaNTXKhBdei1VrwHB+buIXvr1sZokXivW61gmHUWozDeItg8RBsxr/Ru2hkQfq9X6+lUJotFc2+ZcT+tk0IPXxPUv5ovJM8zPsPiLeEh7CQMfXmvHbbTUXxXGNaa1p0b+6HvptvU51gu8FtrR9JhxR1CmC+IvLqPrFqEyvwW/XQWXrUmvQesX2EoMPnZFNOkyK9B/uK6mC+uK/tV4dFnA0o0eS6Md6m5g0fzthrDoMsWxbP52Z6CJB2ta3npoHCLbPmCsukznWKZsRXBcjvoExy6uGfK/TjHjPIWONf8Acy96zI39q+ODdf/2Crl3H0Qr0b0lvreOndH30deL0PEasUxZXU7zQ/Na0w46ouN5MO1mvSqjXiUq0zMEf0rQ4u9l0NPLoBlkpyuSszVRLDrXOKlnCzzCtleX6YKuaf+ky5ej/7Hv4oqt62LQrc87IRr1ta6ILtNf4PGdqZtkBMeNdmPE7cNLFERtJauDdo5QbU5RearKR6o8TeXpKh+l8tEqz1B5psqzVJ6t8hyV56o8T+VjVD5W5eNUPl7lE1Q+UeX5Kp+k8skqn6LyqSqfpvLpKp+h8gKVz1T5rHh6cAV8ige0xND5FON8qnF+pHE+zTifbpwfZZwfbZzPMM5nGuezjPPZxvkc43yucT7POD/GOD/WOD/OOD/eOD/BOD/ROJ9vnJ9knJ9snJ9inJ9qnJ9mnJ9unJ9hnC8wzs80zs+KN1dG88W4ZH4pS2fyfcnuCMK2trP8xcKGiek0JU7W1oSphPwb6Qb/Nj+Sjn9yGiH/tneCfw1yOhn/6uVRhPzbwQn+1cqjyfiXlDMI+bejC/xrSMqZVPyrT8pZhPzbyQX+1SblbCr+KV8+h5B/OzvAvwaFeS4R/+pVW/MI+beLA/yrVZiPIeKfIlMeS8i/Xe3nXwNgPo6Gf/XQ1vGE/NvNfv7VAuYTaPgHZMoTCfm3u/X8a2jEPJ+Ef/WNbZ1EyL89rOdfbSPmk0n410imPIWQf3vazr+GNOZTKfhXn27rNEL+7WU7/2rTmE+n4F+aTHkGIf9GWc6/CQHmBQSYxwdtnUnIv70t59/wAPNZcbq5RDxnly//9ukg/iXzS5Jwnk1uT8i/0Y7wj3CeSO5IyL99HeEf4TyH3JmQf/s5wj/C53S5KyH/9neEf4TPmXJ3Qv4d4Aj/CJ+T5J6E/DvQEf4RjvPlKEL+HeQI/wjHqXIfQv4d7Aj/CMdZcl9C/o1xhH+E4wS5PyH/DnGEf4R+Th5IyL9DHeEfoZ2WBxPyb6wj/CO0M/IQQv6Nc4R/hHoiCWVGcvEvbvDPppizhYRzYdAGdXyr3tg8RszDE4n7mhq33oCdGvd8y+doNZ1nE8olYV/L+ZbLDWyifwSD3JxiOW6wY2cz4D7VEX05h1BfCPtanuqAvixkkJszLMd9BJO+LHBEX84l1BfCvpaU/IO+hRex9PgTbARsNntuPPPRsvPiIitRj1Up3hXQbZ1v+VgVPl4zhUGnFlpuS0CGzmfAfbYjtuQCQrkk7Gt5tuVysxuT3JxnOW6wEecx4D7fEX25kFBfCPtans/oey8IfO6FyPcuYva9lO/WLbbc98JH46Yy6NQiy20JyNBiBtyLHbElFxHKJWFfy8WWy83uTHJzieW4wUYsYsB9qSP6cjGhvhD2tbyU0fdeFPjci5HvvYTZ91K8490kW5b7XvhY65EMOnW55bYEZOhSBtxXOGJLfkcol4R9La+wXG72YJKbKy3HDTbiEgbcSxzRl8sI9YWwr+USRt/7u8DnXoZ87+XMvpdyT5QrLPe98JH0aQw6dZXltgRk6AoG3Fc7Ykt+TyiXhH0tr7ZcbvZkkpvrLMcNNuJyBtzXO6IvfyDUF8K+ltcz+t7fBz73D8j3Xsnseyn25moa11nue/eKZ/aTpOThjZbbEpChJQy4b3LEliwllEvCvpY3WS43ezHJzc2W4wYbcSUD7lsc0Zc/EuoLYV/LWxh979LA5/4R+d6rmH0v5V6WV1vue0fFM3s3U/LwNsttCcjQ1Qy4b3fEllxDKJeEfS1vt1xuRjHJzV2W4wYbcRUD7rsd0ZdrCfWFsK/l3Yy+95rA516LfO91zL6XYk/lpjkVy33v3vHMdxIoeXif5bYEZOh6Btz3O2JLbiCUS8K+lvdbLjd7M8nNg5bjBhtxHQPuhxzRlz8R6gthX8uHGH3vDYHP/RPyvTcy+17KbxDcZLnv3See+SYRJQ8ftdyWgAzdxID7MUdsyZ8J5ZKwr+VjlsvNPkxy86TluMFG3MiA+ylH9OUvhPpC2NfyKUbf++fA5/4F+d6bmX0vxbdwmtYzLPe9o+OZ7/9R8vAZy20JyNAtDLifdcSW3Eool4R9LZ+1XG5GM8nN85bjBhtxMwPuFxzRl78S6gthX8sXGH3vrYHP/Svyvbcx+17Kb8fdbrnv3Tee+dYuJQ9fttyWgAzdzoD7FUdsyR2EcknY1/IVy+VmXya5ec1y3GAjbmPA/boj+nInob4Q9rV8ndH33hH43DuR772L2fdSfMO0KZbAct+7XzzzXXtKHr5puS0BGbqbAfdbjtiSewjlkrCv5VuWy81+THLzjuW4wUbcxYD7XUf05V5CfSHsa/kuo++9J/C59yLfex+z76X85vf9lvve/RV9cxh06gPLbQnI0P0MuD90xJY8QCiXhH0tP7RcbvZnkptPLMcNNuI+BtzLHNGXvxHqC2Ffy2WMvveBwOf+DfneB5l971xC3/uQ5b73AEXfXAad+tRyWwIy9BAD7s8csSUPE8olYV/LzyyXmwOY5OZLy3GDjXiQAfdXjujLI4T6QtjX8itG3/tw4HMfQb73UWbfO4/Q9z5mue89UNE3j0GnvrXcloAMPcaA+ztHbMnjhHJJ2NfyO8vl5kAmufnRctxgIx5lwP2TI/ryBKG+EPa1/InR9z4e+NwnkO99ktn3HkPoe5+y3PcepOg7hkGnfrXcloAMPcWA+zdHbMnThHJJ2NfyN8vl5iAmuVluOW6wEU8y4F7hiL78nVBfCPtarmD0vU8HPvfvyPc+w+x7jyX0vc9a7nsPVvQdy6BT8U522xKQoWcZcCc6uWFLniOUS8K+lgnL5eZgJrkpsRw32IhnGHCXOqIv/yDUF8K+lpT8M33vc4HP/Qfyvc8z+97jCH3vC5b73jGKvuMYdKqz5bYEZOgFBtzljtiSFwnlkrCvZbnlcjOGSW66WI4bbMTzDLi7OqIvLxHqC2Ffy66MvvfFwOe+hHzvy8y+93hC3/uK5b73EEXf8Qw61d1yWwIy9AoD7h6O2JJXCeWSsK9lD8vl5hAmueltOW6wES8z4O7jiL78k1BfCPta9mH0va8GPvefyPe+xux7TyD0va9b7nsPVfSdwKBTa1huS0CGXmfAvaYjtuQNQrkk7Gu5puVycyiT3KxjOW6wEa8x4O7riL78i1BfCPta9mX0vW8EPvdfyPe+yex7TyT0vW/F7fa9YxV9gJdap9a13JaADL3FgLu/I7bkbUK5JOxr2d9yuRnLJDcDLMcNNuJNBtwDHdGXfxPqC2Ffy4GMvhdsBPjcf8czvveduMhKcWI+z4/TtfWu5b53nKJvPoNObWS5LQEZepcB98aO2JL3COWSsK/lxpbLzTgmudnMctxgI95hwD3IEX15n1BfCPtaDmL0ve8FPvd95Hs/YPa9JxH63g8t972HKfpOYtCpGsttCcjQhwy4BztiSz4ilEvCvpaDLZebw5jkZpjluMFGfMCAe7gj+vIxob4Q9rUczuh7Pwp87sfI937C7HtPJvS9yyz3vXWKvpMZdGqE5bYEZGgZA+4tHLEl/yGUS8K+lltYLjd1THKzteW4wUZ8woB7G0f05b+E+kLY13IbRt/7n8Dn/hf53k+Zfe8phL73M8t973hF3ykMOrWd5bYEZOgzBtwjHbElnxPKJWFfy5GWy814JrnZ0XLcYCM+ZcC9kyP68gWhvhD2tdyJ0fd+HvjcL5Dv/ZLZ955K6Hu/stz31iv6TmXQqV0ttyUgQ18x4N7NEVvyNaFcEva13M1yualnkps9LccNNuJLBtx7OaIv3xDqC2Ffy70Yfe/Xgc/9Bvneb5l972mEvvc7y33vBEXfaQw6tY/ltgRk6DsG3KMdsSXfE8olYV/L0ZbLzQQmudnfctxgI75lwH2AI/ryA6G+EPa1PIDR934f+NwfkO/9kdn3nk7oe3+y3Pc2KPpOZ9Cpgy23JSBDPzHgHuOILfmZUC4J+1qOsVxuGpjkZqzluMFG/MiAe5wj+vILob4Q9rUcx+h7fw587i/I9/7K7HvPIPS9v1nueycq+s5g0KnxltsSkKHfGHDXO2JL/kcol4R9Lestl5uJTHIz0XLcYCN+ZcA9yRF9+T9CfSHsazmJ0ff+L/C5/4d873Jm37uA0PeusNz3TlL0LWDQqSMstyUgQysYcE9xxJZAg1S8JOxrOcVyuZnEJDfTLMcNNmI5A+7pjuhLjFBfCPtaTmf0vcBE8LmxRMb3xhMiK1H73jMJfW8iYbfvPVxhPZNBp2ZYbktAhqBvqHHPdMSWFBHKJWFfy5mWyw3oC4fczLEcN9iIOAPuuY7oSzGhvhD2tZzL6HuLAp9bjHxvCbPvPYvQ95Za7nsnK6xnMfjeYy23JSBDpQy25DhHbEkZoVwS9rU8znK5AX3hkJsTLccNNqKEAfd8R/SlE6G+EPa1nM/oe8sCn9sJ+d7ObfjeZH5Jdifss84Jet5o+P1EmifrBr/9RYZH5YGeYF4OCP4vR7ysQOXa025lK+1Wona7hJRbLyjXJShXpHLXiPevauX+Vej+3Vq5fzd0/+4h5dYPynUPygFdPQLiqG3ajvEMD3C7eb+jbrkt3yme5ik17lMdseU9CW05YV9LSv4lkNzgRC1L69K1lSxGdPYKOr138Nsn+F0t+F1d/dYGZctQvRQVPUOSw0qgkaJsvulULtD8cFCmVOXO6P9YcD2O6wTXEuhaoiirmcZrRcFJMbpWHFwrCa5VoXsUI14UU/NCcaMc0ayTyZMUOsb0FNHTI4HPPYK2JjXM2nP21KmTJ05umLFbwzGj6ibPiCESNdlFBtkxkQ3B/B9SPOQaE4tlDNGg2y4KYWcJ/b2T0G4pfbtDtHsXAd0pRH8p4rsu0zv47SoyQwPMjwRqC1KFwRv9y4BFQrudmHjU2eCRpr8T4pEus7bBI33d5FEp4pHmTWfEIwYsNdBuOROPKgweafrLEY90mfUMHunrJo86IR51RseaRwxYBkO7lUw86mLwSNNfiXiky2xs8EhfN3lUjviiedMF/aePsZvT98Puqyviq75WFRxjt9kN3U9fi4fcN2Fga3SbCJO+pmmoQte0/dD3AjloNlxKBb/J/BLLvO1AkXl+xO3mHW9t+bPLVkoSejLgXuDIs8sahM8uhH0tFzDMQ2nerRHMBawe/K6G5hrWZJ6Pqibsu7UI+y4WYIU2qwNehT3vCVp+1IQNntdWN18nOGZ6FqvJ5VmsB6KJ/BlkSHpAyPEgwDSATYYNxvV98CBaD4piglZey1C7MXSfMtR1+rg7KqvLaX7ovsYDXO3QO7VSr8ioV4nKlITgTwla/KUGPeYgvxhdw8/2MUSbNnfLBa28MTxUSjwgEyIbC+aDCOkDDr2CQaYezM6cNX1G3aSGfRrqJmCTFjZHoH9jITDi6Bo+ToRcEyJ77Imne0w1xCatBF0zn+3Yx60mYN123t+vTdD6JLyGAOegH+sE44Q+KvdNpJlndkgYtmR+SQ6iayvJSWdfwvWxEkRndSCl/YLfdYPf/sHvesH4fYOg/PrqfIDKA1XeQOUNVd5I5Y1V3kTlTVXeTOVBKsPEtlS5RuXBKg9ReajKw1QeDnPCKm+u8giVt1B5S5W3UnlrlbcBvCpvq/J2Ko9UeXuVd1B5R5V3UnlnlXdReVeVd1N5d8gB43nGNjUT8djGlM84+k//VovwMQ82EDE0DlpDZP6Ph8xJJ0LmpItC5qSLQ+akS4w5aRb/OSQ5HNrtTN1usqYW2q0gbzc91tITE3qspe+DJ+H0hAb1WKsStYsnd/BEkD5eHZU1J4HwGEv/ah/apZV6nYx6lSJ78sbEnxK0+M0JP3Piqhgdw1hL68WmiDb6MXjNBDwhJRD/hEGvTqWIHo4xGsjiakFbah1l1OzxUyfXb183q27fGQ0NB0yeNa1h5kw8CNK0b2rQbg6Q9P9RB0hck/cxxD/ddkkIj8vo753keaaomRC2cKDpD1s4GBD8trRwYC6kVCDeMC8cSJ7J9jSPoiwcbGrwqKIFHq2EhYManoWDNI+iLBwMMXjUpQUetbZwwLQI0ri40pWJR1UGjyoRHzSPdJktDB7p6yaPKhGPsD+CFEdtYz8ZR2X0/8uD62YbUJ6HJ8kh0G438nbTvNbzP5rXmn59vyJUZgfEC1xX01WM/odUgfijy5ah45Sgs2ut+R18b3o+JmvKRTYvhGh9rNEN0dOTnJ6aWry41x56eiJ6epDTk/Y59DjT/r5X0BbhPF3jM0Vvg1fdDF5VojK9EP96M/Avhu6r29bn+n6eZk+zp9nT7Gn2NHuaPc2eZk+zp9nT7Gn2NHuaPc2eZk+zp9nT7Gn2NHuaPc0pT7On2dOcE81Aj17v1bSWo3LdLaFRX+uBaCxCtEGCNftf0DWGmI7aGOKTjjMwXyAtQmV6xDK0/V9wrQL93x3hqTSuMcUEZcV66rbxC7GaRo2nEtHDFe/Q1aCnawh/9HFpCM/wy8AYg76mY6/wC71alnCMqZYzrAtaT/ELwvEQ+lp7ubgc/ZrxYPgFDyzfGmdPdE3Lei/UhsvyxEDP0DB6zH6IiQz/S40yOH5Nl1k70OOugivmMx3DpPvfjBfD77vpMv0QTbiupissXkzjwe85MmCpxXbdtJMYiy4z0OBvTwaaeLCm5V/rY7HItl8Yqy6zCfIJmwXHWF+7oba2Cvlfp5hxnkLHPdH9+9Bjbowr0jHgun/7hNwbvydAdG+J761jyPV99PUidLxlLFNWl9P80LzWtIOO6HEHpt2sV2nUq0RleofgTwla/H0MevoYNIPsSCRnWo644uLCxr7Yjmoe6TL4PV6GOMbQMYWmQ9+vNR+Ax3K6zA7IRuFxM/Z1uiz2ub2Y8JnvKuvzXogu096HbXiCx82mTSElGAZN6yWyDRUk6g0vCF9SlP0SdHTtQfjyZEdt1kdJM6Z3z0RmgFISQr8pG/i4DJWjfKndvK9JS1UInWwKgxunahM6c88Efbt7ESoJF+69EuR91KiECdE8UdNP+dY1J539mOik7beaLEM0StE8PzguM+5Fcr8hySH4bW1TXsApNr1hncPb2tijx9Eb3Hh2IWG8wV2FrsUQdm2Iq6mwy2QSz2Q00SkyT+L6nvptpE5G2VRAG/2b3OndRnCfY34IdD+dME8rEBbNP4Y3k5N4JKuftLoY9MC9qxD9RPfOGkXrJy3zLbIidNxXZFIV+h/PxOnUDfGvKuR//DZ6hVEHz8IKkZERIbLfWu9mtCVQW2F0cT6NmG88djEwwWCoI2bqzDd48cyp/sVvuUKCPsIyCEnra4VRNiXYdEFGnQXB/av5jAeRDLPZybBZvO4GPXiGi1pfe6B28Sycvo5nEIeJTOqJ/te8wk/Q+qkyjsri/7H96WbUwTNkQmTPDuCn6F5GW0Jkv71p0sX5dG2+EdrdwAT6uiGig+Ft2VbtBuZBFcO98farOrWma1Uh9BDKdrIS0YPvxbEiFfWtUyzD3VqhsZqOxiReSdLtw/n2iF789nk1Ko83B9JldkNt7BQc4zfM8eqX+YY5Hqvq//TKlG6/Wwg/qG1fCWoX6zAei+gyoxDeeYg28jFwQBvWiWqR6QNMM17hrBbNt33Db7DvJzL8jhk8rUb3K0bXexjtF4fwR5c5CLUfR9exvoWt8uB7QMKRA9T9jW0xpqU3wqPLjBPZ/OrVAt2dQuqOb6Gu5oMee+o2KhAt2Ad2b+GeeFWyysDUPQSTLnO4QVdVC+1XhNSd0kJdjakyBJOpT1imgF48rgmbAafuf0wH7pceIXhnIDrnhtBf0gL92O/gVdMeDJiw/+gRQm9H2yrdtjlRG2arwmyJLnNC8At8DNte3fRbWQep4DfficW9GLZSHpVoPjCIM9Kdb1t7E/Kgo1YgKCcV44jOfYInwdGJjDFkmgAcnMtW1DjMqT2fBaoKKVeWaZJ0Ug9vt0vWrpqYxaFQun3A0jmbPU2TD2VG2ZTg224MT2Tq1NpDgaYNT6jgfmHYyiqJHxhbCiHCD6vUDhlv74gnD/V1vCWY3v5diOzJRM0rPFEVtr0V/r8C3bfcqBM2uMHbeevfKqMtIbInwky6uB68Y6LlcDrsMPEDFcfkeGshBpgHDFuhNuoa7l9I7Znow/RQbqNUKcK37GPQYYntRXuwYxkuD6HRhonYLiH0UK7cVyJ68L0Y9DOJF+GwPkp0X/qt6GUSL4Ro255A94eEFzW2RP8NDY5xCCiW59YWAfCiV5lRF49dcF08ya7bwFs66voxkf1wkRLNv9eGZYbaX+Fv5WFasL/SZbYLfvUDc1ELdJeF1N2hhbpCZPsj3Qb+Rh1ehMH0QlpulMU62bWVeuZxhVEH27viEJrwghn9xHe2rOu2EwaNmI+lRhk84aHL7IPqh/Uf1i3dvjkZo+tg+dBl9jfar2qh/bKQuge1UFeIbPnAW2prWvDYyFyMW26UxfLRWj3z2Hxgx76mKIQmPOasQrSkguNkPkmmg0Pw80FRCH3m9+Tws1BK0NoRrEvQbtj3QzWPTVkNs92Tg189YWKWxf4mRv3ADZMEozowWirqfdqY5Gj1GyTJ/JLcx4kIJ5kV4bSvj3Bqwu4jnHyEE+aPj3BKp2R+yUc4EdHvI5xa54+PcEqnZH7JRzj5CCcf4SR8hFOKkDYf4eQjnHyEE59O+Qgner7qtjs0wsmVCTsd5bRvovn7rlS0A917J+ijvfYjnqjjmEjcjwH3/gn6/oc2T2Lq/9FMfDiAgQ8HID7olGCQi3a2Jdv4PzmaMHLwQMv1qR+THC3sxIubws4dyID7bGLcOsWJ+52wfyQXZur9TShtxL6ENuKgCDaiPYt41DYCdOUgBl05mMHXHNwOX5Mv3ZT+gVKOxkTgZ1v34pKjMQxydAiDHB0SyFFHRetTblUSR3QeGgj/WB+tHy35aP2m1NoEt4/W99H6ufLRR+v7aP32YvfR+j5aX9/PR+u3n6E4+rpY+Gh9XMdH6/tofR+t3z5qsN3QbXdotL4wDlJEwCgXvFaFSP1DHYzUH+cj9Zuw+0h9H6mP+YPv7SP18+Ojj9T3kfo+Uj+dUsJH6reXDh+pn04+Uj87+Uj97D7zkfrZ7ftIfR+p7yP1faR+PnzVbeMFCI25w/ciTeaXSCfrdKTPOMYofaD3UIaIp8MY+HAYY7Q68GEsAx/qGPhQ1wHR6hEmWduMRB1LGEE43vJo9b5M0ernORCtPp4B9/mORKsT9o8835FodUobMY7QRtQ7EK1ez6ArExh8zYQOiFan9A+UctTgQLR6A4McTWSQo4koWj1sAZqaN1zbufnFbCEmKZqvD44LeTG70qBJ84M+6jApW5sYDos6S1hGT5Fl9MQsoKdciNC3UHBElb6mJ0US6JoZ8IDlH9/DjOTE8l+KfmXI/eIh9ysJKdcR/MT3Sonmb6hUIDpKLKGnyDJ6EpbREzfowf8Xo/8TqC0czQznpUY9rEP47R9TNzoJH5AkEF9xSqFjH5DUekCSXsgUwgckmXxsT0DSCESHD0hqTr8PSGqdP1EDksaKTPIBSdl8bE9A0t6IDh+Q1JweQtn2AUlGaikgaSqiN0pA0kzUxvTgeFUOSJqH8C5FtLkSkIQX+TkCkk5G7ceF+wFJC0Q2v6IEJC1soa7mw8oKSLrAoCtKQNLiFupqTKtaQNLliM4lIfTbHJC0BB0vRTS4EpB0bfDbWkAS9ltZBykiYBwBSZMSzQcGnNslUi5U59vWog5anG+japsL6pMIMR9OJ0MS8y9furj05XCGRdXJDHo4uQMCwSi3kqNc6L/IkSAZSj08glAPL2IOKEvmlxr18AgGPZzCoIdTQvQwTkz3KEI5mkooR65vP3hkoPDT/PaD0ZLffrAptTZJ5rcf9NsP5spHv/2g336wvdj99oN++0G//WB0hsaE335QoPvhOn77wfDFCb/9YKYdv/1gmhpsN3TbHbr9IPUDN3y7a2oiGxBBu6vEFoRHOvjWxnS/BWETdh/x6yN+MX+iRvz6LQhb5qPfgtBH/PotCNMpJfwWhO2lw0f8ppOP+M1OfgvC7D6LGvE7CuH1WxBm2vdbEDavO76FupoPfgtCvwUhBSa/BaFDE3Y6ymk64zaEmnbqaK+jLN8uDiYSj2LAfTRDlNvRjNsvTmPiwwwGPszogKjbCBPMbUaCTyOMHJzpwPaLHHJ0ieXbLwLmmQy4L3Vk+0XC/pGXOhJZTmkjphPaiFmWb78IujKLQVdmM/ia2R2w/SKlf6CUozmWb78IcjSHQY7mMsjRXLT9Ykw0T9S86ccUrT8vEP5jfLR+tOSj9ZtSaxPcPlrfR+vnykcfre+j9duL3Ufr+2h9H60fnaE4+tpH62fX8dH6PlrfR+u3jxpsN3TbHRqtL4yDFBEwygWvVSFSf56DkfrH+kj9Juw+Ut9H6mP+4Hv7SP38+Ogj9X2kvo/UT6eU8JH67aXDR+qnk4/Uz04+Uj+7z3ykfnb7PlLfR+r7SH0fqZ8PX3XbHRqpL4yDFBGwoxgifY5ljNIHeucxRDwdx8CH4xij1YEPxzDw4XgGPhzfAdHqESZZ24xEPYYwgvAEy6PV+zFFq1/uQLT6CQy4r3AkWp2wf+QVjkSrU9qIYwltxIkORKufyKAr8xl8zfwOiFan9A+UcnSSA9HqJzHI0ckMcnQyilYPW4Cm5g3Xdm5+MVuIUxTN1wfHhbyYXWnQpPlBH3XYvo/PY3oSltFTZBk9MQvoKRci9C0UHFGlr+lJkQS6ZgY8YPnH9zAjObH8l6JfGXK/eMj9SkLKdQQ/2/Px+ZhB48qmp8gyehKW0RM36MH/F6P/E6gtHM0M56VGPaxD+O0fUzc6CR+QJBBfcUqhYx+Q1HpAkl7IFMIHJJl8bE9A0ghEhw9Iak6/D0hqnT9RA5LGikzyAUnZfGxPQNLeiA4fkNScHkLZ9gFJRmopIGkqojdKQNJM1Mb04HhVDkiah/AuRbS5EpCEF/k5ApJORu3HhfsBSQtENr+iBCQtbKGu5sPKCki6wKArSkDS4hbqakyrWkDS5YjOJSH02xyQtAQdL0U0uBKQdG3w21pAEvZbWQcpImAcAUmnJJoPDDi3S6RcqM63rSs7aHG+japtLqifQoj5VDoZkph/+dLFpS+nMiyqnsagh6d1QCAY5VZylAv9Sx0JkqHUw9MJ9XApc0BZMr/UqIenM+jhGQx6eEYH6GFfQjnqT9jWAuLdCcxxBYdsLSCWAZ3OTDQfNArR8lgJH5ehcpRbMpn3NWmpCqGzWR+kCInh6MwzE/TtnpWwe6ACuM9KkPdRsqMitPo7EqHV14kIrZosQ7TQbzfShN2v7vvVfcyfqKv7fruRlvnotxvxq/t+u5F0Sgm/3Uh76fCr++nkV/ezk99uJLvPoq7uj0J4/XYjmfb9diPN645voa7mg99uxG83QoHJbzfSyup+vhOLZyVomQRGcWHI6n6cke582zqbkAcdtQJBOakYR3SeEzwJnus/phQt+Y8pNaXWHgr8x5T8x5Ry5aP/mJL/mFJ7sfuPKfmPKfmPKUVnaEz4jykJdD9cx39MKXwyRtfxH1PyH1PS1GC7odvu0I8pUT9wwyTBwg6Mlop6n5X5QaVzHNyD6jwf4dSE3Uc4+QgnzB8f4ZROyfySj3Aiot9HOLXOHx/hlE7J/JKPcPIRTj7CSfgIpxQhbT7CyUc4+QgnPp3yEU70fNVtd2iEkysTdjrK6TzGjyoB3WczvLt+vuUfv4GJxPMZcF/A8M7+BYwfkzqXiQ8XMvDhwg7YuyDCBHOb+9qcSxg5uMhyferLJEdXWf4xKcC8iAH31Y58TIqwf+TVjuyTQ2kjziO0EYst/5gU6MpiBl25iMHXXNQBH5Oi9A+UcnSx5R+TAjm6mEGOLmGQo0vQx6Rionmi5g3lViVxROelgfD/zkfrR0s+Wr8ptTbB7aP1fbR+rnz00fo+Wr+92H20vo/W99H60RmKo699tH52HR+t76P1fbR++6jBdkO33aHR+sI4SBEBo1zwWhUi9S91MFL/Mh+p34TdR+r7SH3MH3xvH6mfHx99pL6P1PeR+umUEj5Sv710+Ej9dPKR+tnJR+pn95mP1M9u30fq+0h9H6nvI/Xz4atu24q9SJP5JdLJOh3pcxljlD7QeylDxNPlDHy4nDFaHfjwOwY+XMHAhys6IFo9wiRrm5GovyOMIPy95dHq/Zmi1a9zIFr99wy4r3ckWp2wf+T1jkSrU9qIywhtxB8ciFb/A4OuXMnga67sgGh1Sv9AKUdLHIhWX8IgR0sZ5GgpilYPW4Cm5g3Xdm5+MVuIPyqarw+OC3kxu9KgSfODPuow/cCMUwodh0WdJSyjp8gyemIW0FMuROhbKDiiSl/TkyIJdM0MeMDyj+9hRnJi+S9FvzLkfvGQ+5WElOsIfuJ7pUTzN1QqEB0lltBTZBk9CcvoiRv04P+L0f8J1BaOZobzUqMe1iH89o+pG52ED0gSiK84pdCxD0hqPSBJL2QK4QOSTD62JyBpBKLDByQ1p98HJLXOn6gBSWNFJvmApGw+ticgaW9Ehw9Iak4PoWz7gCQjtRSQNBXRGyUgaSZqY3pwvCoHJM1DeJci2lwJSMKL/BwBSSej9uPC/YCkBSKbX1ECkha2UFfzYWUFJF1g0BUlIGlxC3U1plUtIOlyROeSEPptDkhago6XIhpcCUi6NvhtLSAJ+62sgxQRMI6ApD8mmg8MOLdLpFyozretGztocb6Nqm0uqP+REPNVdDIkMf/ypYtLX67i2HaRQQ+v7oBAMMqt5CgX+v/sSJAMpR5eQ6iHf2YOKEvmlxr18BoGPbyWQQ+vDdHDODHdCwnl6DpCOXJ9+8HrA4W/wW8/GC357QebUmuTZH77Qb/9YK589NsP+u0H24vdbz/otx/02w9GZ2hM+O0HBbofruO3HwxfnPDbD2ba8dsPpqnBdkO33aHbD1I/cMO3u65LZAMiaHeV2ILwegff2viT34KwCbuP+PURv5g/USN+/RaELfPRb0HoI379FoTplBJ+C8L20uEjftPJR/xmJ78FYXafRY34HYXw+i0IM+37LQib1x3fQl3NB78Fod+CkAKT34LQoQk7HeX0J8ZtCDXt1NFeN1q+XRxMJN7IgPsmhii3mxi3X7yBiQ9/ZuDDnzsg6jbCBHObkeA3EEYO/sWB7Rc55Ohmy7dfBMx/YcB9iyPbLxL2j7zFkchyShvxJ0IbcbPl2y+CrtzMoSsMvuaWDth+kdI/UMrRrZZvvwhydCuDHP2VQY7+irZfjInmiZo3fZmi9W8LhP92H60fLflo/abU2gS3j9b30fq58tFH6/to/fZi99H6PlrfR+tHZyiOvvbR+tl1fLS+j9b30frtowbbDd12h0brC+MgRQSMcsFrVYjUv83BSP07fKR+E3Yfqe8j9TF/8L19pH5+fPSR+j5S30fqp1NK+Ej99tLhI/XTyUfqZycfqZ/dZz5SP7t9H6nvI/V9pL6P1M+Hr7rtDo3UF8ZBigjYjQyRPncwRukDvbcxRDzdycCHOxmj1YEPtzPw4S4GPtzVAdHqESZZ24xEvZ0wgvBuy6PV+zJFq9/mQLT63Qy4b3ckWp2wf+TtjkSrU9qIOwhtxD0ORKvfw6Ar9zL4mns7IFqd0j9QytF9DkSr38cgR/czyNH9KFo9bAGamjdc27n5xWwhHlA0Xx8cF/JidqVBk+YHfdRh+z4+j+lJWEZPkWX0xCygp1yI0LdQcESVvqYnRRLomhnwgOUf38OM5MTyX4p+Zcj94iH3Kwkp1xH8bM/H52MGjSubniLL6ElYRk/coAf/X4z+T6C2cDQznJca9bAO4bd/TN3oJHxAkkB8xSmFjn1AUusBSXohUwgfkGTysT0BSSMQHT4gqTn9PiCpdf5EDUgaKzLJByRl87E9AUl7Izp8QFJzeghl2wckGamlgKSpiN4oAUkzURvTg+NVOSBpHsK7FNHmSkASXuTnCEg6GbUfF+4HJC0Q2fyKEpC0sIW6mg8rKyDpAoOuKAFJi1uoqzGtagFJlyM6l4TQb3NA0hJ0vBTR4EpA0rXBb2sBSdhvZR2kiIBxBCQ9kGg+MODcLpFyoTrvgJ4OWpxvo2qbC+oPEGL+G50MScy/fOni0pe/MSyqPsighw92QCAY5VZylAv99zgSJEOphw8R6uE9zAFlyfxSox4+xKCHDzPo4cMdvBXfesQYdHok0XzQI0TLvh4fl6FylFsKmfc1aakKobNZH6QIieHozEcS9O0+mrDb0QLuRxPkfZTsKCXsz6SEj3klbJsYjs58jEEJH7dcCQH34wxKyEHr2Uyh9U9Y/krBo0EfUeN+0nLceyv6jmLA/RQzbgp5hL6hfpIjlHP5JKFde9pyOQR5eZpBDv9uOe61FX1/Z/INOsUZeZpvW88keMcs+dIHr5o9wyCX91k+M9CPCff9jrxqRtg/8n7LXytcm6mvH7Rcxtdlwv2QIzJO2D+SEnNHTS70Y5pceNZPLrRNDEdnPsswufCc5ZMLgPs5h2f41mVSwn94JWybGI7O/AeDEj5vuRIC7ucdmeF7LqCVetTzguVP2jC79wID7heJDRjeuh2MOxigdYPf9YLf/sEvpJcCuaPGBTOiLzLw62XCJ349ItaJWmaqCft2g6CdV1Sbr6r8T5VfU/l1ld9Q+V8qv6nyWyq/rfK/VX5H5XdVfk/l91X+QOUPVf5I5Y9V/kTlZSr/R+X/qvypyp+p/LnKX6j8pcpfqfy1yt+o/K3K36n8vco/qPyjyj+p/LPKv6j8ayL9lKHX3F9JZAIg4fxV4/yfxvlrxvnrxvkbxvm/jPM3jfO3jPO3jfN/G+fvGOfvGufvGefvG+cfGOcfGucfGecfG+efGOfLjPP/GOf/Nc4/Nc4/M84/N86/MM6/NM6/Ms6/Ns6/Mc6/Nc6/M86/N85/MM5/NM5/Ms5/Ns5/Mc5/TbQ8QEsFv8n8UpZO52vLXiFs61HLY60aJqbTqwmytib8k5B/j7nBv81fo+OffJ2Qf487wb8G+QYZ/+rlvwj594QT/KuVb5LxLynfIuTfky7wryEp36biX31S/puQf0+5wL/apHyHin/Kl79LyL+nHeBfg8L8HhH/6lVb7xPy7+8O8K9WYf6AiH+KTPkhIf+esZ9/DYD5Ixr+1UNbHxPy71n7+VcLmD+h4R+QKZcR8u856/nX0Ij5PyT8q29s67+E/PuH9fyrbcT8KQn/GsmUnxHy73nb+deQxvw5Bf/q0219Qci/F2znX20a85cU/EuTKb8i5N+LlvNvQoD5awLM44O2viHk30uW8294gPnb/DHX6I2rvyPk38t2809qzN/njbl2om7rB8q5WKv5VzteY/4xf/41bZz+EyH/XrWaf8ObMP+cN+ahTW39Qsi/f1rNP9mE+dcE3VrKo4T7DLxmx54PbSVJuM4gHyfk3+uO8I9wnlw+Sci/NxzhH+E8r3yakH//coR/hPOU8hlC/r3pCP8I59nkc4T8e8sR/hHOE8nnCfn3tiP8I5znkC8S8u/fjvCP8DldvkzIv3cc4R/hc6Z8lZB/7zrCP8LnJPkaIf/ec4R/hON8+QYh/953hH+E41T5JiH/PnCEf4TjLPk2If8+dIR/hOME+Q4h/z5yhH+Efk6+R8i/jx3hH6Gdlh8Q8u8TR/hHaGfkR4T8W+YI/wj1RBLKjOTiX9zgn03vHPxGuBYAbVC/fwXvtr2coH8H7X8J2r6mxr1+IvPuFSXuLp3txg3y+D8G3F07d4xtzJfO/yPUR8K+ll0tlxvQl98Y5Ka75bhfYdKXHo7oy3JCfSHsa0nJP/1OuB5HgI2Ad7+XJzLvgK9IiKxEPeZ4lXDMAS+3U/GZQ6cGJDLvOVPysLfltqRRhorocfdxxJbECOWSsK9lH8vlZgCT3KxhOW6wESsY7MSajuhLnFBfCPtarsnoe8FGNH6ctijjexNFIitR+17Kd+SLLPe9AxOZPUUoebiO5bYEZKiIwYb2dcSWFBPKJWFfy76Wyw3oC4fcrGs5brARCQbc/R3RlxJCfSHsa9mf0fcWBz63BPneUmbf+xqh7y2z3PdukMjs30XJwwGW2xKQoTIGWzLQEVvSiVAuCftaDrRcbkBfOORmI8txg40oZcC9sSP60plQXwj7Wm7M6Hs7BT63M/K95cy+l3JvswrLfe+GicxemZQ83MxyWwIyVMFgSwY5YksqCeWSsK/lIMvlBvSFQ25qLMcNNqKcAfdgR/SlC6G+EPa1HMzoeysDn9sF+d6uzL73DULfW2W5790okdmXmpKHwyy3JSBDVQy2ZLgjtqQboVwS9rUcbrncgL5wyM0Iy3GDjejKgHsLR/SlO6G+EPa13ILR93YLfG535Ht7MPteyj2pe1ruezdOZL4BQcnDrS23JSBDPRlsyTaO2JJehHJJ2NdyG8vlBvSFQ262sxw32IgeDLhHOqIvvQn1hbCv5UhG39sr8Lm9ke/tw+x73yT0vatZ7ns3SWS+t0TJwx0ttyUgQ6sx2JKdHLElqxPKJWFfy50slxvQFw652dVy3GAj+jDg3s0RfVmDUF8I+1ruxuh7Vw987hrI967J7HspvyW0luW+d9NE5tuGlDzc03JbAjK0FoMt2csRW7I2oVwS9rXcy3K5AX3hkJt9LMcNNmJNBtyjHdGXdQj1hbCv5WhG37t24HPXQb63L7PvfZvQ91Zb7ns3S2S+I0zJw/0ttyUgQ9UMtuQAR2xJP0K5JOxreYDlcgP6wiE3B1uOG2xEXwbcYxzRl3UJ9YWwr+UYRt/bL/C56yLf25/Z91J+A3Y9y33vIIX13wy+d6zltgRkaD0GWzLOEVuyPqFcEva1HGe53IC+cMjNeMtxg43oz4C73hF9GUCoL4R9LesZfe/6gc8dgHzvQGbf+w6h793Act+bVFjfYfC9E23fI0H1ywYMtmSSI7ZkQ0K5JOxrOclyuQF94ZCbIyzHDTZiIAPuKY7oy0aE+kLY13IKo+/dMPC5GyHfuzGz732X0PduYrnvlQrruwy+d5rt8aqqXzZhsCXTHbElmxLKJWFfy+mWyw3oC4fczLAcN9iIjRlwz3REXzYj1BfCvpYzGX3vpoHP3Qz53kHMvvc9Qt+btNz31iis7zH43jm2zx2qfkky2JK5jtgSSSiXhH0t51ouN6AvHHJzrOW4wUYMYsB9nCP6UkOoL4R9LY9j9L0y8Lk1yPcOZva97xP63iGW+97BCuv7DL73RMttCcjQEAZbMt8RWzKUUC4J+1rOt11uEjxyc4rluMFGDGbAfaoj+jKMUF8I+1qeyuh7hwY+dxjyvcOZfe8HhL631nLfO0Rh/YDB955huS0BGaplsCULHLElmxPKJWFfywWWyw3oC4fcLLQcN9iI4Qy4z3ZEX0YQ6gthX8uzGX3v5oHPHYF87xbMvvdDQt+7peW+d6jC+iGD7z3PclsCMrQlgy053xFbshWhXBL2tTzfcrkBfeGQm0WW4wYbsQUD7sWO6MvWhPpC2NdyMaPv3SrwuVsj37sNs+/9iND3piz3vcMU1o8YfO8lltsSkKEUgy251BFbsi2hXBL2tbzUcrkBfeGQm8stxw02YhsG3Fc4oi/bEeoLYV/LKxh977aBz90O+d6RzL73Y0Lfu73lvne4wvoxg++90nJbAjK0PYMtWeKILdmBUC4J+1ousX2tIsEjN1dZjhtsxEgG3Fc7oi87EuoLYV/Lqxl97w6Bz90R+d6dmH3vJ4S+d2fLfW+twvoJg++9znJbAjK0M4Mtud4RW7ILoVwS9rW83nK5AX3hkJsbLccNNmInBtw3OaIvuxLqC2Ffy5sYfe8ugc/dFfne3Zh97zJC37u75b53c4V1GYPvvdlyWwIytDuDLbnFEVuyB6FcEva1vMVyuQF94ZCb2yzHDTZiNwbctzuiL3sS6gthX8vbGX3vHoHP3RP53r2Yfe9/CH3vKMt97wiF9T8Mvvcuy20JyNAoBltytyO2ZG9CuSTsa3m35XID+sIhN/dZjhtsxF4MuO93RF/2IdQXwr6W9zP63r0Dn7sP8r2jmX3vfwl9776W+94tFNb/MvjeBy23JSBD+zLYkoccsSX7EcolYV/LhyyXG9AXDrl51HLcYCNGM+B+zBF92Z9QXwj7Wj7G6Hv3C3zu/sj3HsDsez8l9L0HWu57t1RYP2XwvU9abktAhg5ksCVPOWJLDiKUS8K+lk9ZLjegLxxy84zluMFGHMCA+1lH9OVgQn0h7Gv5LKPvPSjwuQcj3zuG2fd+Ruh7D7Hc926lsH7G4Huft9yWgAwdwmBLXnDElhxKKJeEfS1fsFxuQF845OZly3GDjRjDgPsVR/RlLKG+EPa1fIXR9x4a+NyxyPeOY/a9nxP63sMs971bK6yfM/je1yy3JSBDhzHYktcdsSV1hHJJ2NfydcvlBvSFQ27etBw32IhxDLjfckRfxhPqC2Ffy7cYfW9d4HPHI99bz+x7vyD0vRMs973bKKxfMPjedyy3JSBDExhsybuO2JIGQrkk7Gv5ruVyA/rCITcfWI4bbEQ9A+4PHdGXiYT6QtjX8kNG39sQ+NyJyPdOYva9XxL63sMt970phfVLBt/7ieW2BGTocAZbsswRWzKZUC4J+1ous1xuQF845OZTy3GDjZjEgPszR/TlCEJ9Iexr+Rmj750c+NwjkO+dwux7vyL0vVMt973bKqxfMfjeLy23JSBDUxlsyVeO2JIjCeWSsK/lV5bLDegLh9x8azlusBFTGHB/54i+TCPUF8K+lt8x+t4jA587Dfne6cy+92tC33uU5b53O4X1awbf+6PltgRk6CgGW/KTI7bkaEK5JOxr+ZPlcgP6wiE3v1qOG2zEdAbcvzmiLzMI9YWwr+VvjL736MDnzkC+dyaz7/2G0PfOstz3jlRYv2HwvcsttyUgQ7MYbMkKR2zJbEK5JOxrucJyuQF94ZCbeLnduMFGzGTAnSh3Q1/mEOoLYV9LSv6Zvnd24HPnIN87l9n3fkvoe+dZ7nu3V1i/ZfC9JZbbEpCheQy2pNQRW3IMoVwS9rUstVxuQF845Kaz5bjBRsxlwF3uiL4cS6gvhH0tyxl97zGBzz0W+d7jmH3vd4S+93jLfe8OCut3DL63i+W2BGToeAZb0tURW3ICoVwS9rXsarncgL5wyE13y3GDjTiOAXcPR/TlREJ9Iexr2YPR954Q+NwTke+dz+x7vyf0vSdZ7nt3VFi/Z/C9vS23JSBDJzHYkj6O2JKTCeWSsK9lH8vlBvSFQ27WsBw32Ij5DLjXdERfTiHUF8K+lmsy+t6TA597CvK9pzL73h8Ife9plvvenRTWHxh87zqW2xKQodMYbElfR2zJ6YRySdjXsq/lcgP6wiE361qOG2zEqQy4+zuiL2cQ6gthX8v+jL739MDnnoF87wJm3/sjoe8903Lfu7PC+iOD7x1guS0BGTqTwZYMdMSWnEUol4R9LQdaLjegLxxys5HluMFGLGDAvbEj+rKQUF8I+1puzOh7zwp87kLke89m9r0/Efrecyz3vbsorD8x+N7NLLclIEPnMNiSQY7YknMJ5ZKwr+Ugy+UG9IVDbmosxw024mwG3IMd0ZfzCPWFsK/lYEbfe27gc89Dvvd8Zt/7M6HvvcBy37urwvozg+8dZrktARm6gMGWDHfEllxIKJeEfS2HWy43oC8ccjPCctxgI85nwL2FI/qyiFBfCPtabsHoey8MfO4i5HsXM/veXwh970WW+97dFNZfGHzv1pbbEpChixhsyTaO2JKLCeWSsK/lNpbLDegLh9xsZzlusBGLGXCPdERfLiHUF8K+liMZfe/Fgc+9BPneS5l976+Evvd3lvve3RXWXxl8746W2xKQod8x2JKdHLEllxHKJWFfy50slxvQFw652dVy3GAjLmXAvZsj+nI5ob4Q9rXcjdH3Xhb43MuR772iDd+bzC/J3oR9dkURPW+qEXbgSb/gd4MC+91E5d8H9gDz5fdFhckPzJc/FKXtj7aV8Kv1RKBrkFLBbzK/JAnbSnLR2E/Q6qNOVyp+VwbHZeh6iup+Q5KDS6CRwPaZfYltJuE9k9Bugrpd2ENFtVEatFUOtBu4qtC1GMJYxEBLDGHUbetzfb/OItO/R9XVT9l2xqTZRzZMmzUTC4EujK+FKWA85D9cJ44YU2y0XY7+1/91Muo3oYCUzC9JEUIYVdt/KKLztFcSelro/RLRPFFbo7UTPCNPKhkYNn7iBDlh6HhOHvyhiIcH1HSulXCDzmJht0zphI2ftqxLlCwsVfmPKl+l8tUqX6PytSpfp/L1Kt+g8p9UvlHlm1QeENTl8boyy+uaNgHsYUx7qeC3OrieCM4TxvWi4LwIeTe4XhycF6Pr2NhrGuCa9k4xdE07iDi6ph1EAl3TGIrQNe2J9b3hfK3gGovXHZIcVoboI2s3mZxQhvAQttv09CUCHqYw3xCvOum+obu3xPfWg4VO6J6N/YmO10RldTnNDy1PmvYKkZGJTq3UKzLqVaIyJSH4U4IWf6lBT6lBM/RBVXAMvyVFGTo1bZ3paZtQLrJtj+afMOjVqTMzr6D91YO2GqYdPbthdsOo2eOnTq7fcfa0+lmTp08bWTd1Kja+mvhKg3hzVKr/x0YQP4bgITSeoSlGx7huaci1sAQMxkzT18qD407omqanM7qWQMe6PNtoOSGaP5sJQe/llzKNmoj4IfUB5sWfA6n4S1Gm01sSJs0zfQ2qrjD+078xVH+FaP3xKtZCO+UhdFSFXGMTHA0WmPSOcY8E8b2W5v/YVRM8dsk/Ez7C/YVJqKkfWykx3xzS1vhk/YShcvywCcNlQ93Q2vr6zQdLWVM3rG7Y+JraiQ3jh8raobWqzfq6mlp1u5q6etmQrBvWgCf8cKI2PjcTT2rrdEtRxluUhNCvUyLkuAyVW06I1byvSUtVCJ2sczEcnXlLEX27txIqCRfuW4vI+yiUVgrDeCvDyueeHbTymcwxaTopZemvhKuoexKvfIKjAvr6BTzsiJHkH+0eSepUg3lxW6C3t/uRZLPUNJIEJv0fAn97UcuelOrefyRQ1IaJ6XQbodLf7sjIkhLzHagtWTu4pmb4YChXOyEph0yor6mtqZkwfkiyPllXX9Ow+RC5+cQhNUMG10+oH6/arJMTkxPr6jefWJumq6NGlncwjSzv9CPLtonh6Mw7GUaWd1k+sgTcdzkysrw9oJW63buJFRkMLbTZuLIiOmZkdJWDI6N7Arm714+MmqWmkdE9xsjo3g4YGV1FODK6h9AA3uvIyIgS830OjozuYxoZ3e9HRm0Tw9GZ9zOMjB6wfGQEuB9wZGR0b0Ardbt/YxgZ/a2DR0ZXOzgyejCQu4f8yKhZahoZPWiMjB7qgJHR1YQjowcJDeBDjoyMKDE/7ODI6GGmkdEjfmTUNjEcnfkIw8joUctHRoD7UUdGRg8FtFK3+xjDyOixYGSkzyGKeKnouJHS9Q7GaT0eyOETfqTUnGEa7ONBnJY+B2ZVG/ekHildTxi39TihQXzCkZESJeYnHYzbepJppPSUHym1TQxHZz7FMFJ62vKREuB+2pGR0hMBrdTtjnIkbotSlv5OGLc1iiFu6+8dHLd1g4NzcM8EevusH1k2S00jy2eCOTicqEeSNxDOuT1DqOTPOjKSpMT8nINzbs8xjST/4UeSbRPD0Zn/YBhJPm/5SBJwP+/ISPLZgFbqdl9gmHN7oYNXI//k4EjoxUDuXvIjoWapaST0orEa+VIHrEb+iXBk9CKhAXzJkZERJeaXHRwZvcw0MnrFj4zaJoajM19hGBm9avnICHC/6sjI6KWAVup2/8kwMvpnB4+MbnRw9fG1QO5e9yOj5gzTYF8zVh9f74DVxxsJVx9fIzSArzsyMqLE/IaDq49vMI2M/uVHRm0Tw9GZ/2IYGb1p+cgIcL/pyMjo9YBW6nb3cWT1kVKW3iJcfdyHYfXxrWD1ESdqB7Y24TdpljA5bWp9/wuBDNUOSdY0KEfcWt/ky0/C3WmlKwOqtQjl8W1C/dY6+XbIoJyaB5Q7aN/kiE521CJxvvwk3IlZvuQIZsIdzeW1jmCOEfbzNR2kg/li/jcBnXp3eaAN7zINbcPD2O3B773B70PBL2zu+k4wroV6zyCM8D/IIPxeF5R/oij7+yjFwe9aQbk/FBX292L8r//1v/7X/2b/bqzyu8jP6PkJ7V/eCfzGu8Fvd5XfC5wY9Zi3WqS/60Xtx9935FmPEvMHjmCOEWL+0BHMcULMHzmCOUGI+WNHMBcRYv7EEczFhJiXOYK5hBDzfxzBvBEh5v86gnkDQsyfFiDmzwoQ8+cFiPkLRzC/T7iu8GUB9vNXBYj56wLE/E0BYv62ADF/V4CYvy9AzD8UIOYfCxDzTwWI+ecCxPxLAWL+tQAx/1aAmP9XgJj/rwAxLy9AzCsKEDMEJhUa5lgBYo4XIOZEAWIuKkDMxQWIuaQAMZcWIOayAsTcqQAxdy5AzOUFiLmiADFXFiDmLgWIuWsBYq4qQMzdChBz9wLE3KMAMfcsQMy9ChBz7wLE3KcAMa9WgJhXL0DMaxQg5jULEPNaBYh57QLEvE4BYu5bgJirCxBzvwLEvG4BYu5fgJjXK0DM6xcg5gEFiHlgAWLeoAAxb1iAmDcqQMwbFyDmTQoQ86YFiHmzAsQ8qAAxJwsQsyxAzDWOYO5NuD/2YEcw9yHEPMQRzKsRYh7qCObVCTEPK0AbNrwAMdcWIObNCxDziALEvEUBYt6yADFvVYCYty5AzNsUIOZUAWLetgAxb1eAmEcWIObtCxDzDgWIeccCxLxTAWLeuQAx71KAmHctQMy7FSDm3QsQ8x4FiHnPAsS8VwFiHlWAmPcuQMz7FCDm0QWIed8CxLxfAWLe3xHMaxKuuR9QgP18oCOYqwkxH1SA/XxwAWIeU4CYDylAzIcWIOaxBYh5XAFiPqwAMdcVIObxBYi5vgAxTyhAzA0FiHliAWKeVICYDy9AzJMLEPMRBYh5SgFinlqAmI8sQMzTChDz9ALEfFQBYj66ADHPKEDMMwsQ86wCxDy7ADHPKUDMcwsQ87wCxHxMAWI+tgAxH1eAmI8vQMwnFCDmEwsQ8/wCxHxSAWI+uQAxn1KAmE8tQMynFSDm0wsQ8xkFiHlBAWI+swAxn1WAmBc6gvm9IjrMZxdgP59TgJjPLUDM5xUg5vMLEPMFBYj5wgLEvKgA36Nb7AjmtwnHJBcVoGxfXICYLylAzJcWIObfFSDmywoQ8+WOYC4lxHyFI5jLCDH/3hHMnQgx/8ERzJ0JMV/pCOZyQsxLHMFcQYh5qSOYKwkx/9ERzF0IMV/lCOauhJivdgRzFSHmaxzB3I0Q87WOYO5OiPk6RzD3IMR8vSOYexJivsERzL0IMf/JlW8tEmK+0ZVvLRJivsmVby0SYv6zK99aJMT8F0cwr0GI+WZX9vckxHyLI5jXIsR8qyOY1ybE/FdHMK9DiPk2RzD3JcR8OyHmmGojEbS1AcIfC3gA/6llZKFuKUpUhnl6mLeGeVyY14R5Ppj3gnkgmBeBeQJ4bobnSHiugucMGHfDOBTGZTBOAb8NfgzsOtg50HvQA5AL4FO1yv1UXlfl/iqvp/L6Kg9QeSCi8eXg9wNF4Icqf6Tyxyp/ovIylf+j8n9V/lTlz1T+XOUvVP5S5a9U/lrlb1T+VuXvVP5e5R9U/lHln1T+WeVfVP5V5d9U/p/K/6fycpVXBEyJqRxXOaFykcrFKpeoXKpymcqdVO6scrnKFSpXqtxF5a4qV6ncTeXuKvdQuafKvVTurXIflVdTeXWV11B5TZXXUnltlddRua/K1Sr3U3ldlfurvJ7K66s8QOWBKm+g8oYqb6TyxipvovKmKm+m8iCVkyrDN+PhG+rwTXH4xjZ8cxq+wQzfJIZv9MI3a+EbrvBNU/jGJ3zzEr4B2fhNRJXhm3nwDTn4php8Ywy+uQXfoIJvMsE3iuCbPfANG/imC3zjBL75Ad/AgG9CwDcS4JsBsIc+7CkPe6zDnuOwBzfsSQ17NMOexbCHL+xpC3u8wp6nsAco7IkJe0TCnomwhyDsqQd7zMGea7AHGezJBXtUwZ5NsIcR7OkDe9zAni+wBwrsCQJ7ZMCeEbCHAuwpAO/Ywzvn8A42vJMM7+jCO6vwDie80wjv+ME7b/AOGLwTBe8IwTsz8A4JvFMB7xhAzD3EoENMNsQoQ8wuxLBCTCfEOELMH8TAQUwYxEhBzBDE0EBMCcRYQMwBrMHDmjSs0cKaJazhwZoWrPHAmgesAcCcOMwRw5wpzCHCnBrMMcGcC8xBwDM5PKPCMxs8w8CYHsa4MOaDMRCMCcBHgs8AGwo25dZYRrf6Br8bBr97zp46dfLEyQ0zqidMb5hZPW36rOoj62bVH149p27q7IbqydOq506eNa1h5kwo/ENQad3gd9SM6XMmT5tUPa2pkcnT6qfOnjl5+rTqiXWTpzZMgFKlwe3XDGrV102dWj1renXdzJkNM2aNO7Ju3rjxk2eNmzn52Ab4u1O04lXRiveIVny1aMXXiFa8X7Ti60UrvlG04ptFKz40WvHh0YpvHa34ttGK7xit+M7Riu8Vrfg+0YofGK34IdGKT45WfEq04jOiFZ8drfix0YofH634qdGKnxGt+DnRil8Qrfil0YpfFq340mjFr45W/IZoxW+MVvyv0YrfEa34fdGKPxit+DNB8UFB8T2nT9u0Yd7kmbPqps2qPmr2+KmT66sn1M2qq57aUDdR+3Nw8dM2PbZhxnSo8lzQxHpBE6NQrZlT1VhgwvRpA/WIAA0E/pFjvedzrPdCUG9gdr00JmPgMuvwBlz1xdyrvpR71SODZ6/1ddVgpHQUbiJssDQtYXbqLHSv+ukzZjTMPGr6tAkgF3DPWXUzJjXAH9NmzairnwVVnixKV13buPc0aCrsnv8KKqwVVKibNavhyKNmNYrehAkA6/Dq6XMaZkycOn0u/P9ZUL6dcvpFtOLfRyv+U7Ti/4tWfHm04vCUGKF4WbTiXaIV7x6t+OrRiq8Zrfi60YqvH634RtGKbxKt+OBoxYdFK75ltOKpaMX3iFZ8r2jF949W/KBoxcdGK35YtOKTohU/Ilrxo6IVnxWt+HHRip8Qrfhp0YoviFb8nGjFz4tW/OJoxX8XrfiV0YpfFa34zUHxPAZ0twZNRB1g/TXHerflWO/2oF4OQ6s7cq96Z+5V9y5NV1lfV23vgG5+aSQZ+EtQvD1jMRieNg3ygt/Vg99tZ8yoO0YRNKFhXvX02bOqp0+sHj999rQJM3GlA3OpNC6XShNzqfSVyI0X3+Vys19yqdQnlhuFG+RYb5NYDkTWRKmk2bC+yKHSJrlUGpxLpRG5VNo+l0prRewqXa86F64PyKXS9hEpXBGU2zf47de83szZ4xsfJ1uufGA+lccGvz2C313CAeridSICV3SlSdHucUQu9zheRON8POipbdtHmy4eSW51pb1zpG2/aLRFciG60uERaUsE9XKS2IRBaU6V2ymxungkidWVJkW7xxG53COqxPaMJrE9c5HYnjlKbM9oEtszF4ntmaPE9spHYnvlI7G9oklsr1wktlc0ie2Vi8T2ylFi1zfqRWKernxSPpXPaB9XdPGzonBFVzo/2j0W5XKPayJyPhnNViRzsRXJHG1FMpqtSOZiK5I52gqZj62Q+dgKGc1WyFxshYxmK2QutkLmaCu2iyax2+UisdvlKLHbRZPY7XKR2O1ylNiR+UjsyHwkdmQ0iR2Zi8SOjCaxI3OR2JE5SuzofLzb6Hy82+ho3m10Lt5tdDTvNjoX7zY6R+9Wl4/M1+Uj83XRZL4uF5mviybzdbnIfF2OMj8hmpWekIuVnpCjlZ4QzUpPyMVKT8jRSjfkI7EN+UhsQzSJbchFYhuiSWxDLhLbkKPEzokmsXNykdg5OUrsnGgSOycXiZ2To8TOzUdi5+YjsXOjSezcXCR2bjSJnZuLxM7NUWIX5DOuWJDPuGJBtHHFglzGFQuijSsW5DKuWJDjuGJRNFuxKBdbsShHW7Eomq1YlIutWJSjrVicj61YnI+tWBzNVizOxVYsjmYrFudiKxbnaCuuiSax1+QisdfkKLHXRJPYa3KR2GtylNhr85HYa/OR2GujSey1uUjstdEk9tpcJPbaHCX2zny82535eLc7o3m3O3PxbndG82535uLd7szRu50ShDPvGuVmutKvOd5seS43K4pFqPRKEBbcS+RQaa1cKvXPpdJGUSr9O6i0fi6VNsml0uBcKo3IpdL2uVSKGvmh60WK/NCVBuRSKWrkx4dBvZw8kK58YD6V2+mBdPG6KP2mK02Kdo8jcrlHVA/0SVBv2/bR9kkucqsrRR0z6XrtHDN9YshBJNqijpmW5SOxy/KR2GXRJHZZLhK7LJrELstFYpflKLE/R5PYn3OR2J9zlNifo0nsz7lI7M85Suwv+UjsL/lI7C/RJPaXXCT2l2gS+0suEvtLjhLbqTi7XiTm6con5VO5naN8XTzSKF9XOj/aPRblco9rInK+Z1CvnbZCF48WJRZUihwlFtRrb5RYUDxalFhQKXKUWFAvtygxg9KcKrc3SiwoHslW6EqTot3jiFzuEdVWDIgmsQNykdgBOUrsgGgSOyAXiR2Qo8QOzEdiB+YjsQOjSezAXCR2YDSJHZiLxA7MUWKH5+Pdhufj3YZH827Dc/Fuw6N5t+G5eLfhOXq3HfKR+R3ykfkdosn8DrnI/A7RZH6HXGR+hxxlfudoVnrnXKz0zjla6Z2jWemdc7HSO+dopXfJR2J3yUdid4kmsbvkIrG7RJPYXXKR2F1ylNiDo0nswblI7ME5SuzB0ST24Fwk9uAcJXZMPhI7Jh+JHRNNYsfkIrFjoknsmFwkdkyOEjsln3HFlHzGFVOijSum5DKumBJtXDEll3HFlBzHFXOi2Yo5udiKOTnaijnRbMWcXGzFnBxtxdx8bMXcfGzF3Gi2Ym4utmJuNFsxNxdbMTdHW3FmNIk9MxeJPTNHiT0zmsSemYvEnpmjxJ6Vj8SelY/EnhVNYs/KRWLPiiaxZ+UisWflKLGX5ePdLsvHu10Wzbtdlot3uyyad7ssF+92WQ7eTfw/dXRb8grzCwA=", "debug_symbols": "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" }, { "name": "constructor", "is_unconstrained": true, "custom_attributes": ["aztec(public)", "aztec(initializer)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "target_contract", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "reward_token", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }], "param_witnesses": { "inputs": [{ "start": 0, "end": 37 }], "reward_token": [{ "start": 38, "end": 39 }], "target_contract": [{ "start": 37, "end": 38 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240] }, "bytecode": "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", "debug_symbols": "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46XSsfFS6dh4qXRsvGQ61mQ61mQ61mQ61mQ6VsbzChnPK2Q8r5DxvELG8woZzytkPK+Q8bxCxvMKGc8rZDyvkPG8QsbzChnPK2Q8r5DxvELG8woZzytkPK+Q8bxCxvMKGc8rZDyvkPG8QsbzChnPK2Q8r5DxvELG8woZzytkPK+Q8bxCxvMKGc8rZDyvkPG8QsbzChnPK2Q8r5DxvELG8woZzytkPK+Q8bxCxvMKGc8rZDyvkPG8QsbzChnPK2Q8r5DxvELG8woZzytkPK+Q8bxCxvMKGc8rZDyvkPG8QsbzChnPK2Q8r5DxvELG8woZzytkPK+Q8bxCxvMKGc8rZDyvkPG8QsbzChnPK2Q8r5DxvELG8woZzytkPK+Q8bxCxvMKGc8rZDyvkPG8QsbzChnPK2U8r5TxvFLG80oZzytfKh2bMp5XynheKeN5pYznlTKeV8p4XinjeaWM55UynlfKeF4p43mljOeVMp5XynheKeN5pYznlTKeV8p4XinjeaWM55UynlfKeF4p43mljOeVMp5XynheKeN5pYznlTKeV8p4XinjeaWM55UynlfKeF4p43mljOeVMp5XynheKeN5pYznlTKeV8p4XinjeaWM55UynlfKeF4p43mljOeVMp5XynheKeN5pYznlTKeV8p4XinjeaWM55UynlfKeF4p43mljOeVMp5XynheKeN5pYznlTKeV8p4XinjeaWM55UynlfKeF4p43mljOeVMp5XynheKeN5pYznlTKeV8p4XinjeaWM55UynlfKeF4p43mljOeVMp5XynheKeN5pYznlTKeV8p4XinjeaWM55UynlfKeF4p43mVjOdVMp5XyXheJeN51UulY0vG8yoZz6tkPK+S8bxKxvMqGc+rNp7XxyO+fyT2j+T+kdo/cvaP3P0jvX9k1o9sxJaPR/bT9/30fT9930/f99P3/fR9P33fT9/304/99GM//dhPP/bTj/30v8Zv/89ffZ579X3u1f3cq+exV38Nav6fv9qee7U/9+p47tX53KufS2M+l8Z8Lo35XBrzuTTWc2ms59JYz6WxnktjPZfGei6N9Vwa67k01nNprAfS+K+/7rr/8pU3fv0J8OTHLc5L4hYmcQuXuEVI3CIlblEStzgSt7gSt2iJW0h055XozivRnVeiO69Ed16J7rwS3XkluvNKdOeV6M4r0Z0t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mLshmLshmLshmLshmLshmLshmLshmLshmLsBmLvzApi79yFGHOLEIUEcksQhRRxyiEMucUgThxCJNyLxRiTeiMQbkXgjEm9E4o1IvBGJNyLxRiTeicQ7kXgnEu9E4p1IvBOJdyLxTiTeicQ7kfggEh9E4oNIfBCJDyLxQSQ+iMQHkfggEh9E4pNIfBKJTyLxSSQ+icQnkfgkEp9E4pNIfBKJLyLxRSS+iMQXkfgiEl9E4otIfBGJLyLxRST+EIk/ROIPkfhDJP4QiT9E4g+R+EMk/hCJP0TiL5H4SyT+Eom/ROIvkfhLJP4Sib9E4i+R+EskvonEN5H4JhLfROKbSHwTiW8i8U0kvonEN5H4IRI/ROKHSPwQiR8i8UMkfojED5H4IRJPMHdGMHdGMHdGMHdGMHf2SuKQIg45xCGXOKSJQ4jEE8ydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydEcydE8ydE8ydE8ydE8ydv5I4pIhDvp74uv1xyDH79tUnv/PFcT9enBa/3ud1v93nit2nxe4zWvf5HfjA3/c+JnYfF7tPiN0nxe5TYvcR62cT62cT62cT62cX62cX62cX62cX62cX62cX62cX62cX62cX62cX6+cQ6+cQ6+cQ6+cQ6+cQ6+cQ6+cQ6+cQ6+cQ6+cQ6+cU6+cU6+cU6+cU6+cU6+cU6+cU6+cU6+cU6+cU6+cS6+cS6+cS6+cS6+cS6+cS6+cS6+cS6+cS6+cS6+cj1s9HrJ+PWD8fsX4+Yv18xPr5iPXzEevnI9bPR6yfr1g/X7F+vmL9fMX6+Yr18xXr5yvWz1esn69YP1+xfm6xfm6xfm6xfm6xfm6xfm6xfm6xfm6xfm6xfm6xfh6xfh6xfh6x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hzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAhzOAh3OAh3OAh3OAh3OAh/NXAmcUcMYBzrjAGQ2cAeQc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEc4OEC4OEC4OEC4OEC4OHilcAZBZxxgDMucEYDZwA5B3i4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4AHi4BHi4BHi4BHi4BHi4fCVwRgFnHOCMC5zRwBlAzgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEeLgEe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yccjs35kY258PGL7R3z/SOwfyf0jtX/k7B+5+0f20/f99GM//dhPP/bTj/30Yz/92E8/9tOP/fRjP/3YTz/308/99HM//dxPP/fTz/30cz/93E8/99PP/fRrP/3aT7/206/99Gs//dpPv/bTr/30az/92k//7Kd/9tM/++mf/fTPfvpnP/2zn/7ZT//sp3/207/76d/99O9++nc//buf/t1P/+6nf/fTv/vp3/30ez/93k+/99Pv/fR7P/3eT7/30+/99Hs//d5Pf/bTn/30Zz/92U9/9tOf/fRnP/3ZT3/205/19O/rtX/E9o/4/pHYP5L7R2r/yNk/cveP9P6R/fRtP33bT9/207f99G0/fdtP3/bTt/3097u+u9/13f2u7+53fXe/67v7Xd/d7/ruftd397u+u9/13f2u7+53fXe/67v7Xd/d7/ruftd397u+u9/13f2u7+53fXe/67v7Xd/d7/ruftd397u+u9/13f2u7+53fXe/67v7Xd/d7/ruftd397u+u9/13f2u7+53fXe/67v7Xd/d7/ruftd397u+u9/13f2u7+53fXe/67v7Xd/d7/ruftd397u+u9/13f2u7+53fXe/67v7Xd/d7/ruftd397u+u9/13f2u7+53fXe/67v7Xd/d7/ruftd397u+u9/13f2u7+53fXe/67v7Xd/d7/ruftd397u+u9/13f2u7+53fXe/67v7Xd/d7/ruftd397u+u9/19X7X1/tdX+93fb3f9fV+19f7XV/vd3293/X1ftfX+11f73d9vd/19X7X1/tdX+93fb3f9fV+19f7XV/vd3293/X1ftfX+11f73d9vd/19X7X1/tdX+93fb3f9fV+19f7XV/vd3293/X1ftfX+11f73d9vd/19X7X1/tdX+93fb3f9fV+19f7XV/vd3293/X1ftfX+11f73d9vd/19X7X1/tdX+93fb3f9fV+19f7XV/vd3293/X1ftfX+11f73d9vd/19X7X1/tdX+93fb3f9fV+19f7XV/vd3293/X1ftfX+11f73d9vd/19X7X1/tdX+93fb3f9fV+19f7XV/vd3293/X1ftfX+11f73d9vd/19X7X1/tdX+93fb3f9fV+19f7XV/vd3293/X1ftfX+11f73d9vd/19X7X1/tdX+93fb3f9c1+1zf7Xd/sd32z3/XNftc3+13f7Hd9s9/1zX7XN/td3+x3fbPf9c1+1zf7Xd/sd32z3/XNftc3+13f7Hd9s9/1zX7XN/td3+x3fbPf9c1+1zf7Xd/sd32z3/XNftc3+13f7Hd9s9/1zX7XN/td3+x3fbPf9c1+1zf7Xd/sd32z3/XNftc3+13f7Hd9s9/1zX7XN/td3+x3fbPf9c1+1zf7Xd/sd32z3/XNftc3+13f7Hd9s9/1zX7XN/td3+x3fbPf9c1+1zf7Xd/sd32z3/XNftc3+13f7Hd9s9/1zX7XN/td3+x3fbPf9c1+1zf7Xd/sd32z3/XNftc3+13f7Hd9s9/1zX7XN/td3+x3fbPf9c1+1zf7Xd/sd32z3/XNftc3+13f7Hd9s9/1zX7XN/td3+x3fbPf9c1+1zf7Xd/sd32z3vW9V32v/SO2f8T3j8T+kdw/UvtHzv6Ru3+k94/sp2/76dt++rafvu2nb/vp2376tp++7adv++nbfvq+n77vp+/76ft++r6fvu+n7/vp+376vp++76cf++nHfvqxn37spx/76cd++rGffuynH/vpx376uZ9+7qef++nnfvq5n37up5/76ed++rmffu6nX/vp1376tZ9+7adf++nXfvq1n37tp1/76dd++mc//bOf/tlP/+ynf/bTP/vpn/30z376Zz/9s5/+3U//7qd/99O/++nf/fTvfvp3P/27n/7dT//up9/76fd++r2ffu+n3/vp9376vZ9+76ff++n3fvqzn/7spz/76c9++rOf/uynP/vpz376s5/+ftdn+12f7Xd9tt/12X7XZ/tdn+13fbbf9dl+12f7XZ/td3223/XZftdn+12f7Xd9tt/12X7XZ/tdn+13fbbf9dl+12f7XZ/td3223/XZftdn+12f7Xd9tt/12X7XZ/tdn+13fbbf9dl+12f7XZ/td3223/XZftdn+12f7Xd9tt/12X7XZ/tdn+13fbbf9dl+12f7XZ/td3223/XZftdn+12f7Xd9tt/12X7XZ/tdn+13fbbf9dl+12f7XZ/td3223/XZftdn+12f7Xd9tt/12X7XZ/tdn+13fbbf9dl+12f7XZ/td3223/XZftdn+12f7Xd9tt/12X7XZ/tdn+13fbbf9dl+12f7XZ/td3223/XZftdn+12f7Xd9tt/12X7XZ/tdn+13fbbf9dl+12f7XZ/td3223/XZftdn+12f7Xd9tt/12X7X5/tdn+93fb7f9fl+1+f7XZ/vd32+3/X5ftfn+12f73d9vt/1+X7X5/tdn+93fb7f9fl+1+f7XZ/vd32+3/X5ftfn+12f73d9vt/1+X7X5/tdn+93fb7f9fl+1+f7XZ/vd32+3/X5ftfn+12f73d9vt/1+X7X5/tdn+93fb7f9fl+1+f7XZ/vd32+3/X5ftfn+12f73d9vt/1+X7X5/tdn+93fb7f9fl+1+f7XZ/vd32+3/X5ftfn+12f73d9vt/1+X7X5/tdn+93fb7f9fl+1+f7XZ/vd32+3/X5ftfn+12f73d9vt/1+X7X5/tdn+93fb7f9fl+1+f7XZ/vd32+3/X5ftfn+12f73d9vt/1+X7X5/tdn+93fb7f9fl+1+f7XZ/vd32+3/X5ftfn+12f73d9vt/1+X7X5/tdn+93fb7f9fl+1xf7XV/sd32x3/XFftcX+11f7Hd9sd/1xX7XF/tdX+x3fbHf9cV+1xf7XV/sd32x3/XFftcX+11f7Hd9sd/1xX7XF/tdX+x3fbHf9cV+1xf7XV/sd32x3/XFftcX+11f7Hd9sd/1xX7XF/tdX+x3fbHf9cV+1xf7XV/sd32x3/XFftcX+11f7Hd9sd/1xX7XF/tdX+x3fbHf9cV+1xf7XV/sd32x3/XFftcX+11f7Hd9sd/1xX7XF/tdX+x3fbHf9cV+1xf7XV/sd32x3/XFftcX+11f7Hd9sd/1xX7XF/tdX+x3fbHf9cV+1xf7XV/sd32x3/XFftcX+11f7Hd9sd/1xX7XF/tdX+x3fbHf9cV+1xf7XV/sd32x3/XFftcX+11f7Hd9sd/1xX7XF/tdX+x3fbHf9cV+1xf7XV/sd32x3/XFfteX+11f7nd9ud/15X7Xl/tdX+53fbnf9eV+15f7XV/ud3253/XlfteX+11f7nd9ud/15X7Xl/tdX+53fbnf9eV+15f7XV/ud3253/XlfteX+11f7nd9ud/15X7Xl/tdX+53fbnf9eV+15f7XV/ud3253/XlfteX+11fbnZ9f/evvq7u9V++9P0/49tX3/vt/f3w++fZ929Wjp96vz38fn/4/fHw+/Ph99fD7z8Pv//h/Oaj+bXXCjD61we87/fLV2bOt6/tv3p9P/v6efT1/Xr29fbs6/3Z18ezr89nX1/Pvv48+/qv1c7r4yvr9f3X97Ovn0dfP69nX2/Pvt6ffX08+/p89vX17OvPs69/NrXzbGrn0dSuoMLPvN6efb0/+/p49vVf+157P75blb2++/p69vXn2dffZ1/fz75+Hn29vZ59vT37en/29fHs659NrT2bWns2tfZsau3Z1NqzqfVnU+vPptafTa0/m1p/NrX+bGr92dT6s6n1Z1Prz6Y2nk1tPJvaeDa18Wxq49nUxrOpjWdTG8+mNp5NbTyb2nw2tflsavPZ1Oazqc1Ht7CR99nX97Ovf/S/nax0gc+83p59vT/7+nj29fns6+vZ1z+6hV0pFp95fT/7+me3sOfZLex5dgt7nt3Cnme3sCeffX09+/pnU3ueTe15NrXn2dTeZ1N7n03tfTa199m/Y9589vXP/mR4n/3J8D77k+F99ifD++xPhv3sT4b97E+G/exPhv1savvZ1Pazqe1nU9vPprafTW0/m9p5NrXzbGrn2dTOs6mdZ1M7z6Z2nk3tPJvaeTa182hq8/V69vX27Ov92dfHs6/PZ19fz77+PPv6++zr+9nXP5vaZ+mifJYuymfpon9DTn0vSj62q6/89ti7YH997nzyufvJ5/qTz83nnvs+AeHfnot/8dyvn+f30Ybf8Nz95HP9yefmc899Hx/4Dc9993M5fn557pz+/nP3k8/1J5+bzz33/f9A+xues08+55987rvfRm0sfnnQpn5dgJ389cH67IOfnHx+cvL5ycnnJydf28m//0//99//1//49//7f/oP//h+4p//L/+vf/j3//Qf//M//PJ//Kf/57/8//83//3/BQ==" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "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", "debug_symbols": "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" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "19": { "source": "// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n/// A hint for decomposing a single field into two 16 byte fields.\nunconstrained fn decompose_unsafe(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    // Take hints of the decomposition\n    let (xlo, xhi) = decompose_unsafe(x);\n    let borrow = lt_unsafe(PLO, xlo, 16);\n\n    // Range check the limbs\n    xlo.assert_max_bit_size(128);\n    xhi.assert_max_bit_size(128);\n\n    // Check that the decomposition is correct\n    assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n    // Check that (xlo < plo && xhi <= phi) || (xlo >= plo && xhi < phi)\n    let rlo = PLO - xlo + (borrow as Field) * TWO_POW_128;\n    let rhi = PHI - xhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n\n    (xlo, xhi)\n}\n\nunconstrained fn lt_unsafe(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.__to_le_radix(256, num_bytes);\n    let y_bytes = y.__to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nunconstrained fn lte_unsafe(x: Field, y: Field, num_bytes: u32) -> bool {\n    lt_unsafe(x, y, num_bytes) | (x == y)\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    // Decompose a and b\n    let (alo, ahi) = decompose(a);\n    let (blo, bhi) = decompose(b);\n\n    let borrow = lte_unsafe(alo, blo, 16);\n\n    // Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if a == b {\n        false\n    } else if lt_unsafe(a, b, 32) {\n        assert_gt(b, a);\n        false\n    } else {\n        assert_gt(a, b);\n        true\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n", "path": "std/field/bn254.nr" }, "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "30": { "source": "mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\n// TODO: add implementations for the remainder of primitive types.\nimpl Hash for Field{\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        let input: [Field] = [self];\n        H::write(state, input);\n    }\n}\n", "path": "std/hash.nr" }, "33": { "source": "// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n", "path": "std/merkle.nr" }, "35": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "64": { "source": "use crate::{\n    context::Context, history::public_value_inclusion::prove_public_value_inclusion,\n    oracle::{storage::{storage_read, storage_write}}, state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T> Storage<T> for SharedImmutable<T> {}\n\nimpl<T> SharedImmutable<T> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(\n            self.context.private.is_none(), \"SharedImmutable can only be initialized from public functions\"\n        );\n        // TODO(#4738): Uncomment the following assert\n        // assert(\n        //     self.context.public.unwrap_unchecked().is_deployment(), \"SharedImmutable can only be initialized during contract deployment\"\n        // );\n\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let fields_read: [Field; 1] = storage_read(initialization_slot);\n        assert(fields_read[0] == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        storage_write(initialization_slot, [0xdead]);\n\n        let fields_write = T::serialize(value);\n        storage_write(self.storage_slot, fields_write);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"Public read only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.public.is_none(), \"Private read only supported in private functions\");\n        let private_context = self.context.private.unwrap();\n\n        // Read the value from storage (using the public tree)\n        let fields = storage_read(self.storage_slot);\n\n        // Loop over the fields and prove their inclusion in the public tree\n        for i in 0..fields.len() {\n            // TODO: Update membership proofs to use current header (Requires #4179)\n            // Currently executing unnecessary computation:\n            // - a membership proof of the value in the public tree of the header \n            prove_public_value_inclusion(\n                fields[i],\n                self.storage_slot + i as Field,\n                (*private_context).this_address(),\n                (*private_context)\n            )\n        }\n        T::deserialize(fields)\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr" }, "70": { "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::{AztecAddress},\n    header::Header, utils::field::full_field_less_than\n};\nuse dep::std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::{get_public_data_witness}};\n\nfn _public_value_inclusion(\n    value: Field,\n    storage_slot: Field,\n    contract_address: AztecAddress,\n    header: Header\n) {\n    // 1) Compute the leaf slot by siloing the storage slot with the contract address\n    let public_value_leaf_slot = pedersen_hash(\n        [contract_address.to_field(), storage_slot],\n        GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n    );\n\n    // 3) Get the membership witness of the slot\n    let witness = get_public_data_witness(\n        header.global_variables.block_number as u32,\n        public_value_leaf_slot\n    );\n\n    // 4) Check that the witness matches the corresponding public_value\n    let preimage = witness.leaf_preimage;\n\n    // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n    // 1. The value is the same as the one in the witness\n    // 2. The value was never initialized and is zero\n    let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n    let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n    let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n    let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n    if is_in_range {\n        assert_eq(value, 0, \"Non-existant public data leaf value is non-zero\");\n    } else {\n        assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot don't match witness\");\n        assert_eq(preimage.value, value, \"Public value does not match the witness\");\n    }\n\n    // 5) Prove that the leaf we validated is in the public data tree\n    assert(\n        header.state.partial.public_data_tree.root\n        == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n    );\n    // --> Now we have traversed the trees all the way up to archive root and that way verified that a specific\n    // `value` was really set in a given contract storage slot at block `block_number` in public data tree.\n}\n\npub fn prove_public_value_inclusion(\n    value: Field, // The value that we want to prove is in the public data tree\n    storage_slot: Field, // The storage slot in which the value is stored\n    contract_address: AztecAddress, // The contract we want to look into\n    context: PrivateContext\n) {\n    _public_value_inclusion(\n        value,\n        storage_slot,\n        contract_address,\n        context.historical_header\n    );\n}\n\npub fn prove_public_value_inclusion_at(\n    value: Field, // The value that we want to prove is in the public data tree\n    storage_slot: Field, // The storage slot in which the value is stored\n    contract_address: AztecAddress, // The contract we want to look into\n    block_number: u32, // The block at which we'll prove that the note exists\n    context: PrivateContext\n) {\n    let header = context.get_header_at(block_number);\n\n    _public_value_inclusion(value, storage_slot, contract_address, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/public_value_inclusion.nr" }, "71": { "source": "use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::{PrivateContext, ContextInterface},\n    oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\nfn _nullifier_inclusion(nullifier: Field, header: Header) {\n    // 1) Get the membership witness of the nullifier\n    let witness = get_nullifier_membership_witness(header.global_variables.block_number as u32, nullifier);\n\n    // 2) Check that the witness we obtained matches the nullifier\n    assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n    // 3) Compute the nullifier tree leaf\n    let nullifier_leaf = witness.leaf_preimage.hash();\n\n    // 4) Prove that the nullifier is in the nullifier tree\n    assert(\n        header.state.partial.nullifier_tree.root\n        == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n    );\n    // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n    //     was included in the nullifier tree.\n}\n\npub fn prove_nullifier_inclusion<TContext>(\n    nullifier: Field,\n    context: TContext\n) where TContext: ContextInterface {\n    _nullifier_inclusion(nullifier, context.get_header());\n}\n\npub fn prove_nullifier_inclusion_at(\n    nullifier: Field,\n    block_number: u32, // The block at which we'll prove that the nullifier exists in the nullifier tree\n    context: PrivateContext\n) {\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n\npub fn prove_note_is_nullified<Note, N>(\n    note: Note,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n\n    _nullifier_inclusion(nullifier, context.historical_header);\n}\n\npub fn prove_note_is_nullified_at<Note, N>(\n    note: Note,\n    block_number: u32,\n    context: &mut PrivateContext\n) where Note: NoteInterface<N> {\n    let nullifier = compute_siloed_nullifier(note, context);\n    let header = context.get_header_at(block_number);\n\n    _nullifier_inclusion(nullifier, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr" }, "72": { "source": "use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext,\n    note::{utils::compute_note_hash_for_consumption, note_interface::NoteInterface},\n    oracle::get_membership_witness::get_note_hash_membership_witness\n};\n\npub fn _note_inclusion<Note, N>(note: Note, header: Header) where Note: NoteInterface<N> {\n    // 1) Compute note_hash\n    let note_hash = compute_note_hash_for_consumption(note);\n\n    // 2) Get the membership witness of the note in the note hash tree\n    let witness = get_note_hash_membership_witness(header.global_variables.block_number as u32, note_hash);\n\n    // 3) Prove that the commitment is in the note hash tree\n    assert_eq(\n        header.state.partial.note_hash_tree.root, compute_merkle_root(note_hash, witness.index, witness.path), \"Proving note inclusion failed\"\n    );\n}\n\npub fn prove_note_inclusion<Note, N>(note: Note, context: PrivateContext) where Note: NoteInterface<N> {\n    _note_inclusion(note, context.historical_header);\n}\n\npub fn prove_note_inclusion_at<Note, N>(\n    note: Note,\n    block_number: u32, // The block at which we'll prove that the note exists\n    context: PrivateContext\n) where Note: NoteInterface<N> {\n    let header = context.get_header_at(block_number);\n\n    _note_inclusion(note, header);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/history/note_inclusion.nr" }, "77": { "source": "use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_non_existent_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL>,\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_non_existent_read_requests: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_non_existent_read_requests: self.nullifier_non_existent_read_requests.storage,\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address,\n            reverted: false\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_non_existent_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_non_existent_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let side_effect_counter = self.side_effect_counter;\n        // TODO get next value from output of `call_public_function_internal`\n        self.side_effect_counter += 1;\n\n        call_public_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "82": { "source": "use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address, messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n    nullifier_key_validation_request::NullifierKeyValidationRequest,\n    private_call_stack_item::PrivateCallStackItem,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    note_hash_read_requests: BoundedVec<SideEffect, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.note_hash_read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n                nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                start_side_effect_counter: 0,\n                end_side_effect_counter: 0,\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero(),\n                reverted: false\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "91": { "source": "use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u64 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nfn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u64, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr" }, "93": { "source": "use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr" }, "94": { "source": "#[oracle(packArguments)]\nfn pack_arguments_oracle<N>(_args: [Field; N]) -> Field {}\n\n// TODO: explain what this does.\nunconstrained pub fn pack_arguments<N>(args: [Field; N]) -> Field {\n    pack_arguments_oracle(args)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr" }, "99": { "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, \n    address::AztecAddress, \n    constants::ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nfn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr" }, "100": { "source": "use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nfn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nfn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr" }, "103": { "source": "use dep::protocol_types::{address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH};\n\n#[oracle(getContractInstance)]\nfn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr" }, "107": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "108": { "source": "use dep::protocol_types::{constants::{ARCHIVE_HEIGHT, NOTE_HASH_TREE_HEIGHT}, utils::arr_copy_slice};\n\nglobal NOTE_HASH_TREE_ID = 1;\nglobal ARCHIVE_TREE_ID = 4;\n\n// Note: We have M here because we need to somehow set it when calling get_membership_witness function and one way to\n// do it is to set M here and then set type of the return param, e.g.:\n//\n// `let witness: MembershipWitness<NOTE_HASH_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT + 1> = get_membership_witness(...);`\n//\n// Another way to do it would be to add \"type_hint: [Field; T]\" as argument to `get_membership_witness` but that's\n// a bit too boilerplatey for my taste.\nstruct MembershipWitness<N, M> {\n    index: Field,\n    path: [Field; N],\n}\n\n#[oracle(getMembershipWitness)]\nfn get_membership_witness_oracle<M>(\n    _block_number: u32,\n    _tree_id: Field,\n    _leaf_value: Field\n) -> [Field; M] {}\n\nunconstrained pub fn get_membership_witness<N, M>(\n    block_number: u32,\n    tree_id: Field,\n    leaf_value: Field\n) -> MembershipWitness<N, M> {\n    let fields: [Field; M] = get_membership_witness_oracle(block_number, tree_id, leaf_value);\n    MembershipWitness { index: fields[0], path: arr_copy_slice(fields, [0; N], 1) }\n}\n\n// Note: get_nullifier_membership_witness function is implemented in get_nullifier_membership_witness.nr\n\nunconstrained pub fn get_note_hash_membership_witness<N, M>(\n    block_number: u32,\n    leaf_value: Field\n) -> MembershipWitness<NOTE_HASH_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT + 1> {\n    get_membership_witness(block_number, NOTE_HASH_TREE_ID, leaf_value)\n}\n\n// There is no `get_public_data_membership_witness` function because it doesn't make sense to be getting a membership\n// witness for a value in the public data tree.\n\nunconstrained pub fn get_archive_membership_witness(\n    block_number: u32,\n    leaf_value: Field\n) -> MembershipWitness<ARCHIVE_HEIGHT, ARCHIVE_HEIGHT + 1> {\n    get_membership_witness(block_number, ARCHIVE_TREE_ID, leaf_value)\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_membership_witness.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "114": { "source": "use dep::protocol_types::{\n    hash::{silo_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, ContextInterface},\n    oracle::get_contract_instance::get_contract_instance,\n    history::nullifier_inclusion::prove_nullifier_inclusion,\n};\n\npub fn mark_as_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(*context);\n    ContextInterface::push_new_nullifier(context, init_nullifier, 0);\n}\n\npub fn assert_is_initialized<TContext>(context: &mut TContext) where TContext: ContextInterface {\n    let init_nullifier = compute_contract_initialization_nullifier(*context);\n    prove_nullifier_inclusion(init_nullifier, *context);\n}\n\npub fn compute_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    let address = context.this_address();\n    silo_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(context)\n    )\n}\n\npub fn compute_unsiloed_contract_initialization_nullifier<TContext>(context: TContext) -> Field where TContext: ContextInterface {\n    context.this_address().to_field()\n}\n\npub fn assert_initialization_args_match_address_preimage<TContext>(context: TContext) where TContext: ContextInterface {\n    let address = context.this_address(); \n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash([init_selector.to_field(), init_args_hash], GENERATOR_INDEX__CONSTRUCTOR)\n}", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr" }, "121": { "source": "use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    // docs:start:compute_note_hash_and_nullifier_args\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S] // docs:end:compute_note_hash_and_nullifier_args\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n    // docs:start:compute_note_hash_and_nullifier_returns\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_nullifier_returns\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr" }, "131": { "source": "pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr" }, "132": { "source": "struct Reader<N> {\n    data: [Field; N],\n    offset: u64,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr" }, "144": { "source": "use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr" }, "145": { "source": "use crate::{\n    address::eth_address::EthAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash,\n    traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\nstruct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, portal_contract_address: EthAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            pedersen_hash(\n                [\n            salt,\n            initialization_hash,\n            portal_contract_address.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr" }, "146": { "source": "use crate::{\n    address::{eth_address::EthAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::pedersen_hash, traits::ToField\n};\n\n// Partial address\nstruct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, portal_contract_address)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            pedersen_hash(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr" }, "148": { "source": "use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr" }, "153": { "source": "use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr" }, "163": { "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize}\n};\n\nstruct FunctionData {\n    // First four bytes of the abi encoding \n    // of a function. \n    selector : FunctionSelector,\n    is_internal : bool,\n    is_private : bool,\n    is_constructor : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        self.is_internal == other.is_internal &\n        self.is_private == other.is_private &\n        self.is_constructor == other.is_constructor\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_internal: serialized[1] as bool,\n            is_private: serialized[2] as bool,\n            is_constructor: serialized[3] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data: FunctionData = dep::std::unsafe::zeroed();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty item hash\" test\n    assert_eq(hash, 0x200569267c0f73ac89aaa414239398db9445dd4ad3a8cf37015cd55b8d4c5e8d);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr" }, "168": { "source": "use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize}, abis::side_effect::Ordered\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    portal_contract_address : EthAddress,\n\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        assert(self.msg_sender.to_field() == 0);\n        assert(self.storage_contract_address.to_field() == 0);\n        assert(self.portal_contract_address.to_field() == 0);\n        assert(self.function_selector.to_field() == 0);\n        assert(self.is_delegate_call == false);\n        assert(self.is_static_call == false);\n        assert(self.side_effect_counter == 0);\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, call_context: CallContext) -> bool {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3595)\n        call_context.msg_sender.eq(self.msg_sender)\n            & call_context.storage_contract_address.eq(self.storage_contract_address)\n            & call_context.portal_contract_address.eq(self.portal_contract_address)\n            & call_context.function_selector.eq(self.function_selector)\n            & (call_context.is_delegate_call == self.is_delegate_call)\n            & (call_context.is_static_call == self.is_static_call)\n            & (call_context.side_effect_counter == self.side_effect_counter)\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender.to_field(),\n            self.storage_contract_address.to_field(),\n            self.portal_contract_address.to_field(),\n            self.function_selector.to_field(),\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.side_effect_counter as Field,\n        ]\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        CallContext {\n            msg_sender: AztecAddress::from_field(serialized[0]),\n            storage_contract_address: AztecAddress::from_field(serialized[1]),\n            portal_contract_address: EthAddress::from_field(serialized[2]),\n            function_selector: FunctionSelector::from_field(serialized[3]),\n            is_delegate_call: serialized[4] as bool,\n            is_static_call: serialized[5] as bool,\n            side_effect_counter: serialized[6] as u32,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let context: CallContext = dep::std::unsafe::zeroed();\n    let _hashed = context.hash();\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr" }, "183": { "source": "use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem, side_effect::SideEffect\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_internal: false, is_private: false, is_constructor: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0xedd2f10c0cdf776ee2fff3c799bae6df5771f5013a2d5d7154601dffdcf869;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_internal: false, is_private: false, is_constructor: false };\n\n        let mut public_inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n        public_inputs.new_note_hashes[0] = SideEffect{\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x1cec0b51f9394405a626c3b77081c96f1bdcb8bacf96960ae4749068f9b4da0d;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr" }, "185": { "source": "use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_field(value: Field) -> Self {\n        Self { inner: value as u32 }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr" }, "194": { "source": "global NULLIFIER_LEAF_PREIMAGE_LENGTH: u64 = 3;\n\nuse crate::{merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u64,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u64 }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr" }, "196": { "source": "use crate::{\n    abis::{\n    call_context::CallContext, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::AztecAddress,\n    constants::{\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs{\n    call_context: CallContext,\n\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [SideEffect; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [SideEffectLinkedToNoteHash; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n\n    // Here so that the gas cost of this request can be measured by circuits, without actually needing to feed in the\n    // variable-length data.\n    unencrypted_log_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    prover_address: AztecAddress,\n\n    reverted: bool,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.extend_from_array(self.return_values);\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        fields.extend_from_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.reverted as Field);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            return_values: reader.read_array([0; RETURN_VALUES_LENGTH]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(SideEffect::deserialize, [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(SideEffectLinkedToNoteHash::deserialize, [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hash: reader.read_array([0; NUM_FIELDS_PER_SHA256]),\n            unencrypted_log_preimages_length: reader.read(),\n            historical_header: reader.read_struct(Header::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            reverted: reader.read() as bool,\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs: PublicCircuitPublicInputs = dep::std::unsafe::zeroed();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x083ac560a513d670a7f50f0a3052d42cb9816b7b643e62025b8278652ad637ab;\n    assert_eq(hash, test_data_empty_hash);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr" }, "199": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "202": { "source": "global ARGS_LENGTH: u64 = 16;\nglobal RETURN_VALUES_LENGTH: u64 = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_NOTE_HASHES_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX ≥ MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_NOTE_HASHES_PER_TX ≥ MAX_NEW_NOTE_HASHES_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX ≥ MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_CALL: u64 = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: u64 = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: u64 = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: u64 = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: u64 = 16;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_CALL: u64 = 32;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_CALL: u64 = 2; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL: u64 = 2;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: u64 = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 56;\n\nglobal MAX_NEW_NULLIFIERS_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 56;\n\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: u64 = 8;\n\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 8;\nglobal MAX_NON_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 3;\nglobal MAX_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 5;\n\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\n\nglobal MAX_PUBLIC_DATA_READS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\n\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: u64 = 2;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_TX: u64 = 128;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_TX: u64 = 8; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX: u64 = 8;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: u64 = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: u64 = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: u64 = 3;\nglobal FUNCTION_TREE_HEIGHT: u64 = 5;\nglobal NOTE_HASH_TREE_HEIGHT: u64 = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: u64 = 40;\nglobal NULLIFIER_TREE_HEIGHT: u64 = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: u64 = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: u64 = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\nglobal NULLIFIER_TREE_ID = 0;\nglobal NOTE_HASH_TREE_ID = 1;\nglobal PUBLIC_DATA_TREE_ID = 2;\nglobal L1_TO_L2_MESSAGE_TREE_ID = 3;\nglobal ARCHIVE_TREE_ID = 4;\n\n// SUB-TREES RELATED CONSTANTS\nglobal NOTE_HASH_SUBTREE_HEIGHT: u64 = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: u64 = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: u64 = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: u64 = 5;\nglobal ARCHIVE_HEIGHT: u64 = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: u64 = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: u64 = 35;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: u64 = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: u64 = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: u64 = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u64 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u64 = 32;\n// The following is used in immutable state variables to compute an initialization slot whose value is used to\n// determine whether a given variable has been initialized (by asserting that the value in the slot is 0).\n// The initialization slot is computed by adding the constant bellow to the variable's storage slot. This constant has\n// to be large enough so that it's ensured that it doesn't collide with storage slots of other variables.\nglobal INITIALIZATION_SLOT_SEPARATOR: Field = 1000_000_000;\nglobal INITIAL_L2_BLOCK_NUM: Field = 1;\n// 126976 = 31 * 4096;\nglobal BLOB_SIZE_IN_BYTES: Field = 126976;\n\n// CONTRACT CLASS CONSTANTS\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: u64 = 15000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: u64 = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: u64 = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\nglobal DEPLOYER_CONTRACT_ADDRESS = 0x0bffa876f07f9fe1802579dfef599810202f9c25b9a2f58921064a267d1ad1d3;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\nglobal MAX_NOTE_FIELDS_LENGTH: u64 = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: u64 = 23;\nglobal MAX_NOTES_PER_PAGE: u64 = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: u64 = 212;\n\n// LENGTH OF STRUCTS SERIALIZED TO FIELDS\nglobal AZTEC_ADDRESS_LENGTH = 1;\nglobal CALL_CONTEXT_LENGTH: u64 = 7;\nglobal CONTENT_COMMITMENT_LENGTH: u64 = 7;\nglobal CONTRACT_INSTANCE_LENGTH: u64 = 6;\nglobal CONTRACT_STORAGE_READ_LENGTH: u64 = 2;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: u64 = 2;\nglobal ETH_ADDRESS_LENGTH = 1;\nglobal FUNCTION_DATA_LENGTH: u64 = 4;\nglobal FUNCTION_LEAF_PREIMAGE_LENGTH: u64 = 5;\nglobal GLOBAL_VARIABLES_LENGTH: u64 = 6;\nglobal HEADER_LENGTH: u64 = 23; // 2 for last_archive, 7 for content commitment, 8 for state reference, 6 for global vars\nglobal L1_TO_L2_MESSAGE_LENGTH: u64 = 8;\nglobal L2_TO_L1_MESSAGE_LENGTH: u64 = 2;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH = 5;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: u64 = 6;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: u64 = 215;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 210;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 202;\nglobal STATE_REFERENCE_LENGTH: u64 = 8; // 2 for snap + 8 for partial\nglobal TX_CONTEXT_DATA_LENGTH: u64 = 4;\nglobal TX_REQUEST_LENGTH: u64 = 10;\n\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH: Field = 13; // 2 + FUNCTION_DATA_LENGTH + CALL_CONTEXT_LENGTH\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: u64 = 674;\nglobal NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal NUM_MSGS_PER_BASE_PARITY: u64 = 4;\n// NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP / NUM_MSGS_PER_BASE_PARITY\nglobal NUM_BASE_PARITY_PER_ROOT_PARITY: u64 = 4;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n ≤ 8                         | 0 < hash_index ≤ 32  |\n * | MID       | 8 < n ≤ 16                    | 32 < hash_index ≤ 40 |\n * | HIGH      | 16 < n ≤ 48                   | 40 < hash_index ≤ 48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size ≤ 8\nglobal GENERATOR_INDEX__NOTE_HASH = 1;\nglobal GENERATOR_INDEX__NOTE_HASH_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size ≤ 16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size ≤ 44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\nglobal GENERATOR_INDEX__AUTHWIT_INNER = 45;\nglobal GENERATOR_INDEX__AUTHWIT_OUTER = 46;\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/constants.nr" }, "209": { "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr" }, "210": { "source": "use crate::traits::{Empty, Hash};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u64,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr" }, "225": { "source": "use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    portal_contract_address : EthAddress,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt) &\n        self.portal_contract_address.eq(other.portal_contract_address)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.portal_contract_address.to_field(),\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            portal_contract_address: EthAddress::from_field(serialized[4]),\n            public_keys_hash: PublicKeysHash::from_field(serialized[5]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.portal_contract_address\n            )\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr" }, "239": { "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Serialize<7> for ValueNote {\n    fn serialize(self) -> [Field; 7] {\n        let header = self.header.serialize();\n\n        [self.value, self.owner.to_field(), self.randomness, header[0], header[1], header[2], header[3]]\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr" }, "244": { "source": "use dep::aztec::{\n    protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress},\n    context::PrivateContext\n};\n\nstruct Token {\n  address: AztecAddress,\n}\n\nimpl Token {\n    pub fn at(address: AztecAddress) -> Self {\n        Self { address }\n    }\n\n    fn mint_public(self: Self, context: &mut PrivateContext, to: AztecAddress, amount: Field) {\n        let _ret = context.call_public_function(\n            self.address,\n            FunctionSelector::from_signature(\"mint_public((Field),Field)\"),\n            [to.to_field(), amount]\n        );\n    }\n\n    pub fn transfer(\n        self: Self,\n        context: &mut PrivateContext,\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n        nonce: Field\n    ) {\n        let _ret = context.call_private_function(\n            self.address,\n            FunctionSelector::from_signature(\"transfer((Field),(Field),Field,Field)\"),\n            [from.to_field(), to.to_field(), amount, nonce]\n        );\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/claim_contract/src/interfaces.nr" }, "245": { "source": "contract Claim {\n    mod interfaces;\n\n    use dep::aztec::{\n        history::note_inclusion::prove_note_inclusion,\n        protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress},\n        state_vars::SharedImmutable\n    };\n    use dep::value_note::value_note::ValueNote;\n    use interfaces::Token;\n\n    struct Storage {\n      // Address of a contract based on whose notes we distribute the rewards\n      target_contract: SharedImmutable<AztecAddress>,\n      // Token to be distributed as a reward when claiming\n      reward_token: SharedImmutable<AztecAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(target_contract: AztecAddress, reward_token: AztecAddress) {\n        storage.target_contract.initialize(target_contract);\n        storage.reward_token.initialize(reward_token);\n    }\n\n    #[aztec(private)]\n    fn claim(proof_note: ValueNote) {\n        // 1) Check that the note corresponds to the target contract\n        let target_address = storage.target_contract.read_private();\n        assert(\n            target_address == proof_note.header.contract_address, \"Note does not correspond to the target contract\"\n        );\n\n        // 2) Prove that the note hash exists in the note hash tree\n        prove_note_inclusion(proof_note, context);\n\n        // 3) Compute and emit a nullifier which is unique to the note and this contract to ensure the reward can be\n        // claimed only once with the given note.\n        // Note: The nullifier is unique to the note and THIS contract because the protocol siloes all nullifiers with\n        // the address of a contract it was emitted from.\n        context.push_new_nullifier(proof_note.compute_nullifier(&mut context), 0);\n\n        // 4) Finally we mint the reward token to the sender of the transaction\n        let reward_token = Token::at(storage.reward_token.read_private());\n        reward_token.mint_public(&mut context, context.msg_sender(), proof_note.value);\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/claim_contract/src/main.nr" } } }
