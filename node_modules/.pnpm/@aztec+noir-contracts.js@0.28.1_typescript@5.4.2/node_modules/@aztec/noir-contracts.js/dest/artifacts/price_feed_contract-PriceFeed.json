{ "noir_version": "0.25.0+589a6cb62caf38445c768429150eee469ae35d77", "name": "PriceFeed", "functions": [{ "name": "get_price", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "asset_id", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "asset_id": [{ "start": 37, "end": 38 }], "inputs": [{ "start": 0, "end": 37 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239] }, "bytecode": "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", "debug_symbols": "5Z3djmTJkZzfZa4J4Xh4+E/wVQRdUCsKIECQiyUlQCD47kpKXdVDTGGm3XrC1gq8YpPMiOMFd7es/tos828//PHP//a7v/7hz3/6yw+//dsPz39ZuX/47X/92w9/+fff/ekf/8tf/vq7//jrD799fvPD7//0P17/+fff/PA///DH3//w29X99//2m/93IsYncnyixid6fOJMT9Tz7Sd+85PXuduXV3qc99d2vV1uNy9f45/VxyfGk1TjSarxJNV4kmo8STWepH7GJ2x8YtzzHve8xz3vcc973PMe97zHPe9xz893qYfF+fJKa/vxgn/w0rJ4e21Zvr/YznkrxXRKWTqluE4pW6eU0CkldUopnVJap5SjUoo/Mmrrj4za+iOjtv7IqK0/Mmrrj4za+iOjtv7IqK0/Mmrrj47amo7amo7amo7amo7amo7amo7amo7amo7amo7amo7aLh21XTpqu3TUdumo7dJR26WjtktHbZeO2i4dtV06aus6aus6aus6aus6aus6aus6aus6aus6aus6aus6art11HbrqO3WUduto7ZbR223jtpuHbXdOmq7ddR266ht6Kht6Kht6Kht6Kht6Kht6Kht6Kht6Kht6Kht6Kht6qht6qht6qht6qht6qht6qht6qht6qht6qht6qht6aht6aht6aht6aht6aht6aht6aht6aht6aht6aht66ht66ht66ht66ht66ht66ht66ht66ht66ht66itTpbMdbJkrpMlc50smetkyVwnS+Y6WTLXyZK5TpbMdbJkWydLtnWyZFsnS7Z1smT7kVHbrZMl2zpZsq2TJds6WbKtkyXbOlmyrZMl2zpZsq2TJds6WbKtkyXbOlmyrZMl2zpZsq2TJds6WbKtkyXbOlmyrZMl2zpZsq2TJds6WbKtkyXbOlmyrZMl2zpZsq2TJdvEqFKu91LaPyoldUphje16Ecgvr339sT8ohRbK+YZSTKeUpVOK65SyWRu0Xi95e/Hrz193aD3rrZhQKiaViimlYlqpmCNUDC+g8y3FmFIxS6kYVypGSYFDSYFDSYFDSYFpgZ21/e333rXP+qdfIGav/lL4+aSF08JAs8L7xFsN57H9UeH2WQtfn7Xw6Wem7/E3LuzxNy7s8Tcu7PE3Lux6xie+azp/uRffl5/4hvv98v378v1x+f68fP93vSvvfvLLS19/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5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv5qwv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56wv56yv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyv5qyvvi/LHPX+0ZOvP379BJOq9/vP3fu/L838Dffb5fvX5fv98v378v1x+f68fH9dvv/y/sbl/c3L+5uX9zcv729e3t+8vL95eX/z8v7m5f3Ny/ubl/e3Lu9vXd7fury/dXl/6/L+1uX9rcv7W5f3ty7vb13e3768v315f/vy/vbl/e3L+9uX97cv729f3t++vL99eX/P5f09l/f3XN7fc3l/z+X9PXf396zvqv+XPonvrLh7fd69vu5e33evP1ev9+fu9Vc/R/D4unu9371+373++7Z2vX988+uP/cH1eff6unt9373+XL1+P3evt7vXr7vX+93r993r727tvru1++7W7rtbu+9u7d3P7D13P7P33P3M3nP3M3vP9/0L1y9fH3evz7vX193r++71Vz9p++Tdrc27W5t3tzbvbm3e3dq8u7V5d2vz7tbm3a3Nu1tbd7e27m5t3d3auru1dXdr6+7W1t2trbtbW3e3tu5ubd/d2r67tX13a/vu1vbdre27W9t3t7bvbm3f3dq+u7Xf968/Fm9f4mf99TvlPvxKudcLvr52fb3YznmvxYVq2UK1hFAtKVRL0Wr5+v2T3fvDWlqolqNSy36eR6gWE6plCdXiQrVsoVpCqBaa7p7n7ZuU7fVPwB/WUjq1GE1fzruR4/VH/7AWE6plCdXiQrVsoVpCqJYUqqWEammhWo5OLUtId5eQ7i4h3V1CuruEdHcJ6e4S0t0lpLtLSHeXkO66kO66kO66kO66kO66kO66kO66kO66kO66kO66kO5uId3dQrq7hXR3C+nuFtLdLaS7W0h3t5DubiHd3UK6G0K6G0K6G0K6G0K6G0K6G0K6G0K6G0K6G0K6G0K6m0K6m0K6m0K6m0K6m0K6m0K6m0K6m0K6m0K6m0K6W0K6W0K6W0K6W0K6W0K6W0K6W0K6W0K6W0K6W0K620K620K620K620K620K620K620K620K620K620K6e4R09wjp7hHS3SOku0dId4+Q7h4h3T1CunuEdPfo6K49Orprj47u2qOju/bo6K49Orprj47u2qOju/bo6K49Orprj5DuCuXVTCivZkJ5NRPKq5lQXs2E8momlFczobyaCeXVTCivZkJ5NRPKq5lQXs2E8momlFczobyaCeXVTCivZkJ5NRPKq5lQXs2E8momlFczobyaCeXVTCivZkJ5NRPKq5lQXs2E8momlFczobyaCeXVTCivZkJ5NRPKq5lQXs2E8momlFczobyaCeXVTCivZrQs1HrW22fprSeeD2tJoVpYs7vWk2+1rKc+qoWW+fmWWkyoliVUiwvVsln6sl4veXvx689fFea1Ye/VhFQ1KVVNSVXTUtUcpWp4+Z9vqsakqllS1bhUNVJaXFJaXFJaXFJaTMsDrXXefxf2iH/6feKnr+4TbzWcxz76RGyr81kr7+fTVm6ftvL1aSt3gcrfagmhWlKolhKqRUHR32pR0OgvtRwF1X2rhaajfuq9ltMf1rKEanGhWrZQLSFUSwrVUkK1tFAtR6aWRUsafUstOrq7Hh3dXY+O7q5HR3fXo6O769HR3fXo6O56dHR3PUK6a0K6a0K6a0K6a0K6a0K6a0K6a0K6a0K6a0K6a0K6u4R0dwnp7hLS3SWku0tId5eQ7i4h3V1CuruEdHcJ6S4tUfP6Lf/t1tcvtvlhLS5UyxaqJYRqSaFaSqiWFqrl6NRCS9R8Sy32n1HLej6sZQnV4kK1bKFaaLprO95ryQ/fp2mJmm+p5ejUQkuOfEstJlTLEqrFhWqh6cvrXeitltffhD6sJYRqSaFaSqgWni/ol5IjSyj1tIRST0so9bSEUk9LKPW0cgvVEkK1pFAtJVSLkO6mkO6WkO6WkO6WkO6WkO6WkO6WkO6WkO6WkO6WkO6WkO62kO62kO62kO62kO62kO62kO62kO62kO62kO62kO4eId09Qrp7hLTuCGndEdK6I6R1R0fr/ONsyws/fDnnz48iva8r3o4Zdmxhxxw7trFjMTz2+m//+3f/8Yff/fc//v4vrxP/+D//15/+7a9/+POfvvzXv/6ff////8/f/y8=" }, { "name": "set_price", "is_unconstrained": true, "custom_attributes": ["aztec(public)"], "abi": { "parameters": [{ "name": "inputs", "type": { "kind": "struct", "path": "aztec::context::inputs::public_context_inputs::PublicContextInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "public_global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] }, "visibility": "private" }, { "name": "asset_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "price", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "asset_id": [{ "start": 37, "end": 38 }], "inputs": [{ "start": 0, "end": 37 }], "price": [{ "start": 38, "end": 39 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "aztec::protocol_types::abis::public_circuit_public_inputs::PublicCircuitPublicInputs", "fields": [{ "name": "call_context", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::call_context::CallContext", "fields": [{ "name": "msg_sender", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "storage_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "portal_contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "function_selector", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::function_selector::FunctionSelector", "fields": [{ "name": "inner", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "is_delegate_call", "type": { "kind": "boolean" } }, { "name": "is_static_call", "type": { "kind": "boolean" } }, { "name": "side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "args_hash", "type": { "kind": "field" } }, { "name": "return_values", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "nullifier_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "nullifier_non_existent_read_requests", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::read_request::ReadRequest", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "contract_storage_update_requests", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_update_request::StorageUpdateRequest", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "new_value", "type": { "kind": "field" } }] } } }, { "name": "contract_storage_reads", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::contrakt::storage_read::StorageRead", "fields": [{ "name": "storage_slot", "type": { "kind": "field" } }, { "name": "current_value", "type": { "kind": "field" } }] } } }, { "name": "public_call_stack_hashes", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } }, { "name": "new_note_hashes", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffect", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_nullifiers", "type": { "kind": "array", "length": 16, "type": { "kind": "struct", "path": "aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash", "fields": [{ "name": "value", "type": { "kind": "field" } }, { "name": "note_hash", "type": { "kind": "field" } }, { "name": "counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } } }, { "name": "new_l2_to_l1_msgs", "type": { "kind": "array", "length": 2, "type": { "kind": "struct", "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message", "fields": [{ "name": "recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "content", "type": { "kind": "field" } }] } } }, { "name": "start_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "end_side_effect_counter", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }, { "name": "unencrypted_logs_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "unencrypted_log_preimages_length", "type": { "kind": "field" } }, { "name": "historical_header", "type": { "kind": "struct", "path": "aztec::protocol_types::header::Header", "fields": [{ "name": "last_archive", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "content_commitment", "type": { "kind": "struct", "path": "aztec::protocol_types::content_commitment::ContentCommitment", "fields": [{ "name": "tx_tree_height", "type": { "kind": "field" } }, { "name": "txs_effects_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "in_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }, { "name": "out_hash", "type": { "kind": "array", "length": 2, "type": { "kind": "field" } } }] } }, { "name": "state", "type": { "kind": "struct", "path": "aztec::protocol_types::state_reference::StateReference", "fields": [{ "name": "l1_to_l2_message_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "partial", "type": { "kind": "struct", "path": "aztec::protocol_types::partial_state_reference::PartialStateReference", "fields": [{ "name": "note_hash_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "nullifier_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }, { "name": "public_data_tree", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot", "fields": [{ "name": "root", "type": { "kind": "field" } }, { "name": "next_available_leaf_index", "type": { "kind": "integer", "sign": "unsigned", "width": 32 } }] } }] } }] } }, { "name": "global_variables", "type": { "kind": "struct", "path": "aztec::protocol_types::abis::global_variables::GlobalVariables", "fields": [{ "name": "chain_id", "type": { "kind": "field" } }, { "name": "version", "type": { "kind": "field" } }, { "name": "block_number", "type": { "kind": "field" } }, { "name": "timestamp", "type": { "kind": "field" } }, { "name": "coinbase", "type": { "kind": "struct", "path": "aztec::protocol_types::address::eth_address::EthAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "fee_recipient", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }] } }] } }, { "name": "prover_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] } }, { "name": "reverted", "type": { "kind": "boolean" } }] }, "visibility": "public" }, "return_witnesses": [39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240] }, "bytecode": "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", "debug_symbols": "1Z3RjmXHjWX/Rc/C4JLBIBn+lcE8aHo8gAFDbrQ1AwwM//tcd2emSlBKKu7UDu18arl94wStQ+5btWqx8h/f/PVv//bdD3/52/d//+ZP//jm8d889zd/+u//+Obv//7d9//6//z9h+/+44dv/vT49ps/f/+/nv/3n99+87//8tc/f/Mn7/7n//j2P0/k+ESNT/T4xJmeqMf4hH39iW9/9rm17OWTa5+3z3a9PtyZD1/j/60xPjHupBp3Uo07qcadVONO6nEntY1P+PjE+J33+J33+J33+J33+J33+J33+J2f8Ts/43d+xu/8jN/5Gb/zsz8SVLbPyyet7cugeuejZfv1s2X59mE757WU1CmldEppnVKOSinr8dApxXRKcZ1Slk4poVOKTNquh0zarodM2q6HTNquh07amk7amk7amk7amk7amk7amk7amk7amk7amk7amk7auk7auk7auk7auk7auk7auk7auk7auk7auk7auk7aLp20XTppu3TSdumk7dJJ26WTtksnbZdO2i6dtF06aRs6aRs6aRs6aRs6aRs6aRs6aRs6aRs6aRs6aRs6abt10nbrpO3WSdutk7ZbJ223TtpunbTdOmm7ddJ266Rt6qRt6qRt6qRt6qRt6qRt6qRt6qRt6qRt6qRt6qRt6aRt6aRt6aRt6aRt6aRt6aRt6aRt6aRt6aRt6aRt66Rt66Rt66Rt66Rt66Rt66Rt66Rt66Rt66Rt66Tt0Unbo5O2Rydtj07aHp201dklWzq7ZEtnl2zp7JItnV2y0NklC51dstDZJQudXbJ4yKRt6OyShc4uWejskoXOLlno7JKFzi5Z6OyShc4uWejskoXOLlno7JKFzi5Z6OyShc4uWejskoXOLlno7JKFzi5Z6OyShc4uWejskoXOLlno7JKFzi5Z6OyShc4uWejskoXOLlno7JKFzi5Z6OyShc4uWVxcVUp/K6XXe6WYTim32taf4Pzls89/7PdK2TqlpE4ppVNK65Ry7RcJ/vzI64ef//zjDPnDX4q5t5bzNcWYUjGuVMxSKiaUitlKxaRSMaVUTCsVo5TAqZTAqZTAqZTA1xZ2/Pmb1NdfQMTxn/wCYvbpl8Ljsxa+JQvvs19rOA+L9wrPz1p4fdLCxz9xIcrGJ3x8Yo1PxPjEHp/4UHd+xbso8vOb/PzDff7H1he+4vlGfv6HvpWf//Pz5aPPf6y3T1e9Pn5xHx/cx2/u45P7+OI+fvrTM2L80zNi/NMzYvzTM2L80zNi/NMzYvzTM+KMvwlOjk/U+MT4nZ/pO9+Px/iEjU/4+MQan4jxiT0+keMTNT7R4xPjd27jd27jd27jd27jd27jd27jd27jd27jd27jd27jd+7jd+7jd+7jd+7jd+7jd+7jd+7jd+7jd+7jd+7jd77G73yN3/kav/M1fudr/M7X+J2v8Ttf43e+xu98jd95jN95jN95jN95jN95jN95jN95jN95jN95jN95jN/5Hr/zPX7ne/zO9/id7/E73+N3vsfvfI/f+R6/8z1+5zl+5zl+5zl+5zl+5zl+5+OfjbvHPxt3j3827h7/bNw9/tm4e0xq95jU7jGp3WNSu8ekdo9J7R7/FNs9/im2e/xTbPf4p9ju8U+x3eOfYrvHP8V2j3+K7R7/FNs9/im2e/xTbPf4p9juMYfbYw63xxxujzncHnO4PeZwe8zh9pjD7TGH22MOt8ccbo85XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI45XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI05XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XI85XH/sr4n/zb/Voz/2d79/xfOD/PxNfn6Sn1/k5zf5+dy/Nac/9teZf8Xzjfx88vwu8vwu8vwu8vwu8vwu8vwu8vwu8vwGeX6DPL9Bnt8gz2+Q5zfI8/uxv9U813r5ZO4vnm6Pd//e+be/v/vx43PXfi2kVApplUKOSCEf+7vMf89CTKUQVylkqRQSKoVslUJUknWrJOtWSdatkqypkqypkqypkqypkqypkqypkqypkqypkqypkqypkqxFStaXpxv16U59+qI+PahP39SnJ/XpRX16U59+mE9v6qw2dVabOqtNndWmzmpTZ7Wps9rUWW3qrDZ1Vg91Vg91Vg91Vg91Vs/HZjVffxBq1vnYL6zOVikkVQoplUJapZCjUch5PFQKMZVCXKWQpVKISLKeh0iynodIsp6HSLKeh0iynodKsppKsppKsppKsppKsppKsppKsppKsppKsppKsppKsrpKsrpKsrpKsrpKsrpKsrpKsrpKsrpKsrpKsrpKsi6VZF0qybpUknWpJOtSSdalkqxLJVmXSrIulWRdKskaKskaKskaKskaKskaKskaKskaKskaKskaKskaKsm6VZJ1qyTrVknWrZKsWyVZt0qybpVk3SrJulWSdaska6oka6oka6oka6oka6oka6oka6oka6oka6oka6oka6kka6kka6kka6kka6kka6kka6kka6kka6kka6kka6ska6ska6ska6ska6ska6ska6ska6ska6ska6sk61FJ1qOSrEclWY9KsqrsYB2VHayjsoN1VHawjsoO1lHZwbKHyhLWsxKRbH1WIhKuz0pE0vVZiUi8PisRyddnJSIB+6xEJGGflYhE7LMSmYxVWcd6ViKTsSoLWc9KZDJWZSXrWYlMxqosZT0rkclYlbWsZyUyGauymPWsRCZjVVaznpXIZKzKctazEpmMVVnPelYik7EqC1rPSmQyVmVF61mJTMaqLGk9K5HJWJU1rWclMhmrsqj1rEQmY1VWtZ6VyGSsyrLWsxKZjFVZ13pWIpOxKgtbz0pkMlZlZetZiUzGqixtPSuRyViVta1nJTIZq7K49axEJmNVVreelchkrMry1rMSmYxVWd96ViKTsSoLXM9KZDJWZYXrWYlMxqoscT0rkclYlTWuZyUyGauyyPWsRCZjVVa5npXIZKzKMtezEpmMVVnnelYik7EqC13PSmQyVmWl61mJTMaqLHU9K5HJWJW1rmclMhmrstj1rEQmY1VWu56VyGSsynLXsxKZjFVZ73pWIpOxKgtez0pkMlZlxetZiUzGqix5PSuRyViVNa9nJSoZazJ7Xiaz52Uye14ms+f1/GNamUpUMtZk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vExmz8tk9rxMZs/LZPa8TGbPy2T2vGyy5/VyZLKQ9XrE5kd8fmTNj8T8yJ4fyfmRmh/p+ZHx2/fHY37E5kd8fmTNj8T8yJ4fyfmRmh/p+ZH527f527f527f52/+Yv/3rjw7eozfv0cl7dPEe3bxHH9qjP6Yd//qjjfdo5z2aN43Om0bnTaPzptF50+i8aXTeNC7eNC7eNC7eNC7eNC7eNC7eNC7eNC7CNP78czv75ZO799tn8/FWRUtUcRSqiIdEFSZRhUtUsSSqCIkqtkQVKVGFRHaGRHaGRHZuiezcEtm5JbJzS2TnlsjOLZGdWyI7t0R2bons3BLZmRLZmbzfsSbvd6zJ+x1rBu/RvN+xJu93rMnjR8njR8njR8XjR8WbxuJNY/GmsXjTWLxpLN40Fm8aizeNxZvG5k1j86axedPYvGls3jT2/M/Ne/7n5j3/c/Oe/7n53JnxuTPjc2fG586Mz50ZnzszPndmfO7M+NyZ8bkz43NnZs2dmTV3ZtbcmVlzZ2Y9Yn5kz4/k/EjNj/T8yPztz52ZNXdm1tyZWTZ/+zZ/+zZ/+zZ/+zZ/+zZ/+zZ/+z5/+z5/+z5/+z5/+z5/+z5/+z5/+z5/+z5/+z5/+2v+9tf87a/523/fCYiKV5r0sN/45d6xVwv5ZP/zC/L084/22a/FnIfF24ftnLd6QqyeLVZPitVTYvW0WD1Hq573LYg/sB4Tq8fF6hHL5xDL5xDL5xDL5xDL5xDL5+Dl88sN+0G/weg3OP2GRb8h6Dds+g1Jv6HoNzT9BvpMJ32mkz7TSZ/ppM900mc66TOd9JlO+kwnfaaTPtNFn+miz3TRZ7o+PNP2iPXy4X/9wLlf/xXcr7KrCqFatlAtKVRLCdXSQrUcnVr6IVSLCdXiQrUI5W4L5W4L5W4L5W4L5W4L5W4L5e4Ryt0jlLtHKHePUO4eodw9Qrl7hHL3KOTuzz+X9boekueL9ZD1VrZCRANlK6T5uOx4KAQ/ULbCdwRQtsLXCVC2wjcPULbClxRQtsL3GVC2wlcfUPan/JaMx6f8lozH5/yWtM/5LWmf81vSPue3pH3Ob0n7nN+S9jm/Je1zfkva5/yWtM/5LWmf81vSP+e3pH/Ob0n/nN+S/jm/Jf1zfkv68Fvy9Vhixwo71tixAx1bD+yYYcccO7awY4Edw7pkYV2ysC5ZWJcsrEsC65LAuiSwLgmsSwLrksC6JLAuCaxLAuuS9937vd7+JqtnpP56Eq/1yJcPr7X87dMR73y49uuD6/y4C+Cvalu8L+r/ceWYVjmuVc7SKic+Xs62t3L2+bKc1zv2hTvy43d0v93xxb+rL+6o3+GO159mtJ5/TvLeHX3hjmF8vRzLB3bMsGOOHVvYscCObexYYscKO9bYMaxLCuuSwrqksC4prEsK65LCuqSwLimsSwrrksK6pLEuaaxLGuuS99XVbfZ2LH8ji3/r2/d9IfV3vWHTb0j6DUW/oek3HPYN70uZv+sNRr/B6TfQZ/rQZ/rQZ/rQZ/rQZ/rQZ/qwZ3o/HvQbjH6D029Y9BuCfsOm35D0G4p+Q9NvoM+00Wfa6DNt9Jk2+kwbfaaNPtNGn2mjz7TRZ9roM+30mXb6TDt9pp0+006faafPtNNn2ukz7fSZdvpML/pML/pML/pML/pML/pML/pML/pML/pML/pML/pMB32mgz7TQZ/poM900Gc66DMd9JkO+kwHfaaDPtObPtObPtObPtObPtObPtObPtObPtObPtObPtObPtNJn+mkz3TSZzrpM530mU76TCd9ppM+00mf6aTPdNFnuugzXfSZLvpMF32miz7TRZ/pos900We66DPd9Jlu+kw3fabpHtmme2Sb7pFtuke26R7Zpntkm+6RbbpHtuke2aZ7ZJvukW26R7bpHtmme2Sb7pFtuke26R5Z0j2ypHtkSffIku6R5SPoN2z6DUm/oeg3NP0G+kzTPbKke2RJ98iS7pEl3SNLukeWdI8s6R5Z0j2ypHtkSffIku6RJd0jS7pHlnSPLOkeWdI9sqR7ZEn3yJLukSXdI0u6R5Z0jyzpHlnSPbKke2RJ98iS7pEl3SNLukeWdI8s6R5Z0j2ypHtkSffIku6RJd0jS7pHlnSPLOkeWdI9sqR7ZEn3yJLukSXdI0u6R5Z0jyzpHlnSPbKke2RJ98iS7pEl3SNLukeWdI8s6R5Z0j2ypHtkSffIku6RJd0jS7pHlnSPLOkeWdI9sqR7ZEn3yJLukSXdI0u6R5Z0jyzpHlnSPbKke2RJ98iS7pEl3SNLukeWdI8s6R5Z0j2ypHtkSffIku6RJd0jS7pHlnSPLOkeWdI9sqR7ZEX3yIrukRXdIyu6R1aPoN+w6Tck/Yai39D0G+gzTffIiu6RFd0jK7pHVnSPrOgeWdE9sqJ7ZEX3yIrukRXdIyu6R1Z0j6zoHlnRPbKie2RF98iK7pEV3SMrukdWdI+s6B5Z0T2yontkRffIiu6RFd0jK7pHVnSPrOgeWdE9sqJ7ZEX3yIrukRXdIyu6R1Z0j6zoHlnRPbKie2RF98iK7pEV3SMrukdWdI+s6B5Z0T2yontkRffIiu6RFd0jK7pHVnSPrOgeWdE9sqJ7ZEX3yIrukRXdIyu6R1Z0j6zoHlnRPbKie2RF98iK7pEV3SMrukdWdI+s6B5Z0T2yontkRffIiu6RFd0jK7pHVnSPrOgeWdE9sqJ7ZEX3yIrukRXdIyu6R1Z0j6zoHlnRPbKie2RF98iK7pE13SNrukfWdI+s6R5ZP4J+w6bfkPQbin5D02+gzzTdI2u6R9Z0j6zpHlnTPbKme2RN98ia7pE13SNrukfWdI+s6R5Z0z2ypntkTffImu6RNd0ja7pH1nSPrOkeWdM9sqZ7ZE33yJrukTXdI2u6R9Z0j6zpHlnTPbKme2RN98ia7pE13SNrukfWdI+s6R5Z0z2ypntkTffImu6RNd0ja7pH1nSPrOkeWdM9sqZ7ZE33yJrukTXdI2u6R9Z0j6zpHlnTPbKme2RN98ia7pE13SNrukfWdI+s6R5Z0z2ypntkTffImu6RNd0ja7pH1nSPrOkeWdM9sqZ7ZE33yJrukTXdI2u6R9Z0j6zpHlnTPbKme2RN98ia7pE13SNrukfWdI+s6R5Z0z2ypntkTffImu6RNd0ja7pHduge2aF7ZIfukR26R3YeQb9h029I+g1Fv6HpN9Bnmu6RHbpHduge2aF7ZIfukR26R3boHtmhe2SH7pEdukd26B7ZoXtkh+6RHbpHduge2aF7ZIfukR26R3boHtmhe2SH7pEdukd26B7ZoXtkh+6RHbpHduge2aF7ZIfukR26R3boHtmhe2SH7pEdukd26B7ZoXtkh+6RHbpHduge2aF7ZIfukR26R3boHtmhe2SH7pEdukd26B7ZoXtkh+6RHbpHduge2aF7ZIfukR26R3boHtmhe2SH7pEdukd26B7ZoXtkh+6RHbpHduge2aF7ZIfukR26R3boHtmhe2SH7pEdukd26B7ZoXtkh+6RHbpHduge2aF7ZIfukR26R3boHtmhe2SH7pEdukd26B7ZoXtkh+6RHbpHduge2aF7ZIfukR22R+YPtkf2vMHoNzj9hkW/Ieg3bPoNSb+h6Dc0/Qb6TBt9po0+00afaaPPtNFn2ugzbfSZNvpMG32mjT7TTp9pp8+002fa6TPt9Jl2+kw7faadPtNOn2mnz/Siz/Siz/Siz/Siz/Siz/Siz/Siz/Siz/Siz/Siz3TQZzroMx30mQ76TAd9poM+00Gf6aDPdNBnOugzvekzvekzvekzvekzvekzvekzvekzvekzvekzvekznfSZTvpMJ32mkz7TSZ/ppM900mc66TOd9JlO+kwXfaaLPtNFn+miz3TRZ7roM130mS76TBd9pos+002f6abPdNNnuukz3fSZbvpMN32mmz7TTZ/pps/0oc/0oc/0oc/0oc/0oc/0oc/0oc/0oc/0oc803SMzukdmdI/M6B6Z0T0yewT9hk2/Iek3FP2Gpt9An2m6R2Z0j8zoHpnRPTKje2RG98iM7pEZ3SMzukdmdI/M6B6Z0T0yo3tkRvfIjO6RGd0jM7pHZnSPzOgemdE9MqN7ZEb3yIzukRndIzO6R2Z0j8zoHpnRPTKje2RG98iM7pEZ3SMzukdmdI/M6B6Z0T0yo3tkRvfIjO6RGd0jM7pHZnSPzOgemdE9MqN7ZEb3yIzukRndIzO6R2Z0j8zoHpnRPTKje2RG98iM7pEZ3SMzukdmdI/M6B6Z0T0yo3tkRvfIjO6RGd0jM7pHZnSPzOgemdE9MqN7ZEb3yIzukRndIzO6R2Z0j8zoHpnRPTKje2RG98iM7pEZ3SMzukdmdI/M6B6Z0T0yo3tkRvfIjO6RGd0jM7pHZnSPzOkemdM9Mqd7ZE73yPwR9Bs2/Yak31D0G5p+A32m6R6Z0z0yp3tkTvfInO6ROd0jc7pH5nSPzOkemdM9Mqd7ZE73yJzukTndI3O6R+Z0j8zpHpnTPTKne2RO98ic7pE53SNzukfmdI/M6R6Z0z0yp3tkTvfInO6ROd0jc7pH5nSPzOkemdM9Mqd7ZE73yJzukTndI3O6R+Z0j8zpHpnTPTKne2RO98ic7pE53SNzukfmdI/M6R6Z0z0yp3tkTvfInO6ROd0jc7pH5nSPzOkemdM9Mqd7ZE73yJzukTndI3O6R+Z0j8zpHpnTPTKne2RO98ic7pE53SNzukfmdI/M6R6Z0z0yp3tkTvfInO6ROd0jc7pH5nSPzOkemdM9Mqd7ZE73yJzukTndI3O6R+Z0j8zpHpnTPbJF98gW3SNbdI9s0T2y9Qj6DZt+Q9JvKPoNTb+BPtN0j2zRPbJF98gW3SNbdI9s0T2yRffIFt0jW3SPbNE9skX3yBbdI1t0j2zRPbJF98gW3SNbdI9s0T2yRffIFt0jW3SPbNE9skX3yBbdI1t0j2zRPbJF98gW3SNbdI9s0T2yRffIFt0jW3SPbNE9skX3yBbdI1t0j2zRPbJF98gW3SNbdI9s0T2yRffI1sc9MouzXz5s2368I9c7H/asl88+/9TgiwfXO599/vt9vHz4+S9iv3064q34EC7+8VvFfziJbHu8FZ8/Kf71jrxwR124oy/ccfh3fNyD+4o77MIdfuGOdeGOuHDHhTnPC3OeF+Y8L8x5XpjzujDndWHO68Kc14U5rwtzXhfmvC7MeV2Y87ow53VhzvvCnPeFOe8Lc94X5rwvzHlfmPO+MOd9Yc77wpz3hTk/F+b8XJjzc2HOz4U5Pxfm/FyY83Nhzs+FOT8X5vzw5zwejwt32IU7/MId68IdceGOfeGOvHBHXbijL9xxYc7twpzbhTm3C3NuF+bcLsy5XZhzuzDndmHO7cKc24U59wtz7hfm3C/MuV+Yc78w535hzv3CnPuFOfcLc+4X5nxdmPN1Yc7XhTlfF+Z8XZjzdWHO14U5XxfmfF2Y83VhzuPCnMeFOY8Lcx4X5jwuzHlcmPO4MOdxYc7jwpzHhTnfF+Z8X5jzfWHO94U53xfm/IIPFxd8uLjgw8UFHy4u+HBxwYeLCz5cXPDh4oIPFxd8uLjgw8UFHy4u+HBxwYeLCz5cXPDh4oIPFxd8uLjgw8UFHy4u+HBxwYeLCz5cXPDh4oIPFxd8uLjgw8UFHy4u+HBxwYeLCz5cXPDh4oIPFxd8uLjgw8UFHy4u+HBxwYeLCz5cXPDh4oIPFxd8uLjgw8UFHy4u+HD7gg+3L/hw+4IPty/4cPsRF+7YF+7IC3fUhTv6wh0X5vyCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cPuCD7cv+HD7gg+3L/hw+4IPty/4cHnBh8sLPlxe8OHygg+Xj7hwx75wR164oy7c0RfuuDDnF3y4vODD5QUfLi/4cHnBh8sLPlxe8OHygg+XF3y4vODD5QUfLi/4cHnBh8sLPlxe8OHygg+XF3y4vODD5QUfLi/4cHnBh8sLPlxe8OHygg+XF3y4vODD5QUfLi/4cHnBh8sLPlxe8OHygg+XF3y4vODD5QUfLi/4cHnBh8sLPlxe8OHygg+XF3y4vODD5QUfLi/4cHnBh8sLPlxe8OHygg+XF3y4vODD5QUfLi/4cHnBh8sLPlxe8OHygg+XF3y4vODD5QUfLi/4cHnBh8sLPlxe8OHygg+XF3y4vODD5QUfLi/4cHnBh8sLPlxe8OHygg+XF3y4vODD5QUfLi/4cHnBh8sLPlxe8OHygg+XF3y4nPpwr8ccO7awY4Ed29ixxI4VdqyxYwc5VlP16vWYYcccO7awY4Ed29ixxI4VdqyxY1iXGNYlhnWJYV1iWJcY1iWGdYlhXWJYlxjWJYZ1iWNd4liXONYljnWJY13iWJc41iWOdYljXeJYlyysSxbWJQvrkoV1ycK6ZGFdsrAuWViXLKxLFtYlgXVJYF0SWJcE1iWBdUlgXRJYlwTWJYF1SWBdsrEu2ViXbKxLNtYlG+uSjXXJxrpkY12ysS7ZWJck1iWJdUliXZJYlyTWJYl1SWJdkliXJNYliXVJYV1SWJcU1iWFdUlhXVJYlxTWJYV1SWFdUliXNNYljXVJY13SWJc01iWNdUljXdJYlzTWJY11ycG6BGOvhbHXwthrYey1MPZaGHstjL0Wxl4LY6+NsdfG2Gtj7LUx9toYe22MvTbGXhtjr42x18bYa2PstTH22hh7bYy9NsZeG2OvjbHXxthrY+y1MfbaGHttjL02xl4bY6+NsdfG2Gtj7LUx9toYe22MvTbGXhtjr42x18bYa2PstTH22hh7bYy9NsZeG2OvjbHXxthrY+y1MfbaGHttjL02xl4bY6+NsdfG2Gtj7LUx9toYe22MvTbGXhtjr42x18bYa2PstTH22hh7bYy9NsZeG2OvjbHXxthrY+y1MfbaGHttjL02xl4bY6+NsdfG2Gtj7LUx9toYe22MvTbGXhtjr42x18bYa2PstTH22hh7bYy9NsZeG2OvjbHXxthrY+y1MfbaGHttjL02xl4bY6+NsdfG2Gtj7LUx9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now9now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" }, { "name": "compute_note_hash_and_nullifier", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "contract_address", "type": { "kind": "struct", "path": "aztec::protocol_types::address::aztec_address::AztecAddress", "fields": [{ "name": "inner", "type": { "kind": "field" } }] }, "visibility": "private" }, { "name": "nonce", "type": { "kind": "field" }, "visibility": "private" }, { "name": "storage_slot", "type": { "kind": "field" }, "visibility": "private" }, { "name": "note_type_id", "type": { "kind": "field" }, "visibility": "private" }, { "name": "serialized_note", "type": { "kind": "array", "length": 20, "type": { "kind": "field" } }, "visibility": "private" }], "param_witnesses": { "contract_address": [{ "start": 0, "end": 1 }], "nonce": [{ "start": 1, "end": 2 }], "note_type_id": [{ "start": 3, "end": 4 }], "serialized_note": [{ "start": 4, "end": 24 }], "storage_slot": [{ "start": 2, "end": 3 }] }, "return_type": { "abi_type": { "kind": "array", "length": 4, "type": { "kind": "field" } }, "visibility": "public" }, "return_witnesses": [24, 25, 26, 27] }, "bytecode": "H4sIAAAAAAAA/+2YzW6DMAyATYECBbq/bmXrJnHcsUg99MhD7AWqDmm9tFNhe/xpuIuFoesuMwdLtRQlhBB/dkKwmQGABT9i18WFY6H7uann/5NMcK55n5yWEs6BEk5bkBPZJtDvPnV68Ks0o6uAcaiA0VPA6CtgDBQwjhQwhgoYIwWMsQLGsQLGCwWMlwoYrxQwXitgvFHAOFHAeKuA8U4B41SQ0WKMjmkndbmvy0NdZnVZmn4fGsmlGBbZGmN2Up5AWzA2GdCF0/TZxM36iH/A+ugfg+00NgzFbZgvcF5Pel6TKyTM/468/5c+85Mge18+OexZ2ouU75Eel/kqMG3BfysZ122ZEjCdYNaI2lM2lsaRP2hfE3sEzd4M/njO6TwXszHDX+zPQdZ+r8PjdZhdYwsKxkmJ0/ilyyb53wvnHcnP21pzt7MmpI+v+ZOpL0xfJL8OixDa5zHZzCVn7Yj5PpTnyXqy87CmsZnrC2TPkHHHV37HVzEbEzP/jXvwn8X00tx0TfrOzGfmU8whtN9x6uP3qR50bOHxFI0P4Pg8ETWIFPKAzzJweA8PVDxs8YPmQfPRGDFjaRHwoMUPDSa8mFBiwoYJESYcGNBPmY5TQS4PhEkeTf1s6pe3TZmud9tqv1pX6euuKNPtrko/yiJ9328+V1WB10UJ3zr8F0fqGgAA", "debug_symbols": "nZBLCoAgFEX38sYSEX3MrUSDVxkIYqIWhLj3fEQLyNn9cCYngj5WDOowHkSEumpaEFMEb9HQ4AO6AKLhHQNptpzGOjHYlZa08jQzgroSqC+BhhKI/4Ryu9ApXLQkLXSeZv0s5Rpu+z7pAQ==" }, { "name": "fetch_price", "is_unconstrained": true, "custom_attributes": [], "abi": { "parameters": [{ "name": "assetId", "type": { "kind": "field" }, "visibility": "private" }], "param_witnesses": { "assetId": [{ "start": 0, "end": 1 }] }, "return_type": { "abi_type": { "kind": "struct", "path": "asset::Asset", "fields": [{ "name": "price", "type": { "kind": "struct", "path": "std::uint128::U128", "fields": [{ "name": "lo", "type": { "kind": "field" } }, { "name": "hi", "type": { "kind": "field" } }] } }] }, "visibility": "public" }, "return_witnesses": [1, 2] }, "bytecode": "H4sIAAAAAAAA/81XwY7aMBC1k0ACWViuVdXKX7Bytr21h7Q999JeekPZEiokIFJs1G0/flUCM+Wta3W1wpEYCcYZO/PePBvbREIIKY4WQxuNYyV5fZ4VAXPpyMOzi32jdgb9ZSjct/rNsEuSPMZly4mDgDEpfbhfJieuf99JTvPQ2cwzrqtnELoerW9zwHX1RP3YBsAnCc+n6KlO3eUdUq6HgHw7rVJHq9jRagJjhqBf2oN+EnA5Nz8z3nM5RxfAGdeFEmHXRRa+ptvpPscIdM0cfbGuMbUDrkstCJ8xGW8MuFfUlgFxu1w54ErgwXgJjHlN/loc15zw6DMKPz/F//Y4xkM+8gL45MJ/5owczfAcwr7P0M+14Tk0pXbsyT2BGM/d1PMu6jSBWkpq6/PsoBNilfDMeFfAY3ohfFIPn772Up4fzs3P6YVg9zAPh338uqeaZpRrSHmZP+MlMOY99OG7zMv9PeHa4LGRR7cH8Xjvec5ZsXzCEDsF7JGnvk9Qn49nSXHcs5gvPuMdhMdmgHPGWVi4AeQXA4cZcHJrzsVpfn37ag4+Bk04RwbxkPdNvMeWAfN2dfB9XsAcoZXQxntsD/f1YgwaG9u01Y/6S10tJFBLHJropaeMCGLYjj0xQfBcZgIxXg4DiEWOLLgscJn/8ze7JK/Ps8M+FTsFC0/Bktq+sa/I8x729ai7MuvGKq22++9qvW5+1osbhX1GbXbGKmOr1qpl22xUcYN535F/Qf5D21a/1Gq7qO9Vs7OqWaq7ZrddGHzpI/mX5L/voZVtVGVM3dr5prqf363s3Kx+1+IP650NWs0QAAA=", "debug_symbols": "5ZrdasJAEIXfZa+lzOzO7s76KqUXaWtBEBW1hSK+eyMma0qC0rQpJ+TOJWcy38D65YcczWrzUhyWm/XezI+GHqKZPx7Nflusz+v9odgdzDwGNzOL9Wv5S9NpZt6Wq4WZW9XTrJVN7KtsCpqzgTqimjzVWWLJYU7p9DQrYRQJJiHBMEHRMBSNhaJxUDQCReOhaAIUDZSJGUrFDOViC+ViC+ViC+ViC+Vi+2sXM0kdZia6zVPD0J2ThqhVMiR/PaWroP0YocMYoeMYoXWM0GmE0O7eVSeFe9DMMUOLNju0wy7aKivsri6jWNEwFI2FonFQNAJF46FoAhRNhKJRKJqERCNQLhYoFwuUiwXKxQLlYoFysUC5WKBcLFAuFigXeygX+yFdfOlgB+/gBu8gg3f4A7d5zR2Ubu8KCVzvith8zKt3RYCiiVA0CkWTkGgCQdEwFI39XxrJ3o/8jabjGuEoVGHnnM1pkY5wzBAxXV8aW6qmdJOYUiYxpZ/ElGESU0bgKT3nKX1qTnlB1/GiJ2B01Yze2DA1eiRk9Ppe2gm5NjqPF73zb2pDLiJpP8NF7VOUehQp9SniPkX2h0Xl6qPYLYvn1eL8peD54Pv6pf5wsFwePreXI6cv" }], "events": [], "file_map": { "3": { "source": "struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n", "path": "std/collections/bounded_vec.nr" }, "20": { "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n", "path": "std/field.nr" }, "35": { "source": "struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n", "path": "std/option.nr" }, "44": { "source": "use crate::ops::{Add, Sub, Mul, Div, Rem, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\n\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<N>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else if ascii < 71 {\n            ascii - 55\n        } else {\n            ascii - 87\n        } as Field\n    }\n\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if self < b {\n            (U128::from_u64s_le(0, 0), self)\n        } else {\n            //TODO check if this can overflow?\n            let (q,r) = self.unconstrained_div(b * U128::from_u64s_le(2, 0));\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::from_u64s_le(1, 0), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64))as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift left with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: U128) -> U128 { \n        assert(other < U128::from_u64s_le(128,0), \"attempt to shift right with overflow\");\n        let exp_bits = other.lo.to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n", "path": "std/uint128.nr" }, "60": { "source": "use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr" }, "63": { "source": "use crate::context::{Context};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T> Storage<T> for PublicMutable<T> {}\n\nimpl<T> PublicMutable<T> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable reads only supported in public functions\");\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        assert(self.context.private.is_none(), \"PublicMutable writes only supported in public functions\");\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr" }, "77": { "source": "use crate::{\n    context::{inputs::PublicContextInputs, interface::ContextInterface},\n    messaging::process_l1_to_l2_message, oracle::{arguments, public_call::call_public_function_internal}\n};\nuse dep::protocol_types::{\n    abis::{\n    global_variables::GlobalVariables, function_selector::FunctionSelector,\n    private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem,\n    public_circuit_public_inputs::PublicCircuitPublicInputs, read_request::ReadRequest,\n    side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256, RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::hash_args, header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader\n};\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n    side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    nullifier_non_existent_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL>,\n    contract_storage_update_requests: BoundedVec<StorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_reads: BoundedVec<StorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack_hashes: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n    prover_address: AztecAddress,\n}\n\nimpl ContextInterface for PublicContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash {\n            value: nullifier,\n            note_hash: 0, // cannot nullify pending notes in public context\n            counter: self.side_effect_counter\n        };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs, args_hash: Field) -> PublicContext {\n        PublicContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            nullifier_non_existent_read_requests: BoundedVec::new(),\n            contract_storage_update_requests: BoundedVec::new(),\n            contract_storage_reads: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            unencrypted_logs_hash: BoundedVec::new(),\n            unencrypted_logs_preimages_length: 0,\n            historical_header: inputs.historical_header,\n            prover_address: AztecAddress::zero() // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    pub fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    pub fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    pub fn coinbase(self) -> EthAddress {\n        self.inputs.public_global_variables.coinbase\n    }\n\n    pub fn fee_recipient(self) -> AztecAddress {\n        self.inputs.public_global_variables.fee_recipient\n    }\n\n    pub fn finish(self) -> PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            nullifier_non_existent_read_requests: self.nullifier_non_existent_read_requests.storage,\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_reads: self.contract_storage_reads.storage,\n            return_values: self.return_values.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            unencrypted_logs_hash,\n            unencrypted_log_preimages_length,\n            historical_header: self.inputs.historical_header,\n            prover_address: self.prover_address,\n            reverted: false\n        };\n        pub_circuit_pub_inputs\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn push_nullifier_non_existent_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.side_effect_counter };\n        self.nullifier_non_existent_read_requests.push(request);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            this,\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let side_effect_counter = self.side_effect_counter;\n        // TODO get next value from output of `call_public_function_internal`\n        self.side_effect_counter += 1;\n\n        call_public_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        )\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr" }, "87": { "source": "use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/hasher.nr" }, "107": { "source": "use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nfn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nfn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr" }, "110": { "source": "mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n    public_vm: Option<&mut AVMContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none(), public_vm: Option::none() }\n    }\n\n    pub fn public_vm(context: &mut AVMContext) -> Context {\n        Context { public_vm: Option::some(context), public: Option::none(), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none(), public_vm: Option::none() }\n    }\n}\n", "path": "/usr/src/noir-projects/aztec-nr/aztec/src/context.nr" }, "199": { "source": "use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, FUNCTION_TREE_HEIGHT, NUM_FIELDS_PER_SHA256,\n    GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK,\n    GENERATOR_INDEX__CONSTRUCTOR, GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\nuse crate::merkle_tree::root::root_from_sibling_path;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr" }, "202": { "source": "global ARGS_LENGTH: u64 = 16;\nglobal RETURN_VALUES_LENGTH: u64 = 4;\n\n/**\n * Convention for constant array lengths are mainly divided in 2 classes:\n *  - FUNCTION CALL\n *  - TRANSACTION\n *\n * Agreed convention is to use MAX_XXX_PER_CALL resp. MAX_XXX_PER_TX, where XXX denotes a type of element such as\n * commitment, or nullifier, e.g.,:\n *  - MAX_NEW_NULLIFIERS_PER_CALL\n *  - MAX_NEW_NOTE_HASHES_PER_TX\n *\n * In the kernel circuits, we accumulate elements such as note hashes and the nullifiers from all functions calls in a\n * transaction. Therefore, we always must have:\n * MAX_XXX_PER_TX ≥ MAX_XXX_PER_CALL\n *\n * For instance:\n * MAX_NEW_NOTE_HASHES_PER_TX ≥ MAX_NEW_NOTE_HASHES_PER_CALL\n * MAX_NEW_NULLIFIERS_PER_TX ≥ MAX_NEW_NULLIFIERS_PER_CALL\n *\n */\n\n// docs:start:constants\n// \"PER CALL\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_CALL: u64 = 16;\nglobal MAX_NEW_NULLIFIERS_PER_CALL: u64 = 16;\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL: u64 = 4;\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_CALL: u64 = 2;\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL: u64 = 16;\nglobal MAX_PUBLIC_DATA_READS_PER_CALL: u64 = 16;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_CALL: u64 = 32;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_CALL: u64 = 2; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL: u64 = 2;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL: u64 = 1;\n\n// \"PER TRANSACTION\" CONSTANTS\nglobal MAX_NEW_NOTE_HASHES_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NOTE_HASHES_PER_TX: u64 = 56;\n\nglobal MAX_NEW_NULLIFIERS_PER_TX: u64 = 64;\nglobal MAX_NON_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 8;\nglobal MAX_REVERTIBLE_NULLIFIERS_PER_TX: u64 = 56;\n\nglobal MAX_PRIVATE_CALL_STACK_LENGTH_PER_TX: u64 = 8;\n\nglobal MAX_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 8;\nglobal MAX_NON_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 3;\nglobal MAX_REVERTIBLE_PUBLIC_CALL_STACK_LENGTH_PER_TX: u64 = 5;\n\nglobal MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX: u64 = 16;\n\nglobal MAX_PUBLIC_DATA_READS_PER_TX: u64 = 32;\nglobal MAX_NON_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\nglobal MAX_REVERTIBLE_PUBLIC_DATA_READS_PER_TX: u64 = 16;\n\nglobal MAX_NEW_L2_TO_L1_MSGS_PER_TX: u64 = 2;\nglobal MAX_NOTE_HASH_READ_REQUESTS_PER_TX: u64 = 128;\nglobal MAX_NULLIFIER_READ_REQUESTS_PER_TX: u64 = 8; // Change it to a larger value when there's a seperate reset circuit.\nglobal MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_TX: u64 = 8;\nglobal MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_TX: u64 = 4;\nglobal NUM_ENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\nglobal NUM_UNENCRYPTED_LOGS_HASHES_PER_TX: u64 = 1;\n// docs:end:constants\n\n// ROLLUP CONTRACT CONSTANTS - constants used only in l1-contracts\nglobal NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP: u64 = 16;\n\n// TREES RELATED CONSTANTS\nglobal VK_TREE_HEIGHT: u64 = 3;\nglobal FUNCTION_TREE_HEIGHT: u64 = 5;\nglobal NOTE_HASH_TREE_HEIGHT: u64 = 32;\nglobal PUBLIC_DATA_TREE_HEIGHT: u64 = 40;\nglobal NULLIFIER_TREE_HEIGHT: u64 = 20;\nglobal L1_TO_L2_MSG_TREE_HEIGHT: u64 = 16;\nglobal ROLLUP_VK_TREE_HEIGHT: u64 = 8;\nglobal ARTIFACT_FUNCTION_TREE_MAX_HEIGHT = 5;\nglobal NULLIFIER_TREE_ID = 0;\nglobal NOTE_HASH_TREE_ID = 1;\nglobal PUBLIC_DATA_TREE_ID = 2;\nglobal L1_TO_L2_MESSAGE_TREE_ID = 3;\nglobal ARCHIVE_TREE_ID = 4;\n\n// SUB-TREES RELATED CONSTANTS\nglobal NOTE_HASH_SUBTREE_HEIGHT: u64 = 6;\nglobal NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH: u64 = 26;\nglobal NULLIFIER_SUBTREE_HEIGHT: u64 = 6;\nglobal PUBLIC_DATA_SUBTREE_HEIGHT: u64 = 5;\nglobal ARCHIVE_HEIGHT: u64 = 16;\nglobal NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH: u64 = 14;\nglobal PUBLIC_DATA_SUBTREE_SIBLING_PATH_LENGTH: u64 = 35;\nglobal L1_TO_L2_MSG_SUBTREE_HEIGHT: u64 = 4;\nglobal L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH: u64 = 12;\n\n// MISC CONSTANTS\nglobal FUNCTION_SELECTOR_NUM_BYTES: Field = 4;\n// sha256 hash is stored in two fields to accommodate all 256-bits of the hash\nglobal NUM_FIELDS_PER_SHA256: u64 = 2;\nglobal ARGS_HASH_CHUNK_LENGTH: u64 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u64 = 32;\n// The following is used in immutable state variables to compute an initialization slot whose value is used to\n// determine whether a given variable has been initialized (by asserting that the value in the slot is 0).\n// The initialization slot is computed by adding the constant bellow to the variable's storage slot. This constant has\n// to be large enough so that it's ensured that it doesn't collide with storage slots of other variables.\nglobal INITIALIZATION_SLOT_SEPARATOR: Field = 1000_000_000;\nglobal INITIAL_L2_BLOCK_NUM: Field = 1;\n// 126976 = 31 * 4096;\nglobal BLOB_SIZE_IN_BYTES: Field = 126976;\n\n// CONTRACT CLASS CONSTANTS\nglobal MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS: u64 = 15000;\n// Bytecode size for private functions is per function, not for the entire contract.\n// Note that private functions bytecode includes a mix of acir and brillig.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS: u64 = 500;\n// Same for unconstrained functions: the size is per function.\nglobal MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS: u64 = 500;\n// Since we are not yet emitting selectors we'll use this magic value to identify events emitted by the ClassRegisterer.\n// This is just a stopgap until we implement proper selectors.\n// sha224sum 'struct ContractClassRegistered {contract_class_id: ContractClassId, version: Field, artifact_hash: Field, private_functions_root: Field, packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] }'\nglobal REGISTERER_CONTRACT_CLASS_REGISTERED_MAGIC_VALUE = 0x6999d1e02b08a447a463563453cb36919c9dd7150336fc7c4d2b52f8;\n// sha224sum 'struct ClassPrivateFunctionBroadcasted'\nglobal REGISTERER_PRIVATE_FUNCTION_BROADCASTED_MAGIC_VALUE = 0x1b70e95fde0b70adc30496b90a327af6a5e383e028e7a43211a07bcd;\n// sha224sum 'struct ClassUnconstrainedFunctionBroadcasted'\nglobal REGISTERER_UNCONSTRAINED_FUNCTION_BROADCASTED_MAGIC_VALUE = 0xe7af816635466f128568edb04c9fa024f6c87fb9010fdbffa68b3d99;\n\n// CONTRACT INSTANCE CONSTANTS\n// sha224sum 'struct ContractInstanceDeployed'\nglobal DEPLOYER_CONTRACT_INSTANCE_DEPLOYED_MAGIC_VALUE = 0x85864497636cf755ae7bde03f267ce01a520981c21c3682aaf82a631;\nglobal DEPLOYER_CONTRACT_ADDRESS = 0x0bffa876f07f9fe1802579dfef599810202f9c25b9a2f58921064a267d1ad1d3;\n\n// NOIR CONSTANTS - constants used only in yarn-packages/noir-contracts\n// Some are defined here because Noir doesn't yet support globals referencing other globals yet.\n// Move these constants to a noir file once the issue below is resolved:\n// https://github.com/noir-lang/noir/issues/1734\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\nglobal MAX_NOTE_FIELDS_LENGTH: u64 = 20;\n// GET_NOTE_ORACLE_RETURN_LENGT = MAX_NOTE_FIELDS_LENGTH + 1 + 2\n// The plus 1 is 1 extra field for nonce.\n// + 2 for EXTRA_DATA: [number_of_return_notes, contract_address]\nglobal GET_NOTE_ORACLE_RETURN_LENGTH: u64 = 23;\nglobal MAX_NOTES_PER_PAGE: u64 = 10;\n// VIEW_NOTE_ORACLE_RETURN_LENGTH = MAX_NOTES_PER_PAGE * (MAX_NOTE_FIELDS_LENGTH + 1) + 2;\nglobal VIEW_NOTE_ORACLE_RETURN_LENGTH: u64 = 212;\n\n// LENGTH OF STRUCTS SERIALIZED TO FIELDS\nglobal AZTEC_ADDRESS_LENGTH = 1;\nglobal CALL_CONTEXT_LENGTH: u64 = 7;\nglobal CONTENT_COMMITMENT_LENGTH: u64 = 7;\nglobal CONTRACT_INSTANCE_LENGTH: u64 = 6;\nglobal CONTRACT_STORAGE_READ_LENGTH: u64 = 2;\nglobal CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH: u64 = 2;\nglobal ETH_ADDRESS_LENGTH = 1;\nglobal FUNCTION_DATA_LENGTH: u64 = 4;\nglobal FUNCTION_LEAF_PREIMAGE_LENGTH: u64 = 5;\nglobal GLOBAL_VARIABLES_LENGTH: u64 = 6;\nglobal HEADER_LENGTH: u64 = 23; // 2 for last_archive, 7 for content commitment, 8 for state reference, 6 for global vars\nglobal L1_TO_L2_MESSAGE_LENGTH: u64 = 8;\nglobal L2_TO_L1_MESSAGE_LENGTH: u64 = 2;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_LENGTH = 4;\nglobal NULLIFIER_KEY_VALIDATION_REQUEST_CONTEXT_LENGTH = 5;\nglobal PARTIAL_STATE_REFERENCE_LENGTH: u64 = 6;\nglobal PRIVATE_CALL_STACK_ITEM_LENGTH: u64 = 215;\n// Change this ONLY if you have changed the PrivateCircuitPublicInputs structure.\n// In other words, if the structure/size of the public inputs of a function call changes then we should change this\n// constant as well PRIVATE_CALL_STACK_ITEM_LENGTH\nglobal PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 210;\n// Change this ONLY if you have changed the PublicCircuitPublicInputs structure.\nglobal PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH: u64 = 202;\nglobal STATE_REFERENCE_LENGTH: u64 = 8; // 2 for snap + 8 for partial\nglobal TX_CONTEXT_DATA_LENGTH: u64 = 4;\nglobal TX_REQUEST_LENGTH: u64 = 10;\n\nglobal ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH: Field = 13; // 2 + FUNCTION_DATA_LENGTH + CALL_CONTEXT_LENGTH\nglobal GET_NOTES_ORACLE_RETURN_LENGTH: u64 = 674;\nglobal NOTE_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal NULLIFIERS_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal PUBLIC_DATA_WRITES_NUM_BYTES_PER_BASE_ROLLUP: Field = 2048;\nglobal CONTRACTS_NUM_BYTES_PER_BASE_ROLLUP: Field = 32;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal CONTRACT_DATA_NUM_BYTES_PER_BASE_ROLLUP_UNPADDED: Field = 52;\nglobal L2_TO_L1_MSGS_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal LOGS_HASHES_NUM_BYTES_PER_BASE_ROLLUP: Field = 64;\nglobal NUM_MSGS_PER_BASE_PARITY: u64 = 4;\n// NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP / NUM_MSGS_PER_BASE_PARITY\nglobal NUM_BASE_PARITY_PER_ROOT_PARITY: u64 = 4;\n\n/**\n * Enumerate the hash_indices which are used for pedersen hashing.\n * We start from 1 to avoid the default generators. The generator indices are listed\n * based on the number of elements each index hashes. The following conditions must be met:\n *\n * +-----------+-------------------------------+----------------------+\n * | Hash size | Number of elements hashed (n) | Condition to use     |\n * |-----------+-------------------------------+----------------------|\n * | LOW       | n ≤ 8                         | 0 < hash_index ≤ 32  |\n * | MID       | 8 < n ≤ 16                    | 32 < hash_index ≤ 40 |\n * | HIGH      | 16 < n ≤ 48                   | 40 < hash_index ≤ 48 |\n * +-----------+-------------------------------+----------------------+\n *\n * Note: When modifying, modify `GeneratorIndexPacker` in packer.hpp accordingly.\n */\n// Indices with size ≤ 8\nglobal GENERATOR_INDEX__NOTE_HASH = 1;\nglobal GENERATOR_INDEX__NOTE_HASH_NONCE = 2;\nglobal GENERATOR_INDEX__UNIQUE_NOTE_HASH = 3;\nglobal GENERATOR_INDEX__SILOED_NOTE_HASH = 4;\nglobal GENERATOR_INDEX__NULLIFIER = 5;\nglobal GENERATOR_INDEX__INITIALIZATION_NULLIFIER = 6;\nglobal GENERATOR_INDEX__OUTER_NULLIFIER = 7;\nglobal GENERATOR_INDEX__PUBLIC_DATA_READ = 8;\nglobal GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST = 9;\nglobal GENERATOR_INDEX__FUNCTION_DATA = 10;\nglobal GENERATOR_INDEX__FUNCTION_LEAF = 11;\nglobal GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA = 12;\nglobal GENERATOR_INDEX__CONSTRUCTOR = 13;\nglobal GENERATOR_INDEX__CONSTRUCTOR_ARGS = 14;\nglobal GENERATOR_INDEX__CONTRACT_ADDRESS = 15;\nglobal GENERATOR_INDEX__CONTRACT_LEAF = 16;\nglobal GENERATOR_INDEX__CALL_CONTEXT = 17;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM = 18;\nglobal GENERATOR_INDEX__CALL_STACK_ITEM_2 = 19;\nglobal GENERATOR_INDEX__L1_TO_L2_MESSAGE_SECRET = 20;\nglobal GENERATOR_INDEX__L2_TO_L1_MSG = 21;\nglobal GENERATOR_INDEX__TX_CONTEXT = 22;\nglobal GENERATOR_INDEX__PUBLIC_LEAF_INDEX = 23;\nglobal GENERATOR_INDEX__PUBLIC_DATA_LEAF = 24;\nglobal GENERATOR_INDEX__SIGNED_TX_REQUEST = 25;\nglobal GENERATOR_INDEX__GLOBAL_VARIABLES = 26;\nglobal GENERATOR_INDEX__PARTIAL_ADDRESS = 27;\nglobal GENERATOR_INDEX__BLOCK_HASH = 28;\nglobal GENERATOR_INDEX__SIDE_EFFECT = 29;\nglobal GENERATOR_INDEX__FEE_PAYLOAD = 30;\n// Indices with size ≤ 16\nglobal GENERATOR_INDEX__TX_REQUEST = 33;\nglobal GENERATOR_INDEX__SIGNATURE_PAYLOAD = 34;\n// Indices with size ≤ 44\nglobal GENERATOR_INDEX__VK = 41;\nglobal GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS = 42;\nglobal GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS = 43;\nglobal GENERATOR_INDEX__FUNCTION_ARGS = 44;\nglobal GENERATOR_INDEX__AUTHWIT_INNER = 45;\nglobal GENERATOR_INDEX__AUTHWIT_OUTER = 46;\n", "path": "/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/constants.nr" }, "287": { "source": "use dep::aztec::protocol_types::traits::{Serialize, Deserialize};\n\nstruct Asset {\n    price: U128,\n}\n\nglobal ASSET_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<ASSET_SERIALIZED_LEN> for Asset {\n    fn serialize(asset: Asset) -> [Field; ASSET_SERIALIZED_LEN] {\n        [asset.price.to_integer()]\n    }\n}\n\nimpl Deserialize<ASSET_SERIALIZED_LEN> for Asset {\n    fn deserialize(fields: [Field; ASSET_SERIALIZED_LEN]) -> Asset {\n        let price = U128::from_integer(fields[0]);\n        Asset { price }\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/price_feed_contract/src/asset.nr" }, "288": { "source": "mod asset;\n\ncontract PriceFeed {\n    use dep::aztec::prelude::{AztecAddress, FunctionSelector, PrivateContext, Map, PublicMutable};\n    use dep::aztec::{context::{PublicContext, Context}};\n    use crate::asset::Asset;\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    struct Storage {\n        assets: Map<Field, PublicMutable<Asset>>,\n    }\n\n    #[aztec(public)]\n    fn set_price(asset_id: Field, price: Field) {\n        let asset = storage.assets.at(asset_id);\n        asset.write(Asset { price: U128::from_integer(price) });\n    }\n\n    #[aztec(public)]\n    fn get_price(asset_id: Field) -> Asset {\n        storage.assets.at(asset_id).read()\n    }\n\n    unconstrained fn fetch_price(assetId: Field) -> pub Asset {\n        storage.assets.at(assetId).read()\n    }\n}\n", "path": "/usr/src/noir-projects/noir-contracts/contracts/price_feed_contract/src/main.nr" } } }
